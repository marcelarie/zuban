[case callable_cannot_infer_type_var_mypy_compatible]
# flags: --mypy-compatible
from typing import TypeVar, Callable
T1 = TypeVar("T1")
x: Callable[[T1, T1], T1]
reveal_type(x(1, "")) # N: Revealed type is "object"

T2 = TypeVar("T2", int, str)
y: Callable[[T2, T2], T2]

y(1, "") # E: Argument 2 has incompatible type "str"; expected "int"

[case callable_cannot_infer_type_var_no_mypy_compatible]
# flags: --no-mypy-compatible
from typing import TypeVar, Callable
T1 = TypeVar("T1")
x: Callable[[T1, T1], T1]
reveal_type(x(1, "")) # N: Revealed type is "int | str"

T2 = TypeVar("T2", int, str)
y: Callable[[T2, T2], T2]

y(1, "") # E: Argument 2 has incompatible type "str"; expected "int"

[case callable_return_from_function_simple]
from typing import Callable, TypeVar, Tuple

T = TypeVar('T')
U = TypeVar('U')

def return_callable1(x: T) -> Callable[[U], Tuple[T, U]]: ...

reveal_type(return_callable1(7)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(return_callable1(7)("")) # N: Revealed type is "tuple[int, str]"

def return_callable2() -> Callable[[U], Tuple[T, U]]: ...

reveal_type(return_callable2())  # N: Revealed type is "def [U, T] (U) -> tuple[T, U]"
reveal_type(return_callable2()(1))  # N: Revealed type is "tuple[Never, int]"

[case callable_return_from_function_simple_with_context]
from typing import Callable, TypeVar, Tuple

T = TypeVar('T')
U = TypeVar('U')

def return_callable1(x: T) -> Callable[[U], Tuple[T, U]]: ...

x: Tuple[int, str] = return_callable1(7)("")
y: Tuple[int, bytes] = return_callable1(7)("") # E: Argument 1 has incompatible type "str"; expected "bytes"
z: Tuple[bytes, str] = return_callable1(7)("") # E: Incompatible types in assignment (expression has type "tuple[int, str]", variable has type "tuple[bytes, str]")
a: Tuple[bytes, bytes] = return_callable1(7)("") # E: Argument 1 has incompatible type "str"; expected "bytes" \
                                                 # E: Incompatible types in assignment (expression has type "tuple[int, bytes]", variable has type "tuple[bytes, bytes]")

def return_callable2() -> Callable[[U], Tuple[T, U]]: ...

[case callable_return_from_method_simple]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable3(self, x: T) -> Callable[[U], Tuple[T, U, V]]: ...

reveal_type(Foo(1.0).return_callable3(7)) # N: Revealed type is "def [U] (U) -> tuple[int, U, float]"
reveal_type(Foo(1.0).return_callable3(7)("")) # N: Revealed type is "tuple[int, str, float]"

[case callable_return_from_method_no_params]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable4(self) -> Callable[[U], Tuple[T, U, V]]: ...

reveal_type(Foo(1.0).return_callable4()) # N: Revealed type is "def [U, T] (U) -> tuple[T, U, float]"
reveal_type(Foo(1.0).return_callable4()("")) # N: Revealed type is "tuple[Never, str, float]"

[case callable_return_from_method_nested_simple]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable5(self, x: T) -> Callable[[U], Callable[[W], Tuple[T, U, V, W]]]: ...

c = Foo(1.0).return_callable5(1)
reveal_type(c) # N: Revealed type is "def [U] (U) -> def [W] (W) -> tuple[int, U, float, W]"
reveal_type(c("")) # N: Revealed type is "def [W] (W) -> tuple[int, str, float, W]"
reveal_type(c("")(b"")) # N: Revealed type is "tuple[int, str, float, bytes]"

[case callable_return_from_method_nested_multiple1]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable6(self, x: T) -> Callable[[U], Tuple[Callable[[W], Tuple[T, U, V, W]],
                                                            Callable[[W], Tuple[T, U, V, W]]
                                                            ]]: ...

c = Foo(1.0).return_callable6(1)
reveal_type(c) # N: Revealed type is "def [U, W] (U) -> tuple[def (W) -> tuple[int, U, float, W], def (W) -> tuple[int, U, float, W]]"
reveal_type(c("")) # N: Revealed type is "tuple[def (Never) -> tuple[int, str, float, Never], def (Never) -> tuple[int, str, float, Never]]"
reveal_type(c("")[0](b"")) # N: Revealed type is "tuple[int, str, float, Never]" \
                           # E: Argument 1 has incompatible type "bytes"; expected "Never"
reveal_type(c("")[1](b"")) # N: Revealed type is "tuple[int, str, float, Never]" \
                           # E: Argument 1 has incompatible type "bytes"; expected "Never"

[case callable_return_from_method_nested_multiple2]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')
X = TypeVar('X')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable7(self, x: T) -> Callable[[U], Tuple[Callable[[W], Tuple[T, U, V, W]],
                                                            Callable[[X], Tuple[T, U, V, X]]
                                                            ]]: ...
c = Foo(1.0).return_callable7(1)
reveal_type(c) # N: Revealed type is "def [U] (U) -> tuple[def [W] (W) -> tuple[int, U, float, W], def [X] (X) -> tuple[int, U, float, X]]"
reveal_type(c("")) # N: Revealed type is "tuple[def [W] (W) -> tuple[int, str, float, W], def [X] (X) -> tuple[int, str, float, X]]"
reveal_type(c("")[0](b"")) # N: Revealed type is "tuple[int, str, float, bytes]"
reveal_type(c("")[1](b"")) # N: Revealed type is "tuple[int, str, float, bytes]"

[case callable_on_annotation_nested]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_annotation_nested]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_type_comment]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x = any # type: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_type_comment_tuple_without_parentheses]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: Callable[[T], Callable[[U], Tuple[T, U]]], str

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"
reveal_type(y) # N: Revealed type is "str"

[case callable_on_type_comment_tuple_with_parentheses]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: (Callable[[T], Callable[[U], Tuple[T, U]]], str)

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"
reveal_type(y) # N: Revealed type is "str"

[case callable_on_type_comment_with_unbound]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: Tuple[Callable[[T], Tuple[T, U]], U]

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, Never]"
reveal_type(y) # N: Revealed type is "Any"

[out]
__main__:7: error: Type variable "__main__.U" is unbound
__main__:7: note: (Hint: Use "Generic[U]" or "Protocol[U]" base class to bind "U" inside a class)
__main__:7: note: (Hint: Use "U" in function signature to bind "U" inside a function)

[case callable_on_type_comment_tuple_with_unbound]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: (Callable[[T], Tuple[T, U]], U)

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, Never]"
reveal_type(y) # N: Revealed type is "Any"

[out]
__main__:7: error: Type variable "__main__.U" is unbound
__main__:7: note: (Hint: Use "Generic[U]" or "Protocol[U]" base class to bind "U" inside a class)
__main__:7: note: (Hint: Use "U" in function signature to bind "U" inside a function)

[case callable_on_cast_target]
from typing import Callable, TypeVar, Tuple, cast

T = TypeVar('T')
U = TypeVar('U')

x = cast(Callable[[T], Tuple[T, U]], None)

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, Never]"

[out]

[case callable_on_cast_target_with_unbound]
from typing import Callable, TypeVar, Tuple, cast

T = TypeVar('T')
U = TypeVar('U')

x, y = cast(Tuple[Callable[[T], Tuple[T, U]], U], None)

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, Never]"
reveal_type(y) # N: Revealed type is "Any"

[out]
__main__:6: error: Type variable "__main__.U" is unbound
__main__:6: note: (Hint: Use "Generic[U]" or "Protocol[U]" base class to bind "U" inside a class)
__main__:6: note: (Hint: Use "U" in function signature to bind "U" inside a function)

[case additional_callable_params_ordering]
from typing import Callable
from mypy_extensions import Arg, DefaultArg, NamedArg
x: Callable[[Arg(int, "blah"), int], int]  # E: Required positional args may not appear after default, named or var args
y: Callable[[DefaultArg(int), int], int]  # E: Required positional args may not appear after default, named or var args
z: Callable[[DefaultArg(int, "foo"), Arg(int, "bar")], int]  # E: Required positional args may not appear after default, named or var args
a: Callable[[NamedArg(int, "foo"), Arg(int, "bar")], int]  # E: Required positional args may not appear after default, named or var args

[case match_args_kwargs_callable]
# This is a bit special and probably debatable behavior. In theory the code
# below should probably not return an error. However Mypy currently gives an
# error here, because it feels wrong to expect different types for args/kwargs.
from typing import Any
def x(*args: int, **kwargs: object) -> Any: ...
def y(*args: object, **kwargs: int) -> Any: ...
def z(*args: int, **kwargs: int) -> Any: ...

def foo(x: int) -> Any: ...

foo = x # E: Incompatible types in assignment (expression has type "Callable[[VarArg(int), KwArg(object)], Any]", variable has type "Callable[[int], Any]")
foo = y # E: Incompatible types in assignment (expression has type "Callable[[VarArg(object), KwArg(int)], Any]", variable has type "Callable[[int], Any]")
foo = z

[case multiple_lambda_mypy_issue_4226]
from typing import Callable, TypeVar

S = TypeVar('S')
T = TypeVar('T')
U = TypeVar('U')

def comp(g: Callable[[T], U], f: Callable[[S], T]) -> Callable[[S], U]:
    def composed(x: S) -> U:
        return g(f(x))
    return composed

def test(s: str) -> int:
    len_and_inc = comp(lambda i: i + 1, lambda s: len(s))
    x = len_and_inc(s)
    reveal_type(x)  # N: Revealed type is "int"
    return x

[case callable_with_keyword_errors]
from mypy_extensions import Arg
from typing import Callable

def foo(x: int) -> None: ...

bar: Callable[[Arg(int, "x")], None]

foo(1, x=1)  # E: "foo" gets multiple values for keyword argument "x"
foo(1, y=1)  # E: Unexpected keyword argument "y" for "foo"

bar(1, x=1)  # E: function gets multiple values for keyword argument "x"
bar(1, y=1)  # E: Unexpected keyword argument "y"

[case callable_subtyping_keyword_only_default_params1]
def foo(*, y: str) -> None: ...
def bar(x: int = 0, *, y: str) -> None: ...

if bool():
    foo = bar
if bool():
    bar = foo # E: Incompatible types in assignment (expression has type "Callable[[NamedArg(str, 'y')], None]", variable has type "Callable[[int, NamedArg(str, 'y')], None]")

[case callable_subtyping_keyword_only_default_params2]
def foo(*, y: str) -> None: ...
def bar(x: int = 0, *bar: bytes, y: str) -> None: ...

if bool():
    foo = bar
if bool():
    bar = foo # E: Incompatible types in assignment (expression has type "Callable[[NamedArg(str, 'y')], None]", variable has type "Callable[[int, VarArg(bytes), NamedArg(str, 'y')], None]")

[case function_subtyping_positional_or_keyword_vs_variadic_and_kw_only]
def foo1(y: str) -> None: ...
def bar1(*z: str, y: str = "") -> None: ...
def bar2(*z: int, y: str = "") -> None: ...
def bar3(*z: str, y: int = 1) -> None: ...
def bar4(*z: str, y: str) -> None: ...

if bool():
    foo1 = bar1
if bool():
    foo1 = bar2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(int), DefaultNamedArg(str, 'y')], None]", variable has type "Callable[[str], None]")
if bool():
    foo1 = bar3  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), DefaultNamedArg(int, 'y')], None]", variable has type "Callable[[str], None]")
if bool():
    foo1 = bar4  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), NamedArg(str, 'y')], None]", variable has type "Callable[[str], None]")

def foo2(y: str, z: str) -> None: ...
def baz1(*args: str, y: str = '', z: str = "") -> None: ...
def baz2(*args: str, y: str = '', z: str) -> None: ...
def baz3(*args: str, y: str, z: int) -> None: ...

if bool():
    foo2 = baz1
if bool():
    foo2 = baz2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), DefaultNamedArg(str, 'y'), NamedArg(str, 'z')], None]", variable has type "Callable[[str, str], None]")
if bool():
    foo2 = baz3  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), NamedArg(str, 'y'), NamedArg(int, 'z')], None]", variable has type "Callable[[str, str], None]")

[case function_subtyping_positional_or_keyword_vs_variadic_and_kwargs_after_kw_only]
def foo1(y: str) -> None: ...
def foo2(y: str, z: str) -> None: ...
def bar1(*args: str, y: str = '', **kwargs: str) -> None: ...
def bar2(*args: str, y: str, **kwargs: str) -> None: ...
def bar3(*args: str, y: str = '', **kwargs: int) -> None: ...
def bar4(*args: str, z: str = '', **kwargs: int) -> None: ...

if bool():
    foo1 = bar1
    foo2 = bar1
if bool():
    foo1 = bar2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), NamedArg(str, 'y'), KwArg(str)], None]", variable has type "Callable[[str], None]")
if bool():
    foo1 = bar3
    foo2 = bar3  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), DefaultNamedArg(str, 'y'), KwArg(int)], None]", variable has type "Callable[[str, str], None]")
if bool():
    foo1 = bar4  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(str), DefaultNamedArg(str, 'z'), KwArg(int)], None]", variable has type "Callable[[str], None]")

[case func_subtyping_kw_against_normal_params]
def x(x: int, y: int, z: int) -> str: ...
def y(y: int, x: int, z: int) -> str: ...
def z(y: str, x: int, z: int) -> str: ...

def foo(*, x: int, y: int, z: int) -> str: ...

foo = x
foo = y
foo = z  # E: Incompatible types in assignment (expression has type "Callable[[str, int, int], str]", variable has type "Callable[[NamedArg(int, 'x'), NamedArg(int, 'y'), NamedArg(int, 'z')], str]")

[case callable_never_return]
# flags: --warn-unreachable
from typing import Callable, Never

def foo(x: Callable[[], Never]) -> None:
    x()
    undefined  # E: Statement is unreachable

[case unpack_generic_typeddict_callable_in_class]
from typing import TypedDict, Generic, TypeVar, Unpack

T = TypeVar('T')
class Foo(TypedDict, Generic[T]):
    x: T

class X(Generic[T]):
    def foo(self, **kwargs: Unpack[Foo[T]]) -> T: ...

reveal_type(X().foo(x=3))  # E: Argument "x" to "foo" of "X" has incompatible type "int"; expected "Never"  # N: Revealed type is "Never"
reveal_type(X[int]().foo(x=3))  # N: Revealed type is "int"
reveal_type(X[str]().foo(x=3))  # E: Argument "x" to "foo" of "X" has incompatible type "int"; expected "str" # N: Revealed type is "str"

[case unpack_generic_typeddict_callable_with_overload]
from typing import TypedDict, Generic, TypeVar, Unpack, overload, Any

T = TypeVar('T')
class Foo(TypedDict, Generic[T]):
    x: T

class X(Generic[T]):
    @overload
    def foo(self, **kwargs: Unpack[Foo[T]]) -> T: ...
    @overload
    def foo(self, x: int) -> int: ...
    def foo(self, *args: Any, **kwargs: Any) -> Any: ...

# This call is kind of complicated internally and should just not crash.
reveal_type(X[int].foo(X(), x=3))  # N: Revealed type is "int"

reveal_type(X[int]().foo(x=3))  # N: Revealed type is "int"
reveal_type(X[int]().foo(x=""))  # E: No overload variant of "foo" of "X" matches argument type "x=str" \
                                 # N: Possible overload variants: \
                                 # N:     def foo(self, **kwargs: Unpack[__main__.Foo[int]]) -> int \
                                 # N:     def foo(self, x: int) -> int \
                                 # N: Revealed type is "Any"

[case unpacked_typeddict_compatible_with_broader_kwargs1]
from typing import TypedDict, Generic, TypeVar, Unpack, overload, Any

class Foo(TypedDict):
    x: int

def foo(**kwargs: Unpack[Foo]) -> None: ...
def bar(**kwargs: int) -> None: ...

if bool():
    foo = bar
if bool():
    bar = foo  # E: Incompatible types in assignment (expression has type "Callable[[**Unpack[Foo]], None]", variable has type "Callable[[KwArg(int)], None]")

[case unpacked_typeddict_compatible_with_broader_kwargs2]
from typing import TypedDict, Generic, TypeVar, Unpack, overload, Any

class Foo(TypedDict):
    x: int

def foo(**kwargs: Unpack[Foo]) -> None: ...
def bar(*args: str, **kwargs: int) -> None: ...

if bool():
    foo = bar
if bool():
    bar = foo  # E: Incompatible types in assignment (expression has type "Callable[[**Unpack[Foo]], None]", variable has type "Callable[[VarArg(str), KwArg(int)], None]")

[case kwargs_subtyping]
def foo(*args: int, **kwargs: str) -> None: ...
def bar(**kwargs: str) -> None: ...

if bool():
    foo = bar  # E: Incompatible types in assignment (expression has type "Callable[[KwArg(str)], None]", variable has type "Callable[[VarArg(int), KwArg(str)], None]")
if bool():
    bar = foo

[case callable_sub_type1]
from typing import Callable, TypeVar, ParamSpec, Generic
T = TypeVar('T')

class A: ...
class B(A): ...
def meet_test(x: Callable[[T], None], y: Callable[[T], None]) -> T: ...

ca: Callable[[Callable[..., None]], None]
cb: Callable[[Callable[[int], None]], None]
reveal_type(meet_test(ca, cb)) # N: Revealed type is "def (int)"
# TODO it is weird that these do not match
reveal_type(meet_test(cb, ca)) # N: Revealed type is "def (*Any, **Any)"

[case callable_sub_type2]
from typing import Callable, TypeVar, ParamSpec, Generic
T = TypeVar('T')

class A: ...
class B(A): ...

def meet_test(x: Callable[[T], None], y: Callable[[T], None]) -> T: ...

ca: Callable[[Callable[..., A]], None]
cb: Callable[[Callable[[B], B]], None]
reveal_type(meet_test(ca, cb)) # N: Revealed type is "def (__main__.B) -> __main__.B"
reveal_type(meet_test(cb, ca)) # N: Revealed type is "def (__main__.B) -> __main__.B"

[case sub_type_of_type_var_tuples]
from typing import Callable, TypeVarTuple, ParamSpec, Generic
Ts = TypeVarTuple('Ts')

class A: ...
class B(A): ...
class C(B): ...

def meet_test(x: Callable[[*Ts], None], y: Callable[[*Ts], None]) -> tuple[*Ts]: ...

ca: Callable[[A], None]
cb: Callable[[A, B], None]
cc: Callable[[C, A], None]

meet_test(ca, cb)  # E: Argument 2 to "meet_test" has incompatible type "Callable[[A, B], None]"; expected "Callable[[A], None]"
meet_test(cb, ca)  # E: Argument 2 to "meet_test" has incompatible type "Callable[[A], None]"; expected "Callable[[A, B], None]"

reveal_type(meet_test(cb, cc)) # N: Revealed type is "tuple[__main__.C, __main__.B]"
reveal_type(meet_test(cc, cb)) # N: Revealed type is "tuple[__main__.C, __main__.B]"

[case first_positional_type_for_unpacked_tuples]
from typing import Unpack, ClassVar, Callable
class C:
    def a(*args: Unpack[tuple[C, ...]]) -> None: ...
    def b(*args: Unpack[tuple[str, ...]]) -> None: ...

    def c(*args: Unpack[tuple[C, Unpack[tuple[int, ...]]]]) -> None: ...

    def d(*args: Unpack[tuple[Unpack[tuple[int, ...]], str]]) -> None: ...
    def e(*args: Unpack[tuple[Unpack[tuple[C, ...]], str]]) -> None: ...

    def f(*args: Unpack[tuple[C, int]]) -> None: ...
    def g(*args: Unpack[tuple[str, int]]) -> None: ...

    h: ClassVar[Callable[[Unpack[tuple[int, ...]]], None]]
    i: ClassVar[Callable[[Unpack[tuple[Unpack[tuple[C, ...]], str]]], None]]
    j: ClassVar[Callable[[Unpack[tuple[C, Unpack[tuple[int, ...]], str]]], None]]
    k: ClassVar[Callable[[Unpack[tuple[C, str]]], None]]

c: C
c.a
c.b  # E: Invalid self argument "C" to attribute function "b" with type "Callable[[VarArg(str)], None]"
c.c
c.d  # E: Invalid self argument "C" to attribute function "d" with type "Callable[[VarArg(Unpack[tuple[Unpack[Tuple[int, ...]], str]])], None]"
c.e  # E: Invalid self argument "C" to attribute function "e" with type "Callable[[VarArg(Unpack[tuple[Unpack[Tuple[C, ...]], str]])], None]"
c.f
c.g  # E: Invalid self argument "C" to attribute function "g" with type "Callable[[str, int], None]"

c.h  # E: Invalid self argument "C" to attribute function "h" with type "Callable[[VarArg(int)], None]"
c.i  # E: Invalid self argument "C" to attribute function "i" with type "Callable[[VarArg(Unpack[tuple[Unpack[Tuple[C, ...]], str]])], None]"
c.j
c.k

[case class_matching_against_param_spec_with_type_var_syntax_late_bound]
from typing import Callable, Sequence
# From conformance tests generics_syntax_scoping.py
def decorator2[**P, R](x: int) -> Callable[[Callable[P, R]], Callable[P, R]]:
    ...

T = int(0)

@decorator2(T)  # OK
class ClassE[T](Sequence[T]): ...

[case assert_type_callable_with_paramspec]
from typing import Callable, ParamSpec, assert_type

P = ParamSpec("P")
def changes_return_type_to_str(x: Callable[P, int]) -> Callable[P, str]:
    ...
def returns_int(a: str, b: bool, /) -> int:
    ...

f1 = changes_return_type_to_str(returns_int)
assert_type(f1, Callable[[str, bool], str])
