[case dataclass_any_inherited_nested]
# Checks issues of testDataclassesAnyInherit but with additional inheritance
from dataclasses import dataclass
from typing import Any
A: Any
@dataclass
class B(A):
    a: int

@dataclass
class C(B):
    b: str

reveal_type(C) # N: Revealed type is "def (a: int, b: str, *Any, **Any) -> __main__.C"
C(a=1, b="", c=2)
C(1, 1)  # E: Argument 2 to "C" has incompatible type "int"; expected "str"
C(a="foo", b="")  # E: Argument "a" to "C" has incompatible type "str"; expected "int"

[case dataclass_method_binding1]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

class B(A):
    y: int

x = B(1).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1))
type(z)(x=3)

[case dataclass_method_binding2]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

@dataclass
class B(A):
    y: int

x = B(1, 2).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3, y=4)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1, 2))
type(z)(x=3, y=2)

a = A.foo(A(1))
reveal_type(a)  # N: Revealed type is "__main__.A"
type(a)(x=3)

[case dataclass_inheritance_method_generics_with_normal_class]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

class C(A[List[T]]): ...

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "List[int]"

[case dataclass_inheritance_method_generics_with_dataclass]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1, "")
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass
class C(A[List[T]]):
    y: str

C(1, "")  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1], "")
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass_no_init]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass(init=False)
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass(init=False)
class C(A[List[T]]):
    y: str

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_self_in_inheritance]
from typing import Self
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def foo(self) -> Self: return self

@dataclass()
class B(A):
    y: str

x = B(1, "").foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(2, "")
type(x)(2, 2)  # E: Argument 2 to "B" has incompatible type "int"; expected "str"

class C(A):
    y: str

y = C(1)
reveal_type(y)  # N: Revealed type is "__main__.C"
type(y)("")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
type(y)(1)

[case generic_dataclass_used_in_annotation]
from typing import TypeVar, Generic
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class D(Generic[T]):
    foo: T
def foo(x: D[int]) -> None:
    reveal_type(x.foo)  # N: Revealed type is "int"

[case dataclass__call__]
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def __call__(self, x: int) -> None: ...

A(1)()  # E: Missing positional argument "x" in call to "__call__" of "A"
A(1)(1)

[case dataclass_invalid_options]
from dataclasses import dataclass
def f(b: bool):
    @dataclass(init=b)  # E: "init" argument must be a True or False literal
    class B:
        y: str

    @dataclass(**{'undefined': b})  # E: Unexpected argument to "dataclass()"
    class C:
        y: str

[case dataclass_invalid_field_options]
from dataclasses import dataclass, field

def f(b: bool):
    @dataclass
    class B:
        y: str = field(init=b)  # E: "init" argument must be a True or False literal
        z: str = field(kw_only=b)  # E: "kw_only" argument must be a True or False literal

[case dataclass_post_init_invalid_self_type_override]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def __post_init__(self: A[int]) -> None: ...  # E: Invalid self argument "Self" to attribute function "__post_init__" with type "Callable[[A[int]], None]"
    def y(self: A[int]) -> None: ...

[case dataclass_init_with_self_type]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    def __init__(self: C[int], lower: T, upper: T) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # E: Argument 1 to "C" has incompatible type "str"; expected "int" \
                        # E: Argument 2 to "C" has incompatible type "str"; expected "int" \
                        # N: Revealed type is "__main__.C[Any]"

[case dataclass_init_with_self_type_overloaded]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    @overload
    def __init__(self: C[int], lower: int, upper: int) -> None: ...
    @overload
    def __init__(self: C[str], lower: str, upper: str) -> None: ...
    def __init__(self, lower: Any, upper: Any) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # N: Revealed type is "__main__.C[str]"

[case custom_dataclass_stubs]
from dataclasses import dataclass

@dataclass
class A:
    x: int

A(1)
A(x=1)
A(1, y=1)  # E: Unexpected keyword argument "y" for "A"

[file dataclasses-stubs/__init__.pyi]
from typing import Any
def dataclass(cls: type[Any], /) -> type[Any]: ...

[case dataclass_descriptor_call]
from dataclasses import dataclass

class MyDescriptor:
    def __get__(self, obj: object | None, owner) -> "int | MyDescriptor": ...
    def __set__(self, obj: object | None, value: int) -> None: ...

@dataclass
class Foo:
    x: MyDescriptor
    y: MyDescriptor = MyDescriptor()

Foo(3, 3)  # E: Argument 1 to "Foo" has incompatible type "int"; expected "MyDescriptor"
Foo(MyDescriptor(), MyDescriptor())  # E: Argument 2 to "Foo" has incompatible type "MyDescriptor"; expected "int"
f = Foo(MyDescriptor(), 3)  # Currently a false positive error in pyright (and mypy)

f.y = 4

reveal_type(f.y)  # N: Revealed type is "int | __main__.MyDescriptor"
reveal_type(Foo.y)  # N: Revealed type is "int | __main__.MyDescriptor"

[case dataclass_with_or_should_not_panic]
from dataclasses import dataclass

@dataclass()
class Foo(): ...

Bar = Foo | int
