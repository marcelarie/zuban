[case redefine_in_module_access_from_outside]
# flags: --allow-redefinition-new
import m
reveal_type(m.x)  # N: Revealed type is "str"

[file m.py]
x = 1
x = ""

[case redefine_in_module_class_access_from_outside]
# flags: --allow-redefinition-new
from m import C
import m

reveal_type(m.C.x)  # N: Revealed type is "str"
reveal_type(m.C().x)  # N: Revealed type is "str"

reveal_type(C.x)  # N: Revealed type is "str"
reveal_type(C().x)  # N: Revealed type is "str"

[file m.py]
class C:
    x = 1
    x = ""

reveal_type(C.x)  # N: Revealed type is "str"
reveal_type(C().x)  # N: Revealed type is "str"

[case narrow_class_annotation_with_allow_redefinition_new_simple]
# flags: --allow-redefinition-new
from m import C
import m

reveal_type(m.C.x)  # N: Revealed type is "int | str"
reveal_type(m.C().x)  # N: Revealed type is "int | str"

reveal_type(C.x)  # N: Revealed type is "int | str"
reveal_type(C().x)  # N: Revealed type is "int | str"

[file m.py]
class C:
    x: int | str = 1
    x = ""

reveal_type(C.x)  # N: Revealed type is "int | str"
reveal_type(C().x)  # N: Revealed type is "int | str"

[case narrow_class_annotation_with_allow_redefinition_new_with_any1]
# flags: --allow-redefinition-new
from m import C
import m

reveal_type(m.C.x)  # N: Revealed type is "int | str"
reveal_type(m.C().x)  # N: Revealed type is "int | str"

reveal_type(C.x)  # N: Revealed type is "int | str"
reveal_type(C().x)  # N: Revealed type is "int | str"

[file m.py]
from typing import Any

def generate_any() -> Any: ...

class C:
    x: int | str = 1
    x = generate_any()

reveal_type(C.x)  # N: Revealed type is "int | str"
reveal_type(C().x)  # N: Revealed type is "int | str"

[case narrow_class_annotation_with_allow_redefinition_new_with_any2]
# flags: --allow-redefinition-new
from m import C
import m

reveal_type(m.C.x)  # N: Revealed type is "int | str"
reveal_type(m.C().x)  # N: Revealed type is "int | str"

reveal_type(C.x)  # N: Revealed type is "int | str"
reveal_type(C().x)  # N: Revealed type is "int | str"

[file m.py]
from typing import Any

def generate_any_or_int() -> Any | int: ...

class C:
    x: int | str = 1
    x = generate_any_or_int()

reveal_type(C.x)  # N: Revealed type is "int | str"
reveal_type(C().x)  # N: Revealed type is "int | str"

[case no_crash_on_stdlib_overwrite_in_class]
# flags: --allow-redefinition-new

# Enable flow analysis
if bool(): ...

class DType:
    def __repr__(self):
        return '...'
    __str__ = __repr__

[case class_redefine_with_var_not_possible]
# flags: --allow-redefinition-new

class X: ...
class Y(X): ...

if bool():
    X = Y  # E: Name "X" already defined on line 3
if bool():
    Y = X  # E: Name "Y" already defined on line 4

[case class_redefine_with_var_not_possible]
# flags: --allow-redefinition-new

class X: ...
class Y(X): ...

if bool():
    X = Y  # E: Name "X" already defined on line 3
if bool():
    Y = X  # E: Name "Y" already defined on line 4

[case type_alias_redefine_with_var_not_possible]
# flags: --allow-redefinition-new

type X = int
type Y = int | str

reveal_type(X)

if bool():
    X = Y  # E: Name "X" already defined on line 3
if bool():
    Y = X  # E: Name "Y" already defined on line 4
