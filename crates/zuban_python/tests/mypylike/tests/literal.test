[case literal_union_formatting1]
from typing import Literal

a: int
b: str | Literal[1, 2] | float
a = b  # E: Incompatible types in assignment (expression has type "Literal[1, 2] | str | float", variable has type "int")

[case literal_union_formatting2]
from typing import Literal

a: int
b: str | Literal[1, 2] | float
c: str | Literal[1, 2] | float | Literal['x']
d: Literal[1] | Literal['x']

def x(y: int) -> None: ...
x(a)
x(b)  # E: Argument 1 to "x" has incompatible type "Literal[1, 2] | str | float"; expected "int"
x(c)  # E: Argument 1 to "x" has incompatible type "Literal[1, 2, 'x'] | str | float"; expected "int"
x(d)  # E: Argument 1 to "x" has incompatible type "Literal[1, 'x']"; expected "int"

[case literal_union_formatting_through_type_vars]
from typing import Literal, TypeVar

T = TypeVar("T")

l: Literal[3]
u: Literal[3] | list[int]

def foo(x: T) -> str | Literal[1, 2] | float | Literal['x'] | T: ...

def x(y: int) -> None: ...
x(foo(l))  # E: Argument 1 to "x" has incompatible type "Literal[1, 2, 3] | float | str"; expected "int"
x(foo(u))  # E: Argument 1 to "x" has incompatible type "Literal[1, 2, 3] | float | str | list[int]"; expected "int"

[case str_literal_assignment]
# Like testLiteralFromTypingWorks, but for strings
from typing import Literal

x: Literal["foo"]
x = "bar"  # E: Incompatible types in assignment (expression has type "Literal['bar']", variable has type "Literal['foo']")

y: Literal["bar"]
y = "bar"

[case avoid_long_literal_in_tuple_explosion]
x = dict([
    (1, ("00",)),
    (1, ("01",)),
    (1, ("02",)),
])
reveal_type(x)  # N: Revealed type is "dict[int, tuple[str]]"

y = dict([
    (b'', 3),
    (b'', 4),
    (b'', 5),
])
reveal_type(y)  # N: Revealed type is "dict[bytes, int]"
