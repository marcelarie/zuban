[case duplicate_base_class_of_tuple]

class A(tuple, tuple): ...  # E: Duplicate base class "tuple"
class B(tuple[int, str], tuple): ...  # E: Duplicate base class "tuple"
class C(tuple, tuple[int, ...]): ...  # E: Duplicate base class "tuple"
class D(tuple[str], tuple[int, ...]): ...  # E: Duplicate base class "tuple"

class X(tuple[str, int]): ...
class Y(tuple[str, ...]): ...
class Z(tuple): ...

[case duplicate_base_class_of_type]

class A(type, type): ...  # E: Duplicate base class "type"
class B(type[int], type): ...  # E: Invalid base class "type[int]"
class C(type, type[int]): ...  # E: Invalid base class "type[int]"
class D(type[str], type[int]): ...  # E: Invalid base class "type[str]" # E: Invalid base class "type[int]"

class X(type): ...

[case base_class_of_type]
from typing import Type

class A(Type[int]): ...  # E: Invalid base class "Type[int]"
class B(type[int]): ...  # E: Invalid base class "type[int]"
class C(Type): ...  # E: Invalid base class "Type"
class D(type): ...

[case function_as_invalid_base_class]
def untyped(): ...
def typed() -> None: ...
class A(abs): ...  # E: Invalid base class "abs"
class B(untyped): ...  # E: Invalid base class "untyped"
class C(typed): ...  # E: Invalid base class "typed"

[case generic_metaclasses_are_invalid_according_to_mypy]
from typing import Generic, TypeVar

T = TypeVar("T")

class Meta(type, Generic[T]):
    def f(cls) -> T: ...

class A(metaclass=Meta[int]): ...  # E: Invalid metaclass "Meta[int]"

[case metaclass_inheritance]
class MyMeta1(type): ...
class MyMeta2(type): ...
class MyMeta3(MyMeta1, MyMeta2): ...
class A(metaclass=MyMeta1): ...
class B(metaclass=MyMeta2): ...
class C(metaclass=MyMeta3): ...

class Try1(A, B): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try2(B, A): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try3(C, A): ...
class Try4(A, C): ...

[case self_type_in_metaclass]
# Similar to testTypingSelfMetaClassDisabled, but with additional tests
from typing import Self, Any

class Meta(type):
    def __new__(cls, *args: Any) -> Self:  # E: Self type cannot be used in a metaclass
        return 1
    def meth(cls) -> Self: ...  # E: Self type cannot be used in a metaclass
    def other(cls, next: Self) -> None: ...  # E: Self type cannot be used in a metaclass
    x: Self  # E: Self type cannot be used in a metaclass

class Bar(metaclass=Meta): ...

reveal_type(Bar.x)  # N: Revealed type is "Any"
reveal_type(Bar.meth)  # N: Revealed type is "def () -> Any"
reveal_type(Bar.other)  # N: Revealed type is "def (next: Any)"

[case metaclass_descriptor]
from typing import TypeVar, Tuple
T = TypeVar("T")
S = TypeVar("S")
class Descriptor():
    def __get__(self, instance: S, cls: T) -> Tuple[S, T]:
        return instance, cls

class Meta(type):
    a = Descriptor()


class A(metaclass=Meta): ...

# This differs in Mypy and CPython:
# >>> A.a
# (<class '__main__.A'>, <class '__main__.Meta'>)
# However in mypy it's tuple[None, Type[x2.A@1369]]
reveal_type(A.a)  # N: Revealed type is "tuple[Type[__main__.A], Type[__main__.Meta]]"
reveal_type(Meta(A()).a)  # N: Revealed type is "tuple[__main__.Meta, Type[__main__.Meta]]"

[case metaclass_iter_on_type_bound]
# Similar to testInferringLvarTypesUnpackedFromIterableClassObject, but with
# bounds
from typing import Iterator, Type, TypeVar, Union, overload
class Meta(type):
    def __iter__(cls) -> Iterator[int]: raise NotImplementedError

class Meta2(type):
    def __iter__(cls) -> Iterator[str]: raise NotImplementedError

class Meta3(type): ...

class Foo(metaclass=Meta): ...
class Bar(metaclass=Meta2): ...
class Baz(metaclass=Meta3): ...
class Spam: ...

T = TypeVar("T", bound=Foo)
def check_bound1(x: Type[T]) -> None:
    for var in x:
        reveal_type(var)  # N: Revealed type is "builtins.int"

U = TypeVar("U", bound=Foo | Bar)
def check_bound2(x: Type[U]) -> None:
    for var in x:
        reveal_type(var)  # N: Revealed type is "builtins.int | builtins.str"

V = TypeVar("V", bound=Bar | Baz | Spam)
def check_bound3(x: Type[V]) -> None:
    for var in x:  # E: "Type[Baz]" has no attribute "__iter__" (not iterable) \
                   # E: "Type[Spam]" has no attribute "__iter__" (not iterable)
        reveal_type(var)  # N: Revealed type is "builtins.str | Any"

[case kwargs_base_class]
from typing import Type, Any
foo: dict[str, Type[Any]]

class Bar(**foo): ...  # E: Invalid base class "**foo"

[case staticmethod_and_classmethod]
# This is tested in testClassMethodAndStaticMethod, but only one side, so test
# both here.
class C:
  @classmethod  # E: Cannot have both classmethod and staticmethod
  @staticmethod
  def foo(cls) -> None: pass

  @staticmethod  # E: Cannot have both classmethod and staticmethod
  @classmethod
  def bar(cls) -> None: pass

[case overloaded_property_not_possible]
# flags: --mypy-compatible
# There's also testOverloadedProperty, but it's not complete
from typing import overload
class A:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property # E: Name "f" already defined on line 5
    @overload
    def f(self) -> int: pass

class B:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property  # E: Name "f" already defined on line 13
    @overload
    def f(self) -> int: pass
    @property  # E: Name "f" already defined on line 13
    def f(self) -> int: pass

reveal_type(A().f)  # N: Revealed type is "Any"
reveal_type(B().f)  # N: Revealed type is "Any"

[case invalid_args_for_property]
# Similar to testInvalidArgCountForProperty, but a few more cases
from typing import Callable, Any

def any(f: Callable[[Any], int]) -> Callable[..., int]: ...

class A:
    @property
    @any
    def f(self) -> int: pass

[case property_generic_access]
# Make sure this is tested
from typing import Callable, TypeVar, Generic

T = TypeVar("T")

class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x

    @property
    def f(self) -> T: return self.x

x: A[int]

reveal_type(x.f)  # N: Revealed type is "int"

reveal_type(A("").f)  # N: Revealed type is "str"

[case super_with_explicit_self]
# There's testSuperWithGenericSelf, but nothing with explict Self arguments
# AFAIK
from typing import Self

class B:
    def f(self) -> float: pass

class C(B):
    def f(self) -> int: pass

    def g(self: Self) -> Self:
        reveal_type(super(C, self).f) # N: Revealed type is "def () -> builtins.float"
        return self

[case super_self_lookup]
class Bar:
    def f1(self) -> None:
        self.bar = 1
class Foo(Bar):
    def f2(self) -> None:
        self.foo = 1
        reveal_type(super().foo)  # E: "foo" undefined in superclass # N: Revealed type is "Any"
        reveal_type(super().bar)  # E: "bar" undefined in superclass # N: Revealed type is "Any"

[case class_var_in_method_annotation]
from typing import ClassVar

class Foo:
    def method1(self, x: ClassVar) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method2(self, x: ClassVar[int]) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method3(self) -> ClassVar: ...  # E: ClassVar can only be used for assignments in class body
    def method4(self) -> ClassVar[int]: ...  # E: ClassVar can only be used for assignments in class body

[case self_callable]
from typing import Callable
class Foo:
    def __init__(self) -> None:
        o: Callable[[], Callable[[Foo, int], None]]
        self.foo: Callable[[Foo, int], str]
        self.bar = self.foo
        self.bla = o()

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (__main__.Foo, int)"
Foo.foo  # E: "Type[Foo]" has no attribute "foo"

[case callable_on_class_with_classvar]
from typing import Callable, ClassVar
class Foo:
    o: ClassVar[Callable[[], Callable[[Foo, int], None]]]
    foo: ClassVar[Callable[[Foo, int], str]]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_on_class_without_classvar]
from typing import Callable
class Foo:
    o: Callable[[], Callable[[Foo, int], None]]
    foo: Callable[[Foo, int], str]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_mapped_via_class1]
from typing import Callable, ClassVar
class Foo:
    foo: ClassVar[Callable[[Foo, Bar, int], None]]
class Bar:
    bar = Foo().foo

reveal_type(Bar.bar)  # N: Revealed type is "def (__main__.Bar, int)"
reveal_type(Bar().bar)  # N: Revealed type is "def (int)"

[case callable_mapped_via_class2]
class Foo:
    def foo(self, bar: Bar, other: int) -> None: ...
class Bar:
    bar = Foo().foo

reveal_type(Bar.bar)  # N: Revealed type is "def (bar: __main__.Bar, other: int)"
# This might not work in Mypy. As of 47480a5dc, this leads to the same type,
# but also an error:
# Invalid self argument "Bar" to attribute function "bar" with type "Callable[[Bar, int], None]"
reveal_type(Bar().bar)  # N: Revealed type is "def (other: int)"

[case generic_descriptor]
from typing import Generic, TypeVar
T = TypeVar("T")

class Descriptor(Generic[T]):
    def __get__(self, instance, cls) -> T:
        raise NotImplementedError

class Foo(Generic[T]):
    def __init__(self, x: T):
        raise NotImplementedError

    d1: Descriptor[T]
    d2 = Descriptor[T]()

reveal_type(Foo(1).d1)  # N: Revealed type is "int"
reveal_type(Foo(1).d2)  # N: Revealed type is "int"
reveal_type(Foo[int].d1)  # E: Access to generic instance variables via class is ambiguous \
                          # N: Revealed type is "int"
reveal_type(Foo[int].d2)  # N: Revealed type is "int"

[case descriptor_with_wrong_annotations]
class Descriptor():
    def __get__(self, instance: None, cls: None) -> int:
        raise NotImplementedError

class Foo:
    d1: Descriptor
    d2 = Descriptor()

x: int
x = Foo().d1  # E: Argument 1 to "__get__" of "Descriptor" has incompatible type "Foo"; expected "None" \
              # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"
x = Foo().d2  # E: Argument 1 to "__get__" of "Descriptor" has incompatible type "Foo"; expected "None" \
              # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"
x = Foo.d1  # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"
x = Foo.d2  # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"

[case instance_self___call__]
def call(x: int) -> int:
    return 1
class Foo:
    def __init__(self) -> None:
        self.__call__ = call

Foo()()  # E: "Foo" not callable

[case class_context_super_class]
from typing import TypeVar, Generic

T = TypeVar('T')

class I(Generic[T]): ...
class A(I[list[T]]): ...

x = A() # type: I[list[int]]

a_object = A() # type: A[object]
y = a_object # type: I[int] # E: Incompatible types in assignment (expression has type "A[object]", variable has t>

z = A() # type: I[int]

[case cannot_determine_mro]
# Similar to testCannotDetermineMro, but a few more tests
class A: pass
class B(A): pass
class D(A, B): pass # E: Cannot determine consistent method resolution order (MRO) for "D"

class A2(A): pass
class B2(B): pass
class D2(A2, B2): pass  # This is fine

[case classes_with__and__]
# int() supports __and__, but int should not.
int & int  # E: Unsupported left operand type for & ("Type[int]")
int() & int()

[case typed_dict_with_normal_bases]
# Adapted from testCannotCreateTypedDictWithClassOtherBases to test an additional case
from typing import TypedDict

class A: pass

class X(TypedDict, A): # E: All bases of a new TypedDict must be TypedDict types
    x: int
class Y(A, TypedDict): # E: All bases of a new TypedDict must be TypedDict types
    x: int

[case liskov_inheritance_with_changed_type_vars]
from typing import TypeVar, Generic, List
T = TypeVar('T')

class A(Generic[T]):
    def x(self, t: T) -> None: ...
class B(A[List[T]]):
    def x(self, t: T) -> None: ...  # E: Argument 1 of "x" is incompatible with supertype "A"; supertype defines the argument type as "list[T]" \
                                    # N: This violates the Liskov substitution principle \
                                    # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

class C(A[List[T]]):
    def x(self, t: List[T]) -> None: ...

[case operator_shortcut_type_error]

class A:
    def __add__(self, x: int) -> str:
        return ""

A() + A()  # E: Unsupported operand types for + ("A" and "A")

[case generic_class_as_callable]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, x: T):
        self.x = x

def foo(c: Callable[[int], Foo[int]]) -> None: ...
def bar(c: Callable[[int], Foo[str]]) -> None: ...

foo(Foo)
bar(Foo)  # E: Argument 1 to "bar" has incompatible type "Type[Foo]"; expected "Callable[[int], Foo[str]]"

[case generic_class_as_callable_with_func_type_vars]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
S = TypeVar('S')

class Foo(Generic[T]):
    def __init__(self, x: T, y: S, z: S):
        self.x = x

def foo(c: Callable[[int, float, float], Foo[int]]) -> None: ...
def bar(c: Callable[[int, float, str], Foo[int]]) -> None: ...
def baz(c: Callable[[str, str, float], Foo[int]]) -> None: ...

foo(Foo)
bar(Foo)
baz(Foo)  # E: Argument 1 to "baz" has incompatible type "Type[Foo]"; expected "Callable[[str, str, float], Foo[int]]"

[case generic_class_as_callable_with_func_type_vars_and_bounds]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
S = TypeVar('S', bound=int)

class Foo(Generic[T]):
    def __init__(self, x: T, y: S, z: S):
        self.x = x

def foo(c: Callable[[str, int, int], Foo[str]]) -> None: ...
def bar1(c: Callable[[str, int, bytes], Foo[str]]) -> None: ...
def bar2(c: Callable[[str, bytes, int], Foo[str]]) -> None: ...
def bar3(c: Callable[[str, str, float], Foo[int]]) -> None: ...

foo(Foo)
bar1(Foo)  # E: Value of type variable "S" of "bar1" cannot be "bytes"
bar2(Foo)  # E: Value of type variable "S" of "bar2" cannot be "bytes"
bar3(Foo)  # E: Value of type variable "S" of "bar3" cannot be "str"

[case class_init_with_mismatching_self_type_vars]
from typing import Generic, TypeVar

T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T, U]):
    def __init__(self: Foo[int, U], y: U): ...

class Bar(Foo[str, U]): ...

x: Bar[float]  # Fine
y = Bar(1.0)  # E: Invalid self type in __init__
reveal_type(y)  # N: Revealed type is "__main__.Bar[float]"

[case class_init_with_mismatching_self_type_vars_overload]
from typing import Generic, TypeVar, overload

T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T, U]):
    @overload
    def __init__(self: Foo[int, U], y: U): ...
    @overload
    def __init__(self: Foo[float, U], y: U): ...
    def __init__(self, y): ...

class Bar(Foo[str, U]): ...

x: Bar[float]  # Fine
y = Bar(1.0)  # E: No overload variant of "Bar" matches argument type "float" \
              # N: Possible overload variants: \
              # N:     def [T, U] __init__(self: Foo[int, U], y: U) -> Bar[U] \
              # N:     def [T, U] __init__(self: Foo[float, U], y: U) -> Bar[U]

reveal_type(y)  # N: Revealed type is "Any"

[case class_union_attribute_assignment]
from typing import Union

class Foo:
    x: Union[str, int] = ''

f = Foo()
f.x = ''
f.x = 1

[case self_attr_context]
class Foo:
    def __init__(self, x: list[int]):
        self.x = x

f: Foo
f.x = []

[case avoid_losing_context_when_self_attr_doesnt_exist]
class Foo: ...
x = [1]
Foo().undefined = x = []  # E: "Foo" has no attribute "undefined"

[case avoid_context_of_getattr]
class Foo:
    def __getattr__(self, name: str) -> list[int]: ...

class Bar(Foo):
    x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")

[case initialize_type]
type("A", (), {})
type("B", 1, 1)

[out]
main:2: error: No overload variant of "type" matches argument types "str", "int", "int"
main:2: note: Possible overload variants:
main:2: note:     def __init__(self, object, /) -> type
main:2: note:     def __init__(self, str, tuple[Type[Any], ...], dict[str, Any], /, **kwds: Any) -> type

[case assign_in_subclass_to_callable]
# Inspired a bit by testTypedDictUnpackSingleWithSubtypingNoCrash
from typing import Callable

def f(pseudo_self, x: int) -> None:
    pass
def g(pseudo_self, y: str) -> None:
    pass
def h(x: int) -> None:
    pass

class C:
    foo: Callable[[int], None]
    bar: Callable[[int], None]
    baz: Callable[[int], None]

# Currently we fail
class D(C):
    foo = f
    bar = g  # E: Argument 1 of "bar" is incompatible with supertype "C"; supertype defines the argument type as "int" \
             # N: This violates the Liskov substitution principle \
             # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
    baz = h  # E: Invalid self argument "D" to attribute function "h" with type "Callable[[int], None]" \
             # E: Signature of "baz" incompatible with supertype "C" \
             # N:      Superclass: \
             # N:          def (int, /) -> None \
             # N:      Subclass: \
             # N:          Callable[[], None]

[case total_ordering_missing_method]
from functools import total_ordering

@total_ordering
class Ord:  # E: No ordering operation defined when using "functools.total_ordering": < > <= >=
    def __eq__(self, other: object) -> bool:
        return False

reveal_type(Ord() < Ord())  # E: Unsupported left operand type for < ("Ord")  # N: Revealed type is "Any"
reveal_type(Ord() <= Ord())  # E: Unsupported left operand type for <= ("Ord")  # N: Revealed type is "Any"
reveal_type(Ord() == Ord())  # N: Revealed type is "bool"

[case self_annotation_eq_mismatch]
from typing import Generic, TypeVar

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __eq__(self: A[int], other: object) -> bool: ...

aint = A(1)
astr = A("")
aint == None
astr == None  # E: Invalid self argument "A[str]" to attribute function "__eq__" with type "Callable[[A[int], object], bool]"

[case self_annotation_add_mismatch]
from typing import Generic, TypeVar, Self

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __add__(self: A[int], other: object) -> Self: ...

aint = A(1)
astr = A("")
aint + aint
astr + astr  # E: Invalid self argument "A[str]" to attribute function "__add__" with type "Callable[[A[int], object], Self]"

aint += aint
astr += astr  # E: Invalid self argument "A[str]" to attribute function "__add__" with type "Callable[[A[int], object], Self]"

[case self_annotation_radd_mismatch]
from typing import Generic, TypeVar, Self

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __radd__(self: A[int], other: object) -> int: ...

x = 1
y = 1
aint = A(1)
astr = A("")
x + aint
y + astr  # E: Invalid self argument "A[str]" to attribute function "__radd__" with type "Callable[[A[int], object], int]"

x += aint
y += astr  # E: Invalid self argument "A[str]" to attribute function "__radd__" with type "Callable[[A[int], object], int]"

[case self_annotation_contains_mismatch]
from typing import Generic, TypeVar, Self

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __contains__(self: A[int], other: object) -> bool: ...

aint = A(1)
astr = A("")
1 in aint
"" in astr  # E: Invalid self argument "A[str]" to attribute function "__contains__" with type "Callable[[A[int], object], bool]"

[case self_annotation_call_mismatch]
from typing import Generic, TypeVar, Callable

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __call__(self: A[int]) -> bool: ...

aint = A(1)
astr = A("")

def f(x: Callable[[], bool]) -> None: ...
f(aint)
f(astr)  # E: Argument 1 to "f" has incompatible type "A[str]"; expected "Callable[[], bool]"

[case self_annotation_setitem_mismatch]
from typing import Generic, TypeVar

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __setitem__(self: A[int], index, other) -> None: ...

aint = A(1)
astr = A("")

aint[1] = 1
astr[1] = 1  # E: Invalid self argument "A[str]" to attribute function "__setitem__" with type "Callable[[A[int], Any, Any], None]"

[case unannotated_class_init_with_self_def_no_check_untyped_defs]
class C:
    def __init__(self):
        self.x = 1
        self.y = None
        if bool():
            self.y = 1
        self.z = None
        self.lst = []
        self.lst.append(1)
        self.with_annotation: int = ""  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
        self.with_type_comment = ""  # type: int  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
        self.wrong_aug_assign += ""

c = C()
reveal_type(c.x)  # N: Revealed type is "Any"
reveal_type(c.y)  # N: Revealed type is "Any"
reveal_type(c.z)  # N: Revealed type is "Any"
reveal_type(c.lst)  # N: Revealed type is "Any"
reveal_type(c.with_annotation)  # N: Revealed type is "int"
reveal_type(c.with_type_comment)  # N: Revealed type is "int"
reveal_type(c.wrong_aug_assign)  # N: Revealed type is "Any"


[case unannotated_class_init_with_self_def_check_untyped_defs]
# flags: --check-untyped-defs
class C:
    def __init__(self):
        self.x = 1
        self.y = None
        if bool():
            self.y = 1
        self.z = None
        self.lst = []
        self.lst.append(1)
        self.with_annotation: int = ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        self.with_type_comment = ""  # type: int  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        self.wrong_aug_assign += ""  # E: "Self" has no attribute "wrong_aug_assign"

c = C()
reveal_type(c.x)  # N: Revealed type is "int"
reveal_type(c.y)  # N: Revealed type is "int | None"
reveal_type(c.z)  # N: Revealed type is "None"
reveal_type(c.lst)  # N: Revealed type is "list[int]"
reveal_type(c.with_annotation)  # N: Revealed type is "int"
reveal_type(c.with_type_comment)  # N: Revealed type is "int"
reveal_type(c.wrong_aug_assign)  # N: Revealed type is "Any"

[case aug_assign_had_issue]
class M:
    def __init__(self) -> None:
        self.next_id = 0
        self.next_id += 1
        reveal_type(self.next_id)  # N: Revealed type is "int"

[case multi_inheritance_with_generic_nested]
from typing import Generic, TypeVar
from abc import abstractmethod

T = TypeVar("T")

class S(Generic[T]):
    @abstractmethod
    def foo(self, x: T) -> T: ...
    @abstractmethod
    def bar(self, x: T) -> T: ...

class A(S[T]): ...

class B:
    def foo(self, x: str) -> str: ...
    def bar(self, x: int) -> int: ...

class M1(B, A[int]): ...  # E: Definition of "foo" in base class "B" is incompatible with definition in base class "A"
class M2(A[int], B): ...

[case multi_inheritance_self_type_mismatch]
from typing import Generic, TypeVar
from abc import abstractmethod

T = TypeVar("T")

class A(Generic[T]):
    def foo(self: A[int]) -> None: ...

class B(Generic[T]):
    def foo(self: B[int]) -> None: ...

class C(Generic[T]):
    def bar(self: C[int]) -> None: ...

class D(Generic[T]):
    def bar(self: D[str]) -> None: ...

class M1(B[int], A[int]): ...
class M2(A[int], B[int]): ...

class M3(C[int], D[int]): ...  # E: Definition of "bar" in base class "C" is incompatible with definition in base class "D"
class M4(D[int], C[int]): ...  # E: Definition of "bar" in base class "D" is incompatible with definition in base class "C"

class M5(B[str], A[int]): ...  # E: Definition of "foo" in base class "B" is incompatible with definition in base class "A"
class M6(A[int], B[str]): ...  # E: Definition of "foo" in base class "A" is incompatible with definition in base class "B"

class M7(D[str], C[int]): ...
class M8(C[int], D[str]): ...

[case closure_self_access]
class Foo:
    x: int
    def foo(self) -> None:
        def bar() -> None:
            reveal_type(self.x)  # N: Revealed type is "int"

        def bar2() -> None:
            def bar3() -> None:
                reveal_type(self.x)  # N: Revealed type is "int"

        def bar4(self) -> None:
            reveal_type(self.x)  # N: Revealed type is "Any"

[case weird_type_executions]
from typing import Any, TypeVar, NewType
import typing

T = TypeVar("T")
N = NewType("N", int)

def foo(
        a: type[Any],
        b: type[int],
        n: N,
        ):
    reveal_type(type(a))  # N: Revealed type is "Type[Any]"
    reveal_type(type(b))  # N: Revealed type is "Type[object]"
    reveal_type(type(()))  # N: Revealed type is "Type[tuple[()]]"
    reveal_type(type(T))  # N: Revealed type is "Type[typing.TypeVar]"

    reveal_type(type(n))  # N: Revealed type is "Type[__main__.N]"
    reveal_type(type(N))  # N: Revealed type is "Type[object]"
    reveal_type(type(N))  # N: Revealed type is "Type[object]"
    reveal_type(type(typing))  # N: Revealed type is "Type[types.ModuleType]"
    reveal_type(type(abs))  # N: Revealed type is "Type[object]"

[case weird_type_executions_in_class]
from typing import Generic, ParamSpec, TypeVarTuple
Ts = TypeVarTuple("Ts")
P = ParamSpec("P")
class Foo(Generic[*Ts, P]):
    def foo(self, *x: P.args, **y: P.kwargs) -> None:
        reveal_type(type(super()))  # N: Revealed type is "Type[builtins.super]"
        reveal_type(type(Ts))  # N: Revealed type is "Type[typing.TypeVarTuple]"
        reveal_type(type(P))  # N: Revealed type is "Type[typing.ParamSpec]"
        reveal_type(type(x))  # N: Revealed type is "Type[object]"
        reveal_type(type(y))  # N: Revealed type is "Type[object]"
        reveal_type(type(self))  # N: Revealed type is "Type[Self]"

[case type_executions_of_special_types]
from enum import Enum
from dataclasses import dataclass
from typing import TypedDict, NamedTuple

class E(Enum):
    x = "x"
    y = "y"

@dataclass
class D:
    x: int

class N(NamedTuple):
    x: int

class T(TypedDict):
    x: int

def foo(e: E, d: D, n: N, t: T):
    reveal_type(type(E))  # N: Revealed type is "Type[object]"
    reveal_type(type(e))  # N: Revealed type is "Type[__main__.E]"
    reveal_type(type(E.x))  # N: Revealed type is "Type[__main__.E]"

    reveal_type(type(D))  # N: Revealed type is "Type[object]"
    reveal_type(type(d))  # N: Revealed type is "def (x: int) -> __main__.D"

    reveal_type(type(N))  # N: Revealed type is "Type[object]"
    reveal_type(type(n))  # N: Revealed type is "Type[tuple[int, fallback=__main__.N]]"

    reveal_type(type(T))  # N: Revealed type is "Type[object]"
    reveal_type(type(t))  # N: Revealed type is "Type[object]"

[case self_argument_against_generics]
from typing import Self, Generic, TypeVar

T = TypeVar("T")
class Parent(Generic[T]): ...

class A(Parent[int]):
    def foo(self, b: B) -> None:
        reveal_type(b.bar(self))  # N: Revealed type is "int"

class B:
    def bar(self, other: Parent[T]) -> T: ...

[case missing__init__decorator]
class F:
    @foo  # E: Name "foo" is not defined
    def __init__(self, x: int) -> None: ...

F(b'')

[case __init__decorator_with_invalid_type]
def foo(x) -> int: ...
class F:
    # TODO add an error that this is an invalid __init__
    @foo
    def __init__(self, x: int) -> None: ...

F(b'')

[case slots_no_slots_with_dict]

class A:
    __slots__ = ('a',)
    a: int
    x: int

class B(A):
    b: int

class C(B):
    __slots__ = ('c',)
    c: int

def foo(a: A, b: B, c: C) -> None:
    a.a = 1
    a.b = 1  # E: "A" has no attribute "b"
    a.c = 1  # E: "A" has no attribute "c"
    a.x = 1  # E: Trying to assign name "x" that is not in "__slots__" of type "__main__.A"
    a.undefined = 1  # E: "A" has no attribute "undefined"

    b.a = 1
    b.b = 1
    b.c = 1  # E: "B" has no attribute "c"
    b.x = 1
    b.undefined = 1  # E: "B" has no attribute "undefined"

    c.a = 1
    c.b = 1
    c.c = 1
    c.x = 1
    c.undefined = 1  # E: "C" has no attribute "undefined"

[case slots_conflicting_with_class_var_access_with_inheritance_with__dict__]
class A:
    __slots__ = ('a', '__dict__')
    a: int
    x: int

class B(A):
    b: int

class C(B):
    __slots__ = ('c',)
    c: int

A.a  # E: "a" in __slots__ conflicts with class variable access
A.b  # E: "Type[A]" has no attribute "b"
A.c  # E: "Type[A]" has no attribute "c"
A.x
A.undefined = 1  # E: "Type[A]" has no attribute "undefined"

B.a  # E: "a" in __slots__ conflicts with class variable access
B.b
B.c  # E: "Type[B]" has no attribute "c"
B.x
B.undefined = 1  # E: "Type[B]" has no attribute "undefined"

C.a  # E: "a" in __slots__ conflicts with class variable access
C.b
C.c  # E: "c" in __slots__ conflicts with class variable access
C.x
C.undefined = 1  # E: "Type[C]" has no attribute "undefined"

[case aug_assign_with_inheritance_context]
class Foo:
    x: list[int | str]
    y: list[int | str]

    def __init__(self) -> None:
        self.x += [1]

    def bar(self) -> None:
        self.x += [""]
        self.y += [""]

class Super:
    x: list[int | str]

    def __init__(self) -> None:
        self.y: list[int | str] = []
        self.z: list[int | str]

class Sub(Super):
    def __init__(self) -> None:
        self.x += [1]
        self.y += [""]
        self.z += [""]

[case type_mro_lookup]
from typing import Any

type.mro(type(object()))
type.mro(type(1))
type.mro(1)  # E: Argument 1 to "mro" of "type" has incompatible type "int"; expected "type"

def foo(a: type[Any]) -> None:
    type.mro(a)

[case mro_is_assignable_if_instance_attr]
class Foo:
    def __init__(self) -> None:
        self.mro: str = ""

Foo().mro = ""
Foo.mro = ""  # E: Cannot assign to a method \
              # E: Incompatible types in assignment (expression has type "str", variable has type "Callable[[], list[Type[Any]]]")

[case var_defined_on_if_in_unannotated_self_function]
class F:
    def foo(self) -> None:
        self.f.read() + ""

    def bar(self):
        # This is obviously not code somebody would write, but we get a context
        # manager that way.
        with open("lala") as self.f:
            ...

[case weird_invalid__new__]
import typing
class C1:
    __new__ = typing  # E: Signature of "__new__" incompatible with supertype "object" \
                      # N:      Superclass: \
                      # N:          def [Self: object] __new__(cls) -> Self \
                      # N:      Subclass: \
                      # N:          ModuleType

C1()

import typing
class C2:
    def __new__() -> C1: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
C2()

[case super_matching]
class Foo: ...
class Bar(Foo):
    def __init__(self) -> None:
        sup = super()
        if bool():
            sup = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "super")
        if bool():
            sup = super()
        if bool():
            sup = super(Foo, self)  # E: Incompatible types in assignment (expression has type "super", variable has type "super")

[case type_against_unknown_metaclass_matching]
class WithType(type): ...
class Simple: ...
class UnknownBase(UNDEFINED): ...  # E: Name "UNDEFINED" is not defined
class UnknownMeta(metaclass=UNDEFINED): ...  # E: Name "UNDEFINED" is not defined

def f(with_type: WithType, simple: Simple, unknown_base: UnknownBase, unknown_meta_t: type[UnknownMeta]):
    with_type = unknown_meta_t
    simple = unknown_meta_t  # E: Incompatible types in assignment (expression has type "Type[UnknownMeta]", variable has type "Simple")
    unknown_base = unknown_meta_t

[case unknown_metaclass_getitem]
class Simple: ...
class UnknownMeta(metaclass=UNDEFINED): ...  # E: Name "UNDEFINED" is not defined

UnknownMeta[int]
Simple[int]  # E: "Simple" expects no type arguments, but 1 given

[case metaclass_with_type_var]
from typing import Generic, TypeVar

T = TypeVar("T")
class Meta(Generic[T]): ...

class Foo(metaclass=Meta[T]): ...  # E: Invalid metaclass "Meta[T]"

[case invalid_overload_inits_used_as_callable]
from typing import Callable, overload, Any

class A:
    @overload
    def __init__(self, y: int) -> None: ...
    @overload
    def __init__() -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    def __init__(*args: Any, **kwargs: Any) -> None: ...

class B:
    @overload
    def __init__(*, y: int) -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    @overload
    def __init__() -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    def __init__(*args: Any, **kwargs: Any) -> None: ...

def foo(x: Callable[[int], Any]) -> None: ...

foo(A)
foo(B)  # E: Argument 1 to "foo" has incompatible type "Type[B]"; expected "Callable[[int], Any]"

[case nested_class_self_assignment]
class Foo:
    def __init__(self) -> None:
        self.x = 1
        class Bar:
            def __init__(bar) -> None:
                bar.z = ""
            def foo(bar) -> None:
                reveal_type(self.x)  # N: Revealed type is "int"
                reveal_type(self.y)  # N: Revealed type is "float"
                self.z  # E: "Foo" has no attribute "z"
                bar.x  # E: "Self" has no attribute "x"
                bar.y  # E: "Self" has no attribute "y"
                reveal_type(bar.z)  # N: Revealed type is "str"
                self.x += 1

        self.y = 1.0

        self.bar = Bar()

def check(f: Foo) -> None:
    reveal_type(f.x)  # N: Revealed type is "int"
    reveal_type(f.y)  # N: Revealed type is "float"
    reveal_type(f.z)  # E: "Foo" has no attribute "z" # N: Revealed type is "Any"
    f.bar.x  # E: "Bar" has no attribute "x"
    f.bar.y  # E: "Bar" has no attribute "y"
    f.bar.z

[case nested_function_in_class_self_assignment]
class Foo:
    def __init__(self) -> None:
        self.x = 1
        def init(bar) -> None:
            bar.z = ""
        def foo(bar) -> None:
            reveal_type(self.x)  # N: Revealed type is "int"
            reveal_type(self.y)  # E: Cannot determine type of "y" # N: Revealed type is "Any"
            self.z  # E: "Self" has no attribute "z"
            bar.x
            bar.y
            reveal_type(bar.z)  # N: Revealed type is "Any"
            self.x += 1

        self.y = 1.0

def check(f: Foo) -> None:
    reveal_type(f.x)  # N: Revealed type is "int"
    reveal_type(f.y)  # N: Revealed type is "float"
    reveal_type(f.z)  # E: "Foo" has no attribute "z" # N: Revealed type is "Any"

[case class_lookup_of_methods_with_generics]
from typing import Callable, TypeVar, Generic, ClassVar

def simple_dec(x: T) -> T: ...
T = TypeVar("T")
class G(Generic[T]):
    def foo(self, x: T) -> T: ...

    @simple_dec
    def bar(self, x: T) -> T: ...

class H(G[list[T]]): ...

reveal_type(G.foo)  # N: Revealed type is "def [T] (self: __main__.G[T], x: T) -> T"
reveal_type(G.bar)  # N: Revealed type is "def [T] (self: __main__.G[T], x: T) -> T"

reveal_type(H.foo)  # N: Revealed type is "def [T] (self: __main__.G[list[T]], x: list[T]) -> list[T]"
reveal_type(H.bar)  # N: Revealed type is "def [T] (self: __main__.G[list[T]], x: list[T]) -> list[T]"

def check_g(g1: G[int], g2: G[list[int]], h: H[int], x: int, y: str, l: list[int], k: list[str]) -> None:
    G.foo(g1, x)
    G.foo(g1, y)  # E: Argument 2 to "foo" of "G" has incompatible type "str"; expected "int"
    G.bar(g1, x)
    G.bar(g1, y)  # E: Argument 2 to "bar" of "G" has incompatible type "str"; expected "int"

    H.foo(g2, l)
    H.foo(g2, k)  # E: Argument 2 to "foo" of "G" has incompatible type "list[str]"; expected "list[int]"
    H.bar(g2, l)
    H.bar(g2, k)  # E: Argument 2 to "bar" of "G" has incompatible type "list[str]"; expected "list[int]"

    H.foo(h, l)
    H.foo(h, k)  # E: Argument 2 to "foo" of "G" has incompatible type "list[str]"; expected "list[int]"
    H.bar(h, l)
    H.bar(h, k)  # E: Argument 2 to "bar" of "G" has incompatible type "list[str]"; expected "list[int]"

[case reassigning_with_self_types]
from typing import Callable, Self

def dec(f) -> Callable[[A, int], A]: pass

class A:
    x = int()
    if x:
        @dec
        def f(self): pass
    else:
        def f(self, x: int) -> Self: pass

[case classmethod_self_type_with_additional_type_vars]
from typing import TypeVar
T = TypeVar("T")
U = TypeVar("U")
class F:
    @classmethod
    def foo(cls: type[T], other: U) -> tuple[T, U]: ...

f1 = F.foo
f2 = F().foo
reveal_type(f1)  # N: Revealed type is "def [U] (other: U) -> tuple[__main__.F, U]"
reveal_type(f2)  # N: Revealed type is "def [U] (other: U) -> tuple[__main__.F, U]"

reveal_type(f1(1))  # N: Revealed type is "tuple[__main__.F, int]"
reveal_type(f2(1))  # N: Revealed type is "tuple[__main__.F, int]"

[case overloaded_setattr]
from typing import overload
class Foo:
    @overload
    def __setattr__(self, name: str, other: int) -> None: ...
    @overload
    def __setattr__(self, name: str, other: str) -> None: ...
    def __setattr__(self, name: str, other) -> None: ...

Foo().x = 3
Foo().x = ""
Foo().x = b""  # E: Incompatible types in assignment (expression has type "bytes", variable has type "int | str")

[case iter_without_next]
from typing import Self
class Foo:
    def __iter__(self) -> Self: ...

for x in Foo(): ...  # E: "Foo" has no attribute "__next__"

[case yield_from_iter_without_next]
from typing import Self
class Foo:
    def __iter__(self) -> Self: ...

def f(x: int):
    yield from Foo()  # E: "Foo" has no attribute "__next__"

[case contains_iter_without_next]
from typing import Self
class Foo:
    def __iter__(self) -> Self: ...

def f(x: int):
    1 in Foo()  # E: "Foo" has no attribute "__next__"

[case overlapping_of_ops_with_incompatible_self_types]
from typing import TypeVar, Generic, Any
T = TypeVar('T')

class A(Generic[T]):
    def __add__(self: A[int], other: Any) -> int: ...

class B(A[T]):
    def __radd__(self: A[str], other: A[str]) -> str: ...  # E: Signatures of "__radd__" of "B[T]" and "__add__" of "A[str]" are unsafely overlapping

[case avoid_complex_decorator_crash_on_method]
from typing import no_type_check
class C:
    @no_type_check
    @undefined   # E: Name "undefined" is not defined
    def foo(self) -> None: ...

[case __init_subclass__with_never_or_any_return]
from typing import Any, Never
class C:
    def __init_subclass__(self) -> Never: ...
class D:
    def __init_subclass__(self) -> Any: ...  # E: The return type of "__init_subclass__" must be None

[case class_decorator_after_staticmethod_without_args]
from typing import Any
class Decorator:
    def __init__(self, other: Any): ...
    def __call__(self, other: int) -> int: ...
class C:
    @staticmethod
    @Decorator
    def s() -> None: ...

reveal_type(C().s(1))  # N: Revealed type is "int"

[case overlapping_op_methods_checking_with_valid_self_type]
from typing import Self

class C:
    def __or__(self, value: Self, /) -> Self: ...
    def __ror__(self, value: Self, /) -> Self: ...
