[case single_line_typed_dict]
from typing import TypedDict

class A(TypedDict): x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
class B(TypedDict): x: str

reveal_type(A)  # N: Revealed type is "def (*, x: Any) -> TypedDict('__main__.A', {'x': Any})"
reveal_type(B)  # N: Revealed type is "def (*, x: str) -> TypedDict('__main__.B', {'x': str})"

[case unpack_optional_args]
from typing import TypedDict, Unpack
from typing_extensions import NotRequired

class A(TypedDict, total=False):
    x: int
    y: int

class B(TypedDict):
    x: int
    y: NotRequired[int]

def foo(**kwargs: Unpack[A]) -> None: ...
def bar(**kwargs: Unpack[B]) -> None: ...

foo()
bar()  # E: Missing named argument "x" for "bar"
foo(y=1)
bar(y=1)  # E: Missing named argument "x" for "bar"
foo(x=1)
bar(x=1)

[case invalid_typed_dict_inference]
# This used to lead to stack overflows
from typing import TypeVar
T = TypeVar("T")
U = TypeVar("U")
def foo(x: T) -> T:
    def bar(x: U, y: T) -> U: ...

    bar(1, {})  # E: Argument 2 to "bar" has incompatible type "dict[Never, Never]"; expected "T"
    return x

[case accessing_special_implementations]
from typing import TypedDict

class TD(TypedDict):
    x: int

def foo(x: TD) -> None:
    x.get.__sizeof__

[case typed_dict_passing_to_callable]
from typing import TypedDict, Callable

class TD(TypedDict):
    x: int

def foo(x: type[TD]) -> None:
    def wanted(*, x: int) -> TD: ...
    y = wanted
    if bool():
        y = x
    y = TD

[case typed_dict_passing_to_callable_generic]
from typing import TypedDict, Callable, Generic, TypeVar

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    x: T

def foo(x: type[TD[int]], y: type[TD[str]]) -> None:
    def wanted(*, x: int) -> TD: ...
    w = wanted
    if bool():
        w = x
    if bool():
        w = y  # E: Incompatible types in assignment (expression has type "Type[__main__.TD[str]]", variable has type "Callable[[NamedArg(int, 'x')], TD]")
    w = TD

[case invalid_typed_dict]
from typing import TypedDict

A = TypedDict()  # E: TypedDict() expects a string literal as the first argument
B, C = TypedDict("B", {'x': int})  # E: Invalid assignment form for TypedDict, please use the simple form "X = TypedDict(..)"
D = TypedDict("D", x=int)  # E: TypedDict() expects a dictionary literal as the second argument
E = TypedDict("E", lambda: None)  # E: TypedDict() expects a dictionary literal as the second argument

[case typed_dict_slice_index]
from typing import TypedDict

class TD(TypedDict):
    x: int

def f(x: TD):
    x['x']
    x['x':'x']  # E: TypedDict key must be a string literal; expected one of ("x")

[case typed_dict_invalid_arguments]
from typing import TypedDict

class TD(TypedDict):
    x: int
    y: str

TD(x=3, y="")
TD(3)  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(3, "")  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(x=3, **{"y": ""})  # E: Unexpected argument to "TD"
TD(x=3, **{"z": ""})  # E: Unexpected argument to "TD"

class Other(TypedDict):
    z: int

TD(Other(z=1))  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(TD(x=1, y=""))

[case typed_dict_fields_with_final_and_class_var]
# Copied testTypedDictFinalAndClassVar with changed messages
from typing import TypedDict, Final, ClassVar

class My(TypedDict):
    a: Final      # E: Final can be only used as an outermost qualifier in a variable annotation
    b: Final[int] # E: Final can be only used as an outermost qualifier in a variable annotation
    c: ClassVar       # E: Invalid Type: ClassVar nested inside other type
    d: ClassVar[int]  # E: Invalid Type: ClassVar nested inside other type

Func = TypedDict('Func', {
    'a': Final,         # E: Final can be only used as an outermost qualifier in a variable annotation
    'b': Final[int],    # E: Final can be only used as an outermost qualifier in a variable annotation
    'c': ClassVar,      # E: Invalid Type: ClassVar nested inside other type
    'd': ClassVar[int], # E: ClassVar can only be used for assignments in class body
})
