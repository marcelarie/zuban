[case single_line_typed_dict]
from typing import TypedDict

class A(TypedDict): x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
class B(TypedDict): x: str

reveal_type(A)  # N: Revealed type is "def (*, x: Any) -> TypedDict('__main__.A', {'x': Any})"
reveal_type(B)  # N: Revealed type is "def (*, x: str) -> TypedDict('__main__.B', {'x': str})"

[case unpack_optional_args]
from typing import TypedDict, Unpack
from typing_extensions import NotRequired

class A(TypedDict, total=False):
    x: int
    y: int

class B(TypedDict):
    x: int
    y: NotRequired[int]

def foo(**kwargs: Unpack[A]) -> None: ...
def bar(**kwargs: Unpack[B]) -> None: ...

foo()
bar()  # E: Missing named argument "x" for "bar"
foo(y=1)
bar(y=1)  # E: Missing named argument "x" for "bar"
foo(x=1)
bar(x=1)

[case invalid_typed_dict_inference]
# This used to lead to stack overflows
from typing import TypeVar
T = TypeVar("T")
U = TypeVar("U")
def foo(x: T) -> T:
    def bar(x: U, y: T) -> U: ...

    bar(1, {})  # E: Argument 2 to "bar" has incompatible type "dict[Never, Never]"; expected "T"
    return x

[case accessing_special_implementations]
from typing import TypedDict

class TD(TypedDict):
    x: int

def foo(x: TD) -> None:
    x.get.__sizeof__

[case typed_dict_passing_to_callable]
from typing import TypedDict, Callable

class TD(TypedDict):
    x: int

def foo(x: type[TD]) -> None:
    def wanted(*, x: int) -> TD: ...
    y = wanted
    if bool():
        y = x
    y = TD

[case typed_dict_passing_to_callable_generic]
# flags: --disallow-redefinition
from typing import TypedDict, Callable, Generic, TypeVar

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    x: T

def foo(x: type[TD[int]], y: type[TD[str]]) -> None:
    def wanted(*, x: int) -> TD: ...
    w = wanted
    if bool():
        w = x
    if bool():
        w = y  # E: Incompatible types in assignment (expression has type "Type[__main__.TD[str]]", variable has type "Callable[[NamedArg(int, 'x')], __main__.TD[Any]]")
    w = TD

[case invalid_typed_dict]
from typing import TypedDict

A = TypedDict()  # E: TypedDict() expects a string literal as the first argument
B, C = TypedDict("B", {'x': int})  # E: Invalid assignment form for TypedDict, please use the simple form "X = TypedDict(..)"
D = TypedDict("D", x=int)  # E: TypedDict() expects a dictionary literal as the second argument
E = TypedDict("E", lambda: None)  # E: TypedDict() expects a dictionary literal as the second argument

[case typed_dict_slice_index]
from typing import TypedDict

class TD(TypedDict):
    x: int

def f(x: TD):
    x['x']
    x['x':'x']  # E: TypedDict key must be a string literal; expected one of ("x")

[case typed_dict_invalid_arguments]
from typing import TypedDict

class TD(TypedDict):
    x: int
    y: str

TD(x=3, y="")
TD(3)  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(3, "")  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(x=3, **{"y": ""})  # E: Unexpected argument to "TD"
TD(x=3, **{"z": ""})  # E: Unexpected argument to "TD"

class Other(TypedDict):
    z: int

TD(Other(z=1))  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(TD(x=1, y=""))

[case typed_dict_fields_with_final_and_class_var]
# Copied testTypedDictFinalAndClassVar with changed messages
from typing import TypedDict, Final, ClassVar

class My(TypedDict):
    a: Final      # E: Final can be only used as an outermost qualifier in a variable annotation
    b: Final[int] # E: Final can be only used as an outermost qualifier in a variable annotation
    c: ClassVar       # E: Invalid Type: ClassVar nested inside other type
    d: ClassVar[int]  # E: Invalid Type: ClassVar nested inside other type

Func = TypedDict('Func', {
    'a': Final,         # E: Final can be only used as an outermost qualifier in a variable annotation
    'b': Final[int],    # E: Final can be only used as an outermost qualifier in a variable annotation
    'c': ClassVar,      # E: Invalid Type: ClassVar nested inside other type
    'd': ClassVar[int], # E: ClassVar can only be used for assignments in class body
})

[case invariant_typed_dict_matching]
from typing import TypedDict
class A(TypedDict):
    x: str
class B(TypedDict):
    x: str
    y: int
class C(TypedDict):
    x: str
    y: int
    z: bytes

def check_covariant(a: A, b: B, c: C):
    if bool():
        a = a
        a = b
        a = c
    b = a  # E: Incompatible types in assignment (expression has type "A", variable has type "B")
    b = b
    b = c

def check_invariant(a: set[A], b: set[B], c: set[C]):
    if bool():
        a = a
        a = b  # E: Incompatible types in assignment (expression has type "set[B]", variable has type "set[A]")
        a = c  # E: Incompatible types in assignment (expression has type "set[C]", variable has type "set[A]")
    b = a  # E: Incompatible types in assignment (expression has type "set[A]", variable has type "set[B]")
    b = b
    b = c  # E: Incompatible types in assignment (expression has type "set[C]", variable has type "set[B]")

[case typed_dict_name_resolving_if_member_has_same_name]
from typing import TypedDict
import m

class A(TypedDict):
    a: int

class B(A):
    m: m.C
    n: m.C  # E: Invalid type comment or annotation

def foo(b: B):
    b.m  # E: "B" has no attribute "m"
    reveal_type(b['a'])  # N: Revealed type is "int"
    reveal_type(b['m'])  # N: Revealed type is "m.C"
    reveal_type(b['n'])  # N: Revealed type is "Any"

[file m.py]
class C: ...

[case typed_dict_name_resolving_if_member_has_same_name_but_is_defined_later]
from typing import TypedDict

class A(TypedDict):
    a: int

class B(A):
    m: m.C
    n: m.C  # E: Invalid type comment or annotation

def foo(b: B):
    b.m  # E: "B" has no attribute "m"
    reveal_type(b['a'])  # N: Revealed type is "int"
    reveal_type(b['m'])  # N: Revealed type is "m.C"
    reveal_type(b['n'])  # N: Revealed type is "Any"

import m

[file m.py]
class C: ...

[case generic_typed_dict_alias]
from typing import TypedDict, TypeVar, Generic
T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    a: T
A = TD[int]
reveal_type(A(a=1))  # N: Revealed type is "TypedDict('__main__.TD', {'a': int})"
A(a='')  # E: Incompatible types (expression has type "str", TypedDict item "a" has type "int")

class InvalidGeneric(TypedDict):
    a: T  # E: Type variable "__main__.T" is unbound \
          # N: (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class) \
          # N: (Hint: Use "T" in function signature to bind "T" inside a function)

B = InvalidGeneric[int]  # E: "InvalidGeneric" expects no type arguments, but 1 given
reveal_type(B(a=1))  # N: Revealed type is "TypedDict('__main__.InvalidGeneric', {'a': Any})"
B(a='')

[case typed_dict_alias_and_access]
# Like testTypedDictAliasGeneric, but with type access and a type alias from syntax
from typing import TypedDict

class A[T](TypedDict):
    x: T

A0 = A
class B(A0[str]):  # E: Bad number of arguments for type alias, expected 0, given 1
    y: int

def f(x: B) -> None:
    reveal_type(x['x'])  # N: Revealed type is "Any"
