[case mypy_no_compatible_untyped_func_exec]
# flags: --no-mypy-compatible
def f(x):
    return (x, "")

reveal_type(f(1))  # N: Revealed type is "tuple[int, Literal['']?]"

[case infer_untyped_result_but_typed_param]
# flags: --no-mypy-compatible
def f(x: int):
    return x

reveal_type(f(1))  # N: Revealed type is "int"
reveal_type(f(""))  # E: Argument 1 to "f" has incompatible type "str"; expected "int"  # N: Revealed type is "int"

[case infer_untyped_result_but_typed_param_with_type_var]
# flags: --no-mypy-compatible
def f[S, T](x: T, y: S):
    return x

reveal_type(f(1, b''))  # N: Revealed type is "int"
reveal_type(f("", b''))  # N: Revealed type is "str"

[case infer_untyped_result_result_context]
# flags: --no-mypy-compatible
def f(x):
    return [x]

reveal_type(f(1))  # N: Revealed type is "list[int]"

x: list[object] = f(1)

[case type_var_formatting]
# flags: --no-mypy-compatible

def f(x, y, z):
    return x, z

def wrap[T](x: T) -> list[T]:
    return [x]

reveal_type(f)  # N: Revealed type is "def [T1 <: Any, T2 <: Any, T3 <: Any] (x: T1, y: T2, z: T3) -> tuple[T1, T3]"
reveal_type(wrap(f))  # N: Revealed type is "list[def [T1 <: Any, T2 <: Any, T3 <: Any] (x: T1, y: T2, z: T3) -> tuple[T1, T3]]"

[case infer_untyped_callables]
# flags: --no-mypy-compatible

from typing import Callable

def ret_same(x): return x
def ret_other(x): return 1

reveal_type(ret_same)  # N: Revealed type is "def [T1 <: Any] (x: T1) -> T1"
reveal_type(ret_other)  # N: Revealed type is "def [T1 <: Any] (x: T1) -> Literal[1]?"

reveal_type(ret_same(1))  # N: Revealed type is "int"
reveal_type(ret_same(""))  # N: Revealed type is "str"
x: str = ret_same(1)  # E: Argument 1 to "ret_same" has incompatible type "int"; expected "str"
y: int = ret_other(1)
z: int = ret_other("")

def f[S, T](x: Callable[[T], S]) -> tuple[T, S]: ...

reveal_type(f(ret_same))  # N: Revealed type is "tuple[Never, Never]"
reveal_type(f(ret_other))  # N: Revealed type is "tuple[Never, int]"

[case untyped_callables_with_errors]
# flags: --no-mypy-compatible --check-untyped-defs

def f(x):
    1()  # E: "int" not callable
    return x
reveal_type(f(""))  # N: Revealed type is "str"

[case untyped_callables_without_errors]
# flags: --no-mypy-compatible --no-check-untyped-defs

def f(x):
    1()
    return x
reveal_type(f(""))  # N: Revealed type is "str"

[case untyped_class]
# flags: --no-mypy-compatible

class C:
    def __init__(self, x):
        self.x = x

    def f(self, x):
        return (x, self.x, self)

c = C("")
reveal_type(c.x)  # N: Revealed type is "str"
reveal_type(c.f(1))  # N: Revealed type is "tuple[int, str, __main__.C]"

[case untyped_method_typed_class]
# flags: --no-mypy-compatible

class C[T]:
    def __init__(self, x: T):
        self.x = x

    def f(self, x):
        return (x, self.x, self)

c = C("")
reveal_type(c.x)  # N: Revealed type is "str"
reveal_type(c.f(1))  # N: Revealed type is "tuple[int, str, __main__.C[str]]"

[case untyped_method_in_class_with_self_type1]
# flags: --no-mypy-compatible

class C:
    def f(self):
        return self

c = C()
reveal_type(c.f)  # N: Revealed type is "def () -> __main__.C"
reveal_type(c.f())  # N: Revealed type is "__main__.C"

class D(C): ...

d = D()
reveal_type(d.f)  # N: Revealed type is "def () -> __main__.D"
reveal_type(d.f())  # N: Revealed type is "__main__.D"

[case untyped_method_in_class_with_self_type2]
# flags: --no-mypy-compatible
from typing import Self

class C:
    def f(self, y: Self):
        return (self, y)

c = C()
reveal_type(c.f)  # N: Revealed type is "def (y: __main__.C) -> tuple[__main__.C, __main__.C]"
reveal_type(c.f(c))  # N: Revealed type is "tuple[__main__.C, __main__.C]"

class D(C): ...

d = D()
reveal_type(d.f)  # N: Revealed type is "def (y: __main__.D) -> tuple[__main__.D, __main__.D]"
reveal_type(d.f(d))  # N: Revealed type is "tuple[__main__.D, __main__.D]"
