# Next up
testKeywordUnpackWithDifferentTypes
testClassMethodAndStaticMethod
testUsingNumbersType
testMultipleInheritanceOverridingOfFunctionsWithCallableInstances
testForwardBoundFunctionScopeWorks

testFor
testForInFunction
testMultipleAssignmentWithNonTupleRvalue
testComplexDefinitions
testLocalComplexDefinition
testInvalidVarArg
testRecursiveTupleClassesNewType
testRecursiveRegularTupleClass
testTupleBaseClass2
callable_on_type_comment_with_unbound
testAssignmentToStarFromIterable
testNamedTupleTypeReferenceToClassDerivedFrom
testNamedTupleSelfTypeWithNamedTupleAsBase

testGenericClassMethodUnboundOnClass
testGenericClassMethodUnboundOnSubClass
testGenericClassClsNonGeneric
testGenericClassMethodUnboundOnClassNonMatchingIdNonGeneric
testGenericClassAlternativeConstructorPrecise2
testGenericClassMethodAnnotationDecorator
testSelfTypeGenericClassNoClashClassMethodClassObject
testTypingSelfAlternativeGenericConstructor
testGenericNamedTupleCustomMethods

testUnpackIterableClassWithOverloadedIter2
testInOperator
testNotInOperator
testInferringTypesFromIterableStructuralSubtyping1

# raise with brackets and no parentheses
testRaiseClassObjectCustomInit
# raise from: Exception must be derived from BaseException
testRaiseFromStatement
testRaiseFromClassobject
# Exception uses type instead of instance
testSimpleTryExcept
testSimpleTryExcept2
testBaseClassAsExceptionTypeInExcept
testMultipleExceptHandlers
testTryExceptStatement
testTryExceptWithinFunction
testExceptionVariableReuseInDeferredNode4
testExceptionVariableReuseInDeferredNode5
testExceptionVariableReuseInDeferredNode6
testArbitraryExpressionAsExceptionType
testTupleValueAsExceptionType
testOverloadedExceptionType
testExceptionIsType
testExceptionVariableReuseInDeferredNode1
testExceptionVariableReuseInDeferredNode2
testExceptionVariableReuseInDeferredNode3
testTryExceptWithMultipleHandlers
# tuple assignment tuple[Any, ...] to tuple[A, A]
testSubtypingWithNamedTupleType

# Flakey in --release
testReturnInIterator

# Remove Mode from inference_state
testSelfTypeRestrictedMethodOverloadInitBadTypeNoCrash

# typing.List used in inference
testTypeApplicationWithQualifiedTypeAlias
# typing.Union used in type alias
testUnionTypeAliasWithQualifiedUnion

# dict specialities
testDictWithKeywordArgsOnly
testDictWithoutKeywordArgs
testDictFromList
testDictFromIterableAndKeywordArg
testDictFromIterableAndKeywordArg2
testDictFromIterableAndStarStarArgs
testDictFromIterableAndStarStarArgs2
testSpecialSignatureForSubclassOfDict
testSpecialSignatureForSubclassOfDict2
testDictWithStarStarExpr
testDictIncompatibleTypeErrorMessage
testDictIncompatibleKeyVerbosity
testDictIncompatibleValueVerbosity

# Type var constraints not enforced in type alias
testValidTypeAliasValues
testValidTypeAliasValuesMoreRestrictive

# Type var finder recursion is not handled, because imports are involved.
testRecursiveAliasImported

# No recursion tests
testRecursiveDoubleUnionNoCrash
testNoRecursiveExpandInstanceUnionCrashGeneric
testNoRecursiveExpandInstanceUnionCrashInference

# Implement bitwise or
testUnionOrSyntaxWithTypeAliasWorking

# Callable formatting varargs
testUnionOfSimilarCallablesCrash
# Nicer Callable Errors
testCallableParsingFromExpr
testCallableParsing
testCallableTooManyVarArg
testCallableKindsOrdering

# Details around Never?
testStar2Context

# Invalid recursive aliases --enable-recursive-aliases
testRecursiveAliasesProhibitBadAliases
# Recursive Alias wrong type var inference --enable-recursive-aliases
testRecursiveAliasesJoins
# Recursive alias union type var inference --enable-recursive-aliases
testRecursiveAliasWithRecursiveInstanceInference
# Recursive alias class type aliases --enable-recursive-aliases
testRecursiveClassLevelAlias

# func type var in __init__
testInvalidNumberOfTypeArgs
testInheritedConstructor2

# Uses function context but is in fact in module context
testFunctionForwardRefAlias

# None + 1 non strict optional
testTypeCheckNamedModule
testTypeCheckNamedModule2
testTypeCheckNamedModule3
testInferOptionalFromDefaultNone
# __contains__ on None (no-strict-optional)
testOptionalIterator

# In A + B, if B is a subclass of A, __radd__ on B is called first
testReverseOperatorOrderingCase4
testReverseOperatorOrderingCase6
testReverseOperatorOrderingCase7
testReverseOperatorWithOverloads2
testFlattenTypeAliasWhenAliasedAsUnion
testOperatorDoubleUnionStandardSubtyping
# "Signatures of "__radd__" of "Fraction" and "__add__" of "T" are unsafely overlapping"
testReverseOperatorOrderingCase3
testReverseOperatorWithOverloads1
testDivReverseOperator
testReverseOperatorTypeVar1
testReverseOperatorTypeVar2a
testReverseOperatorTypeVar2b
testReverseOperatorTypeVar3
testReverseOperatorTypeType
testUnsafeOverlappingWithOperatorMethodsAndOverloading2
testUnsafeOverlappingWithLineNo
testReverseComparisonOperator
testUnsafeOverlappingNamedTuple
# "Forward operator "__add__" is not callable"
testReverseOperatorMethodForwardIsAny3

# Overload union math for __init__
overload_union_math_on_class_init_constrained

# Class function Foo.bar something like a BoundFunction
testParamSpecConstraintOnOtherParamSpec
testExpandNonBareParamSpecAgainstCallable

# Cannot use a covariant type variable as a parameter
testRejectCovariantArgument
testRejectCovariantArgumentSplitLine
testRejectCovariantArgumentInLambda
# Cannot use a contravariant type variable as return type
testRejectContravariantReturnType
testAcceptCovariantReturnType
testAcceptContravariantArgument

# Union of empty lists dicts sets with used ones
testUnificationEmptyListLeft
testUnificationEmptyListRight
testUnificationEmptyListLeftInContext
testUnificationEmptyListRightInContext
testUnificationEmptySetLeft
testUnificationEmptyDictLeft
testUnificationEmptyDictRight
testUnificationDictWithEmptyListLeft
testUnificationDictWithEmptyListRight
testMisguidedSetItem
testOperatorWithEmptyListAndSum

# Union Not matching type vars
testJoinUnionWithUnionAndAny
testNoComplainInferredNoneStrict

# "Cannot determine consistent method resolution order (MRO) for "B""
testCannotDetermineMro
testInconsistentMroLocalRef

# cycle for self.a = self.f(self.a) where f(T) -> T
testGenericTypeBody1
# import cycle
testBoundGenericMethodParamSpecFine
# Cycles
testCyclicUndefinedImportWithName
testCyclicUndefinedImportWithStar1
testCyclicUndefinedImportWithStar2
testCyclicUndefinedImportWithStar3
testNewAnalyzerTypeAnnotationCycle4
testBoundGenericMethodFine
testSelfReferentialSubscriptExpression
testOverrideByIdemAliasCorrectType
testOverrideByIdemAliasCorrectTypeReversed
testConditionalExceptionAlias
testListAssignmentUnequalAmountToUnpack
testNewAnalyzerMemberNameMatchesNamedTuple

# Module attributes
testModuleImplicitAttributes
testSpecialAttrsAreAvaliableInClasses
testSpecialModulesNameImplicitAttr
# Function attributes
testInvalidRvalueTypeInInferredMultipleLvarDefinition
testOverlappingClassCallables
# None attributes
testNoneHasBool
testEqNone
testInferEqualsStillOptionalWithBothOptional
# type attributes
testTypeEquivalentTypeAnyEdgeCase
testMetaclassMemberAccessViaType3

# boolean operators
testOrOperationWithGenericOperands
testOrOperationInferredFromContext

# Bound with Union: Item "{}" of the upper bound "{}" of type variable "{}" has no attribute "{}"
testTypeVarBoundToOldUnionAttributeAccess
testTypeVarBoundToNewUnionAttributeAccess
testUnboundedTypevarUnpacking
# Tuple Bound with iter unpacking
testIterableBoundUnpacking
# Bound not respected
testLiteralAndGenericsRespectsUpperBound
testWideOuterContextEmptyError
# Value of type variable "P" of "new_pro" cannot be "U"
testTypeUsingTypeCTwoTypeVars
testOverloadedCallWithVariableTypes

# *args on TypeVar
testInvalidTypevarValues

# Tuple type var context
testTupleContextFromIterable
testComplexTypeInferenceWithTuple
testInferenceWithTypeVariableTwiceInReturnType
testInferenceWithTypeVariableTwiceInReturnTypeAndMultipleVariables
testLiteralFinalErasureInMutableDatastructures1
testLiteralFinalGoesOnlyOneLevelDown
testLiteralAndInstanceSubtyping
class_generics_recursion
# bottom up tuple inference
testLiteralInferredInTupleContext
# bottom up inference for tuple with *args
testCallerVarArgsListWithTypeInference
testCallerVarArgsTupleWithTypeInference
testCallerVarargsAndComplexTypeInference
# bottom up inference list multiply
testListMultiplyInContext
# bottom up dict
testDictionaryLiteralInContext
testLiteralInferredInDictContext

# context inference from class statement
testSetDescriptorOnClass

# Not able to infer context with unions and literals
testLiteralAndGenericWithUnion
testLiteralAndGenericsNoMatch

# Type variable "C.T" cannot be used as an expression
testClassMemberTypeVarInFunctionBody
# Type variable "__main__.Ts" is invalid as target for type alias
testTypeVarTupleIsNotValidAliasTarget
# Type variable "__main__.T" is unbound
# (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class)
# (Hint: Use "T" in function signature to bind "T" inside a function)
testGenericTypeAliasesRuntimeExpressionsInstance
testNestedGenericFunctionTypeApplication
# An unbound ParamSpec in type application
testParamSpecAliasNested

# ParamSpec is not unbound if working like a T in Callable?
testTrivialParametersHandledCorrectly

# type var backtracking
testUnionInference
testMapWithOverloadedFunc
unite_type_vars_mypy_issue_5874
multiple_lambda_mypy_issue_4226

# Chained assignments are not legal like a = b = [] if a and b are list[int]
# and list[str].
testChainedAssignmentInferenceContexts

# Nested type vars
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues
testGenericClassInnerFunctionTypeVariable
testFunctionInGenericInnerClassTypeVariable-skip
testSubtypingWithGenericInnerFunctions
testNestedGenericFunctions
testInnerFunctionTypeVar
testConstraintsBetweenConcatenatePrefixes
testParamSpecDecoratorImplementation
testParamSpecArgsAndKwargsMissmatch
testParamSpecTestPropAccess
testTupleAndDictOperationsOnParamSpecArgsAndKwargs
testUnpackingParamsSpecArgsAndKwargs
testParamSpecConcatenateFromPep
param_spec_with_identity_mypy_issue_12278

# Param spec invalid definitions
testInvalidParamSpecDefinitionsWithArgsKwargs
testInvalidParamSpecAndConcatenateDefinitionsWithArgsKwargs
testUnboundParamSpec
# Param spec invalid calls
testParamSpecInvalidCalls

# Callable type alias definition
testConcatDeferralNoCrash

# Are generics in self types always bound to the function?
# https://github.com/python/typing/discussions/1340
# https://github.com/python/mypy/issues/14729
testSelfTypeBadTypeIgnoredInConstructorGeneric
testSelfTypeRestrictedMethodOverloadInit

# function call in class of function in class
testCallConditionalMethodInClassBody

# Class in function special cases
testNewAnalyzerUnsupportedBaseClassInsideFunction
testInfiniteLoop
testGenericClassWithinFunction
testGenericClassWithInvalidTypevarUseWithinFunction
testAccessToLocalInOuterScopeWithinNestedClass
# Class in function type comment
testClassWithinFunction
testDeclareVariableWithNestedClassType
# NewType in function "A@6" as qualified name
testNewTypeInLocalScope
# class in class forward reference
testForwardReferenceToNestedClassWithinClass
testClassWithBaseClassWithinClass
testDeclarationReferenceToNestedClass
# function types in class body
testMethodRefInClassBody
# Class argument and __init__ as overloaded DbType
testOverloadedToGeneric

# Class: generic access from outside
# Type application vs. type declaration (type alias)
testGenericTypeAliasesTypeVarBinding
testParamSpecApplyConcatenateTwice
testNewAnalyzerAliasToNotReadyClassDoubleGeneric
testTypeAliasesResultingInPlainInstance
testSelfTypeMultipleTypeVars
testTypingSelfNonAnnotationUses

# Property
testBoundMethodUsage
testNonMethodProperty
testInvalidArgCountForProperty
testNewAnalyzerProperty
testNewAnalyzerNoCrashOnCustomProperty
testOverloadNotConfusedForProperty
testForwardReferenceToDynamicallyTypedProperty
testForwardReferenceToStaticallyTypedProperty
testTypingSelfProperty
testSelfTypePropertyUnion
testSelfTypeProperSupertypeAttribute
testSelfTypeProperSupertypeAttributeTuple
testSelfTypeProperSupertypeAttributeMeta
testSelfTypeProperSupertypeAttributeGeneric
testUnionPropertyField
testAccessingReadOnlyProperty
testAssigningToReadOnlyProperty
testAssigningToInheritedReadOnlyProperty
testPropertyGetterBody
testDynamicallyTypedProperty
testPropertyWithSetter
testPropertyWithDeleterButNoSetter
testAllowPropertyAndInit1
testAllowPropertyAndInit2
testPropertyWithExtraMethod
testOverrideAttrWithSettableProperty
testOverrideAttrWithSettablePropertyAnnotation
testOverrideMethodProperty
testOverridePropertyMethod
testEllipsis
testCrashOnComplexNamedTupleUnionProperty
testNamedTupleProperty
testNewNamedTupleProperty
testFastParseProperty
testFastParseConditionalProperty
# Decorated property not supported
testOverloadedProperty
testOverloadedProperty2
testDecoratedPropertySetter

# descriptors wrong decorator check name binding issue
testClassCustomPropertyWorks
# classmethod name redirect name binding issue
testAliasToClassMethod

# classmethod not a valid classmethod
testClassmethodAndNonMethod
# Self type classmethod access with type vars(no Self)
testSelfTypeClone
testNewAnalyzerTypeVarBoundInCycle
testSelfTypeVarIndexExpr

# classmethod overloads
testGenericClassMethodOverloaded
testOverloadClassmethodDisappears
testOverloadWithClassMethods
testOverloadWithInconsistentClassMethods
testOverloadAndClassTypes
testGenericClassInGenericFunctionOverloadedConstructor-skip
testGenericClassAlternativeConstructorPreciseOverloaded
testOverloadClassMethodImplementation
testOverloadWithSwappedDecorators
testClassMethodBeforeInit3
testRefMethodWithOverloadDecorator
# classmethod self type with overload
testSelfTypeClassMethodOverloadedOnInstance
SelfTypeOverloadedClassMethod

# staticmethod
testStaticmethodAndNonMethod
testTypeConstructorReturnsTypeType
testTypingSelfClassMethod
testForwardReferenceToDynamicallyTypedStaticMethod
testOverloadWithSwappedDecorators2
testOverloadWithStaticMethods
testBuiltinStaticMethod
testRefMethodWithDecorator
testStaticMethodWithNoArgs
testIgnoredModuleDefinesBaseClassAndClassAttribute
# staticmethod call error has no Argument 1 to "f" of "A"
testSimpleStaticMethod
testForwardReferenceToStaticallyTypedStaticMethod

# "The erased type of self "Type[__main__.A]" is not a supertype of its class "Type[__main__.B]""
testSelfTypeNonsensical
testSelfTypeNew

# typing assert_type
testTypingSelfAssertType
testInvalidAssertType
testAssertType
testAssertTypeGeneric
testAssertTypeUncheckedFunction
testAssertTypeUncheckedFunctionWithUntypedCheck

# Final literal issues
testLiteralWithFinalPropagation
testLiteralWithFinalPropagationIsNotLeaking

# Tuple Super Class
testGenericTupleTypeCreation
testGenericTupleTypeSubclassing
testTypeAliasesToNamedTuple
testNewAnalyzerTupleIteration
testValidTupleBaseClass2
testGenericClassWithTupleBaseClass
testTupleSubclassJoin
testTypeTupleCall
# Tuple indexing (including slices)
testLiteralIntelligentIndexingTuples
testLiteralIntelligentIndexingTupleUnions
testMutuallyRecursiveNamedTuplesClasses
testNonliteralTupleSlice
testIndexingWithDynamic
testIndexingTuples
testIndexingTuplesWithNegativeIntegers
testMultipleAssignmentWithIndexedLvalues
testTupleMeetTupleVariable
testNonliteralTupleIndex
# `Foo: NamedTuple` used as definition
testNamedTupleTypeIsASuperTypeOfOtherNamedTuples
testNamedTupleTypeIsASuperTypeOfOtherNamedTuplesReturns
# Semanal issues
testTypingNamedTupleWithTooFewArguments
# "Class has two incompatible bases derived from tuple"
testNamedTuplesTwoAsBaseClasses
testNamedTuplesTwoAsBaseClasses2
# "NamedTuple type as an attribute is not supported"
testAssignNamedTupleAsAttribute
# "First argument to namedtuple() should be "A", not "X""
testNamedTupleTypeNameMatchesVariableName
testInvalidNamedTupleWithinFunction
# "Statement is unreachable"
testNamedTupleWithBoolNarrowsToBool
# "Self type cannot be used in NamedTuple item type"
testNamedTupleSelfItemNotAllowed
# "Property "y" defined in "Point" is read-only"
testTypingExtensionsNamedTuple
testNamedTupleAttributesAreReadOnly
# Namedtuple unpacking size messages
testNamedTupleUsedAsTuple
# Joining namedtuples (especially generic once)
testGenericNamedTupleJoin
# "Generic named tuples are not supported for legacy class syntax"
testGenericNamedTupleNoLegacySyntax
# Recursive generic NamedTuple
testBasicRecursiveGenericNamedTuple
# NamedTuple generic used
testGenericNamedTupleCallSyntax
# ^ need to add generic namedtuple tests for call syntax
# NamedTuple special methods
testNewAnalyzerNamedTupleSpecialMethods
testNewAnalyzerNamedTupleBaseClass
testNamedTupleAsDict
testNamedTupleReplace
testNamedTupleReplaceAsClass
testNamedTupleReplaceTyped
testNamedTupleMake
testNamedTupleFields
testNamedTupleSource
testNamedTupleUnit
testNamedTupleFieldTypes
testNamedTupleSelfTypeReplace
testNamedTupleSelfTypeMake
testNamedTupleTypingSelfMethod
testGenericNamedTupleMethods
# Namedtuple class attr access
testNamedTupleForwardFunctionIndirectReveal
testNamedTupleMissingClassAttribute
# Namedtuple bad overwrite of count etc
testNamedTupleIncompatibleRedefinition
testNewNamedTupleIllegalNames
# "Protocol member HasX.x expected settable variable, got read-only attribute"
testTypingNamedTupleAttributesAreReadOnly

# data class (currently all are passing)

# Enum
testNewAnalyzerEnumRedefinition
testRefreshFunctionalEnum
testRefreshClassBasedEnum
testRefreshClassBasedIntEnum
testClassBasedEnumPropagation1
testClassBasedEnumPropagation2
testRefreshFuncBasedEnum
testRefreshFuncBasedIntEnum
testFuncBasedEnumPropagation1
testFuncBasedEnumPropagation2
testLiteralWithEnumsBasic
testLiteralWithEnumsDefinedInClass
testLiteralWithEnumsSimilarDefinitions
testLiteralWithEnumsDeclaredUsingCallSyntax
testLiteralWithEnumsDerivedEnums
testLiteralWithEnumsAliases
testLiteralUsingEnumAttributesInLiteralContexts
testLiteralUsingEnumAttributeNamesInLiteralContexts
testAliasForEnumTypeAsLiteral
testInvariance
testStrictEqualityAndEnumWithCustomEq

# TypedDict
testTypedDictWithDocString
testCanCreateTypedDictTypeWithDictLiteral
testNewAnalyzerTypedDictClass
testNewAnalyzerTypedDictClassInheritance
testNewAnalyzerMemberNameMatchesTypedDict
testTypeVarWithTypedDictBoundInIndexExpression
testTypeVarWithUnionTypedDictBoundInIndexExpression
testTypeVarWithTypedDictValueInIndexExpression
testDirectlyImportTypedDictObjectAtTopLevel
testUnpackWithoutTypedDict
testUnpackTypedDictTotality
testUnpackKeywordTypesTypedDict
testUnpackKwargsOverridesTypedDict
testUnpackGenericTypedDictImplicitAnyEnabled
testUnpackGenericTypedDictImplicitAnyDisabled
testOverloadKwargsSelectionWithTypedDict
testOverloadTypedDictDifferentRequiredKeysMeansDictsAreDisjoint
testOverloadedTypedDictPartiallyOverlappingRequiredKeys
testOverloadedTypedDictFullyNonTotalDictsAreAlwaysPartiallyOverlapping
testOverloadedTotalAndNonTotalTypedDictsCanPartiallyOverlap
testOverloadedTypedDictsWithSomeOptionalKeysArePartiallyOverlapping
testBasicRecursiveTypedDictClass
testBasicRecursiveTypedDictCall
testBasicRecursiveTypedDictExtending
testRecursiveTypedDictCreation
testRecursiveTypedDictMethods
testRecursiveTypedDictSubtyping
testRecursiveTypedDictJoin
testBasicRecursiveGenericTypedDict
testRecursiveGenericTypedDictExtending
testTypedDictRefresh
testTypedDictUpdate
testTypedDictUpdate2
testTypedDictUpdate3
testTypedDictCrashFallbackAfterDeletedMeet
testTypedDictCrashFallbackAfterDeletedJoin
testTypedDictUpdateGeneric
testLiteralIntelligentIndexingTypedDict
testLiteralIntelligentIndexingTypedDictUnions
testLiteralIntelligentIndexingMultiTypedDict
testUnpackKwargsNonIdentifier
testTypedDictNestedClassRecheck
testLiteralIntelligentIndexingUsingFinal
testCrashOnSelfRecursiveTypedDictVar
testCorrectJoinOfSelfRecursiveTypedDicts
testCrashInForwardRefToTypedDictWithIsinstance
testNewTypeFromForwardTypedDict
testCorrectItemTypeInForwardRefToTypedDict
testCrashOnDoubleForwardTypedDict
testCrashOnForwardUnionOfTypedDicts
testCrashInvalidArgsSyntheticClassSyntax
testCrashInvalidArgsSyntheticClassSyntaxReveals
testCrashInvalidArgsSyntheticFunctionSyntax
testCrashForwardSyntheticClassSyntax
testCrashForwardSyntheticFunctionSyntax
testRecursiveTypedDictWithList
testNewAnalyzerTypeArgBoundCheckDifferentNodes
testDistinctTypes
testForwardRefsInWithStatementImplicit
testForwardRefsInWithStatement

# NoReturn
testNoReturnTypeAlias
testUnionWithNoReturn
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2
testDontNeedAnnotationForCallable
testLiteralCheckSubtypingStrictOptional
testLiteralCheckSubtypingNoStrictOptional

# typing.no_type_check
testNoTypeCheckDecoratorOnMethod1
testNoTypeCheckDecoratorOnMethod2
testCallingNoTypeCheckFunction
testCallingNoTypeCheckFunction2
testNoTypeCheckDecoratorSemanticError

# Union attribute error: Item "D" of "C | D" has no attribute "y"
testUnionAttributeAccess
testOverloadBadArgumentsInferredToAny2

# Union iter()
testUnionMultiassignSingle
testUnionMultiassignDouble
testUnionMultiassignGeneric
testUnionMultiassignAny
testUnionMultiassignNotJoin
testUnionMultiassignRebind
testUnionMultiassignAlreadyDeclared
testUnionMultiassignIndexed
testUnionMultiassignIndexedWithError
testUnionMultiassignPacked
testUnpackingUnionOfListsInFunction
testUnionOfVariableLengthTupleUnpacking
testUnionOfNonIterableUnpacking
testUnionAlwaysTooMany
testUnionAlwaysTooFew
testUnionUnpacking*
testNestedUnionUnpackingFromNestedTuples
testNestedUnionUnpackingFromNestedTuplesBinder
testUnpackUnionNoCrashOnPartialNone
testUnpackUnionNoCrashOnPartialNone2
testUnpackUnionNoCrashOnPartialNoneBinder
testUnpackUnionNoCrashOnPartialNoneList
testReusingInferredForIndex
testReusingInferredForIndex2
testNestedProtocolUnions
testNestedProtocolGenericUnions
testNestedProtocolGenericUnionsDeep
testNestedInstanceUnsimplifiedUnion
testNestedInstanceTypeAlias
testNestedInstanceTypeAliasUnsimplifiedUnion
# Tuple iter fixes
testTupleBaseClass

# Dynamic functions are not type checked?!
testNoInvalidTypeInDynamicFunctions
testCallGenericFunctionWithTypeVarValueRestrictionInDynamicFunc
testDynamicallyTypedNestedFunction
testInferringImplicitDynamicTypeForLvar
testInferringMultipleLvarDefinitionWithImplicitDynamicRvalue
testLambdaUnypedContext
testSkipTypeCheckingWithImplicitSignature
testSkipTypeCheckingWithImplicitSignatureAndDefaultArgs
testSkipTypeCheckingImplicitMethod
testTooManyArgsInDynamic
testTooFewArgsInDynamic
testJustRightInDynamic
# Dynamic functions are ignored in classes and the super class is used?
testInferringTypesFromIterable
# "'reveal_type' always outputs 'Any' in unchecked functions"
testRevealUncheckedFunction
# Function duplicate param names
testFastParserDuplicateNames

# Comprehensions
testNewAnalyzerListComprehension
testNewAnalyzerDictionaryComprehension
testEnumerateReturningSelfFromIter
testSimpleListComprehension
testSimpleListComprehensionNestedTuples
testSimpleListComprehensionNestedTuples2
testListComprehensionWithNonDirectMapping
testErrorInListComprehensionCondition
testTypeInferenceOfListComprehension
testSimpleListComprehensionInClassBody
testSimpleSetComprehension
testSimpleDictionaryComprehension
testDictionaryComprehensionWithNonDirectMapping
testSimpleGeneratorExpression
testGeneratorIncompatibleErrorMessage
testSetComprehension
testSetComprehensionWithCondition
testDictionaryComprehension
testDictionaryComprehensionWithCondition
testComprehensionShadowBinder
# comprehensions Scoping
testListComprehensionSpecialScoping

# lambda
testLambdaWithArguments
testLambdaDefaultTypeErrors
testLambdaDefaultContext
testLambdaVarargContext
testLambdaDeferredSpecialCase
testErasedTypeRuntimeCoverage
testLambdaJoinWithDynamicConstructor
testSelfTypeLambdaDefault
testEnclosingScopeLambdaNoCrash
testEnclosingScopeLambdaNoCrashExplicit
testLambdaAndReachability
# lambda: Name "UNDEFINED" is not defined
testLambdaInheritsCheckedContextFromTypedFunc
testLambdaInheritsCheckedContextFromTypedFuncForced
testLambdaInheritsCheckedContextFromModule
testLambdaInheritsCheckedContextFromModuleForce
testLambdaInheritsCheckedContextFromModuleLambdaStack
testLambdaInheritsCheckedContextFromModuleLambdaStackForce
testLambdaInheritsCheckedContextFromFuncLambdaStackForce
testLambdaInheritsCheckedContextFromTypedFuncLambdaStack
testLambdaInheritsCheckedContextFromTypedFuncLambdaStackForce
testLambdaInheritsCheckedContextFromClassLambdaStack
testLambdaInheritsCheckedContextFromClassLambdaStackForce
# Lambda with defined return types (inferred context)
testInferLambdaTypeUsingContext
testLambdaWithoutContext
testInvalidContextForLambda
testEllipsisContextForLambda
testEllipsisContextForLambda2
testIsinstanceInInferredLambda
testLambdaDeferredCrash
# Cannot infer type of lambda
testParamSpecLiteralsTypeApplication
# Param Spec lambda type inference
testParamSpecInferredFromLambda

# Protocol
testProtocolUpdateTypeInVariable
testProtocolUpdateTypeInFunction
testProtocolUpdateTypeInClass
testProtocolAddAttrInFunction
testProtocolRemoveAttrInClass
testProtocolConcreteUpdateTypeFunction
testProtocolConcreteUpdateTypeMethodGeneric
testProtocolConcreteRemoveAttrVariable
testProtocolConcreteUpdateBaseGeneric
testProtocolUpdateBaseGeneric
testProtocolChangeGeneric
testNonProtocolToProtocol
testInvalidateProtocolViaSuperClass
testProtocolInvalidateConcreteViaSuperClassUpdateType
testProtocolInvalidateConcreteViaSuperClassAddAttr
testProtocolInvalidateConcreteViaSuperClassRemoveAttr
testTwoProtocolsTwoFilesCrossedUpdateType-only_when_nocache
testTwoProtocolsTwoFilesCrossedDeleteAttr-only_when_cache
testProtocolsInvalidateByRemovingBase
testProtocolVsProtocolSubUpdated
testProtocolVsProtocolSuperUpdated
testProtocolVsProtocolSuperUpdated2
testProtocolVsProtocolSuperUpdated3
testProtocolMultipleUpdates
testWeAreCarefulWithBuiltinProtocols
testWeAreCarefullWithBuiltinProtocolsBase
testModuleAsProtocolImplementationFine
testMixinAllowedWithProtocol
testBadClassLevelDecoratorHack
testSelfTypeProtocolClassmethodMatch
testCannotUseNewTypeWithProtocols
testBuiltinClassMethod
testDivmod
testProtocolsInvalidateByRemovingMetaclass
testSubtypingTupleIsSized
# Duck typing
testOverloadingAndDucktypeCompatibility

# TypeVarTuple
testTypeVarTupleMixed
testTypeVarTupleChaining
testTypeVarTupleGenericClassDefn
testTypeVarTupleCached
testTypeVarTuplePep646ArrayExample
testTypeVarTuplePep646ArrayExampleWithDType
testTypeVarTuplePep646TypeVarTupleUnpacking
testTypeVarTuplePep646TypeVarStarArgsBasic
testTypeVarTuplePep646TypeVarStarArgs
testTypeVarTuplePep646TypeVarStarArgsFixedLengthTuple
testTypeVarTuplePep646TypeVarStarArgsVariableLengthTuple
testTypeVarTuplePep646Callable
testTypeVarTuplePep646CallableWithPrefixSuffix
# typing_extensions.Unpack
testRuntimeProtoTwoBases
testUnpackKwargsReveal
testUnpackOutsideOfKwargs
testUnpackWithDuplicateKeywords
testUnpackWithDuplicateKeywordKwargs
testUnpackKwargsEmpty
testUnpackUnexpectedKeyword
testUnpackKeywordTypes
testFunctionBodyWithUnpackedKwargs
testUnpackKwargsOverrides
testUnpackKwargsGeneric
testUnpackKwargsInference
testUnpackKwargsOverload
testUnpackKwargsJoin
testUnpackKwargsParamSpec
testUnpackKwargsUpdateFine
testUnpackNoCrashOnEmpty
testInvalidUnpackTypes
# Unpack item in ** argument must be a TypedDict
testTypeVarTuple

# Visibility of imports in pyi
testNewSemanticAnalyzerModulePrivateRefInMiddleOfQualified

# x: typing_extensions.TypeAlias = int
testClassLevelTypeAliasesInUnusualContexts
testMalformedTypeAliasRuntimeReassignments

# TypeAlias normal string interpreted as a forward reference
testTypeAliasWithNewStyleUnionChangedToVariable

# "Missing return statement"
testWarnNoReturnWorksWithStrictOptional
testAssertCurrentFrameIsNotUnreachable
testNoReturnInGenerator
testWithStmtBoolExitReturnOkay

# ""f" does not return a value"
testUseOfNoneReturningFunction
testNoneReturnTypeBasics
testNoneReturnTypeWithStatements
testNoneReturnTypeWithExpressions
testNoneReturnTypeWithExpressions2
testConditionalExpressionWithEmptyCondition
testConditionalExpressionStatementNoReturn
testVoidValueInTuple

# stdlib imports
testOverloadSpecialCase
testSubclassingGenericABCWithImplicitAny
testSubclassingGenericABCWithImplicitAnyAndDeepHierarchy
testImplementingGenericABCWithImplicitAnyAndDeepHierarchy2
testSubtypingAndABCExtension
testAccessingGenericABCMembers
testAccessingInheritedGenericABCMembers
testPrecedenceOfFirstBaseAsInferenceResult
type_var_with_co_and_contra_real_life
testBuiltinsUsingModule
# future imports (future is not part of stubs)
testNewAnalyzerMetaclassFuture1
testNewAnalyzerMetaclassFuture3
testNewAnalyzerMetaclassFuture4
testFutureMetaclass
testFromFutureMetaclass
testFutureMetaclassImportFrom
testFutureMetaclassImport
testFutureMetaclassAndBase
testFutureMetaclassGenerics
testFutureMetaclassErrors
testFutureMetaclassAny
# six imports
testNewAnalyzerMetaclassSix1
testNewAnalyzerMetaclassSix2
testNewAnalyzerMetaclassSix3
testNewAnalyzerMetaclassSix4
testSixMetaclassImportFrom
testSixMetaclassImport
testSixMetaclassAndBase
testSixMetaclassGenerics
testSixMetaclassErrors
testSixMetaclassAny
testSixMetaclass
testFromSixMetaclass
testSixMetaclassGenericBase
testIgnoreInsideClassDoesntAffectWhole

# star imports in modules that are imported
testRelativeImport3

# Binary or implementation missing
testMiscBinaryOperators

# Module __all__
testNewAnalyzerExportedValuesInImportAll
testExportedValuesInImportAll
testAllMustBeSequenceStr
testUnderscoreExportedValuesInImportAll
testReExportAllInStub

# Module <M> has no attribute <missing_name>
testRelativeImportFromSameModule
testImportFromSameModule
# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions
testImportMisspellingSingleCandidate
testImportMisspellingMultipleCandidates
testImportMisspellingMultipleCandidatesTruncated

# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testKeywordMisspelling
testMultipleKeywordsForMisspelling
testKeywordMisspelling*

# Import submodules
testNewAnalyzerImportStarSpecialCase

# Submodule was not imported
testSubmoduleImportFromDoesNotAddParents
testSubmoduleMixingImportFromAndImport

# import a.b.c issues
testMissingSubmoduleImportedWithIgnoreMissingImports
testMissingSubmoduleImportedWithIgnoreMissingImportsStub
testMissingSubmoduleImportedWithIgnoreMissingImportsNested
testMissingSubmoduleOfInstalledStubPackage
testGenericAliasCollectionsABCReveal

# Complex Star import
testImportWithinMethod
testNoCrashOnImportFromStarNested
# Star import override
testAssignToFuncDefViaImport

# Module type does not contain module info
testMultiModuleAlias
testModuleAliasWithExplicitAnnotation

# Import itself / Extremely weird import orders
testNewAnalyzerImportCycleWithIgnoreMissingImports
testNewAnalyzerImportFromTopLevelFunction
testNewAnalyzerImportFromTopLevelAlias
testNewAnalyzerImportAmbiguousWithTopLevelFunction
testImportCycleSpecialCase
testPackagePath

# namespace packages
testClassicNotPackage
testNamespacePackage*
testClassicPackageIgnoresEarlierNamespacePackage
testClassicPackageInsideNamespacePackage

# Stub Reexport
testNoReExportFromStubs
testNoReExportFromStubsMemberType
testNoReExportFromStubsMemberVar
testNoReExportChildStubs
testReExportChildStubs
testReExportChildStubs2
testNoReExportNestedStub
testNoReExportFromMissingStubs
testMissingGenericImport
testStubFixupIssues
testNoReExportUnrelatedModule
testNoReExportUnrelatedSiblingPrefix
testUnimportedHintAny
testUnimportedHintAnyLower
testFromImportAsInStub
testImportAsInStub

# "Invalid metaclass "Explicit"" when Explicit: TypeAlias = type
testValidTypeAliasAsMetaclass
testValidTypeAliasOfTypeAliasAsMetaclass
# Metaclass self type
testSelfTypeProtocolMetaclassMatch
testMetaclassSelfType
testSelfTypeStructureMetaclassMatch
# "Self type cannot be used in a metaclass"
testTypingSelfMetaClassDisabled
# Metaclass Union
testNotSimplifyingUnionWithMetaclass
# Metaclass iter/getitem/addition
testMetaclassGetitem
testMetaclassIterable
testInferringLvarTypesUnpackedFromIterableClassObject
testInferringLvarTypesUnpackedFromIterableClassObjectWithGenericIter
testMetaclassOperators
testMetaclassOperatorsDirect

# Use type(foo) when foo has a metaclass
testMetaclassTypeCallable
testMetaclassMemberAccessViaType
# Foo = type(...) used as `x: Foo` (type execution)
testNoneAlias
testNoneAliasStrict

# Type[Any] is object
testSimplifyingUnionWithTypeTypes2

# abstractmethod / ABCMeta
testMakeClassNoLongerAbstract1
testMakeClassNoLongerAbstract2
testAddAbstractMethod
testMakeClassAbstract
testMakeMethodNoLongerAbstract1
testMakeMethodNoLongerAbstract2
testAbstractBodyTurnsEmpty
testAbstractBodyTurnsEmptyProtocol
testAbstractGlobalFunction
testAbstractNestedFunction
testInferenceWithAbstractClassContext3
testAbstractClasses
testAbstractInit
testNewAnalyzerClassPropertiesInAllScopes
testConstructorJoinsWithCustomMetaclass

# Signature of "???" incompatible with supertype "???"
testKeywordOnlyArgumentOrderInsensitivity
testPositionalOverridingArgumentNamesCheckedWhenMismatchingPos
testOverrideGenericMethodInNonGenericClassLists
testOverrideGenericMethodInNonGenericClassGeneralize
testOverloadedMethodSupertype-only_when_cache
testOverloadedMethodSupertype2-only_when_nocache
testOverloadedInitSupertype
testIncompatibleOverrideFromCachedModuleIncremental
testOverrideAttributeWithMethod
testMethodOverridingWithIncompatibleArgumentCount
testOverrideWithDecorator
testOverrideDecorated
testOverrideWithDecoratorReturningInstance
testClassMethodSubclassing
testOverloadedOperatorMethodOverrideWithSwitchedItemOrder
testVariableMethod
testClassStaticMethodSubclassing
testCyclicOverrideChecked
testCyclicOverrideCheckedDecorator
testCyclicOverrideCheckedDecoratorDeferred
testParentClassWithTypeAliasAndSubclassWithMethod
testSelfTypeOverrideCompatibilityTypeVar

# supertype context inference
testUseSupertypeAsInferenceContext
testUseSupertypeAsInferenceContextInvalidType
testUseSupertypeAsInferenceContextPartial
testUseSupertypeAsInferenceContextPartialError
testUseSupertypeAsInferenceContextPartialErrorProperty
testUseSupertypeAsInferenceContextConflict
testLiteralSubtypeContext
testLiteralSubtypeContextNested
testLiteralSubtypeContextGeneric

# super()
testSuperExpressionsWhenInheritingFromGenericType
testSuperExpressionsWhenInheritingFromGenericTypeAndDeepHierarchy
testSuperOutsideClass
testSuperField
testSuperBasics
testRefreshGenericSubclass
testConstrainedGenericSuper
testTypingSelfOnSuperTypeVarValues
testSelfTypeSuper
testMixinProtocolSuper
testConstructorSignatureChanged3
testRefreshSubclassNestedInFunction2
testCyclicDecoratorSuper
testCyclicDecoratorSuperDeferred

# class types defined in super class
testInheritanceFromGenericWithImplicitDynamic

# "Invalid self argument "A[C]" to attribute function "f" with type "Callable[[A[B]], None]""
testInvalidMethodAsDataAttributeInGenericClass
# "Attribute function "f" with type "Callable[[], None]" does not accept self argument"
testMethodWithInvalidMethodAsDataAttribute
testClassValuedAttributesBasics

# ClassVar
testMethodAsDataAttribute
testMethodWithDynamicallyTypedMethodAsDataAttribute
testPartiallyTypedSelfInMethodDataAttribute
testCallableDataAttribute
testTypingSelfClassVar
testTypingSelfCallableClassVar
testSelfTypeCallableClassVarOldStyle
testMetaclassAsAny
testMetaclassStrictSupertypeOfTypeWithClassmethods
testMetaclassAsAnyWithAFlag

# "Variance of TypeVar "T_contra" incompatible with variance in parent type"
testIncompatibleVariance

# Self type variable type
testDecoratorUpdateNestedClass
testDecoratorUpdateClassInFunction
param_spec_with_generic_class

# Self tests
testTypingSelfAttrOldVsNewStyle
# "Method cannot have explicit self annotation and Self type"
testTypingSelfConflict
# "Self argument missing for a non-static method"
# "The erased type of self "None" is not a supertype of its class "__main__.A""
testSelfTypeNotSelfType

# None as a default for class variables, even if not optional?
testNoneClassVariable
testNoneClassVariableInInit
testMultipleAssignmentNoneClassVariableInInit

# Liskov
testLiskovFineVariable
testLiskovFineVariableInFunction
testLiskovFineDecorator
testLiskovFineVariableClean-only_when_nocache
testLiskovFineVariableCleanDefInMethod-only_when_nocache
testLiskovFineVariableCleanDefInMethodStar-only_when_nocache
testLiskovFineVariableCleanDefInMethodNested-only_when_nocache
testLiskovFineVariableInFunctionClean-only_when_nocache
testLiskovFineDecoratorClean-only_when_nocache
testPositionalOverridingArgumentNameInsensitivity
testOverridingMethodInSimpleTypeInheritingGenericType
testOverridingMethodInGenericTypeInheritingSimpleType
testOverridingMethodInMultilevelHierarchyOfGenericTypes
testOverridingMethodInGenericTypeInheritingGenericType
testSubclassingGenericABC1
testSubclassingGenericABCWithDeepHierarchy
testSubclassingGenericABCWithDeepHierarchy2
testMethodOverridingWithIncompatibleTypes
testEqMethodsOverridingWithNonObjects
testMethodOverridingAcrossDeepInheritanceHierarchy1
testOverrideStaticMethodWithStaticMethod
testOverrideClassMethodWithClassMethod
testOverrideClassMethodWithStaticMethod
testOverrideStaticMethodWithClassMethod
testIntroducingInplaceOperatorInSubclass
testMethodOverridingWithIncompatibleTypesOnMultipleLines
testMultiLineMethodOverridingWithIncompatibleTypesWrongIgnore
testOverridingMethodAcrossHierarchy
testMultipleInheritance_MethodDefinitionsIncompatibleOverride

# "Return type "int" of "foo" incompatible with return type "str" in supertype "B""
testPreviousErrorInDecoratedMethodOverride
testAddBaseClassMethodCausingInvalidOverride
testModifyBaseClassMethodCausingInvalidOverride
testSelfTypeBound
testMethodOverridingAcrossDeepInheritanceHierarchy2
testMethodOverridingWithVoidReturnValue
testNewNamedTupleMethodInheritance
# Signatures of "__ior__" and "__or__" are incompatible
testGenericOperatorMethodOverlapping
testGenericOperatorMethodOverlapping2
testOverlappingNormalAndInplaceOperatorMethod
testOverloadedNormalAndInplaceOperatorMethod
#  Incompatible types in assignment (expression has type "int", base class "BaseS" defined the type as "str")
testAliasFineNormalClassBases
testTypingSelfOverrideVar
testTypingSelfOverrideVarMulti
testOverrideMethodWithAttribute
testVariableSubclassAssignMismatch
testVariableSubclassAssignment
testVariableSubclassTypeOverwrite
testVariableSubclassTypeOverwriteImplicit
testClassAllBases
testVariableTypeVarInvalid
testVariableTypeVarIndirectly
testVariableProperty
testInstanceMethodOverwriteError
testClassMethodOverwriteError
testClassSpecError
testClassStaticMethod
testClassStaticMethodIndirect
testClassMemberObject
testClassOrderOfError
testClassOneErrorPerLine
testClassIgnoreType_RedefinedAttributeAndGrandparentAttributeTypesNotIgnored
testCheckForPrivateMethodsWhenPublicCheck
testAttributeDefOrder1
testAttributeDefOrder2
testGenericOverridePreciseInvalid
testGenericOverrideGeneric
testGenericOverrideGenericChained
testNamedTupleFallback
testMultipleInheritance_NestedVariableOverriddenWithIncompatibleType1
testMultipleInheritance_NestedVariableOverriddenWithIncompatibleType2
# List item 0 has incompatible type "str"; expected "int"
testVariableTypeVarList
testInWithInvalidArgs

# "Definition of "f" in base class "A" is incompatible with definition in base class "B""
testMethodNameCollisionInMultipleInheritanceWithIncompatibleSigs
testMethodNameCollisionInMultipleInheritanceWithIncompatibleSigs2
testInstanceVarNameOverlapInMultipleInheritanceWithInvalidTypes
testClassVarNameOverlapInMultipleInheritanceWithInvalidTypes
testMethodOverlapsWithClassVariableInMultipleInheritance
testMethodOverlapsWithInstanceVariableInMultipleInheritance
testMultipleInheritanceAndDifferentButCompatibleSignatures
testMultipleInheritance_NestedClassesWithSameName
testMultipleInheritance_NestedClassesWithSameNameCustomMetaclass
testMultipleInheritance_NestedClassesWithSameNameOverloadedNew
testMultipleInheritance_NestedClassAndAttrHaveSameName
testMultipleInheritance_NestedClassAndFunctionHaveSameName
testMultipleInheritance_NestedClassAndRefToOtherClass
testMultipleInheritance_ReferenceToSubclassesFromSameMROOverloadedNew
testMultipleInheritance_ReferenceToGenericClasses
testMultipleInheritance_GenericSubclasses_SuperclassFirst
testMultipleInheritance_RefersToNamedTuples
testMultipleInheritance_NestedVariableRefersToSuperlassUnderSubclass
testMultipleInheritance_MethodsReturningSelfIncompatible
testNestedVariableRefersToCompletelyDifferentClasses
testGenericMultipleOverrideReplace

# setting class attributes on self
self_instance_variable1

# verify class definitions when setting self
testInferAttributeTypeAndAssignInInit
testTypingSelfInternalSafe
testTypingSelfClashInBodies

# untyped (inferred?) instance attributes
testChangeBaseClassAttributeType

# subclass preferred over class for types
testAddBaseClassAttributeCausingErrorInSubclass

# base class: type alias
testOptionalAndAnyBaseClass
# base class: callable
testInvalidBaseClass
# class base Any in combination with overload
testOverloadWithDerivedFromAny

# `class type` stuff
testObfuscatedTypeConstructorReturnsTypeType
testOtherTypeConstructorsSucceed
testTypeTypeComparisonWorks
# type vs type[object]
testGeneralTypeMatchesSpecificTypeInOverloadedFunctions
testNonTypeDoesNotMatchOverloadedFunctions
testTypeConstructorLookalikeFails
# `class type` access on class
testTypeUsingTypeCTypeAnyMember
testTypeUsingTypeCTypeAnyMemberFallback
testTypeUsingTypeCTypeNoArg
testTypeUsingTypeCClassMethod
testTypeUsingTypeCClassMethodUnion
testTypeUsingTypeCClassMethodFromTypeVar
testTypeUsingTypeCClassMethodFromTypeVarUnionBound
testTypeUsingTypeCClassMethodFromTypeVarUnionBound
testTypeUsingTypeCErrorUnsupportedType
testTypeUsingTypeCOverloadedClass
testTypeUsingTypeCTuple
testTypeUsingTypeCJoin

# __new__
testClassMethodUnannotated
testDunderNewUpdatedMethod
testDunderNewUpdatedSubclass
testDunderNewUpdatedAlias
testDunderNewUpdatedCallable
testDunderNewDefine
testDunderNewInsteadOfInit
testSelfTypeInGenericClassUsedFromAnotherGenericClass1
testOverride__new__AndCallObject
testConstructInstanceWith__new__
testConstructInstanceWithDynamicallyTyped__new__
testClassWith__new__AndCompatibilityWithType
testClassWith__new__AndCompatibilityWithType2
testGenericClassWith__new__
testOverloaded__new__
testNewAndInit1
testNewAndInit2
testNewAndInit3
testNewReturnType1
testNewReturnType3
testNewReturnType4
testNewReturnType5
testNewReturnType6
testNewReturnType7
testNewReturnType8
testNewReturnType10
testNewReturnType11
testNewReturnType12
testNewAndInitNoReturn
testOverloadedNewAndInitNoReturn
testNamedTupleNew

# __init_subclass__
testOverride__init_subclass__WithDifferentSignature
# "The return type of "__init_subclass__" must be None"
testInitSubclassWithReturnValueType
testInitSubclassWithAnyReturnValueType
testDecoratedInitSubclassWithAnyReturnValueType
testOverloadedInitSubclassWithAnyReturnValueType
testInitSubclassWrongType
testInitSubclassTooFewArgs
testInitSubclassTooFewArgs2
testInitSubclassOK
testInitSubclassWithMetaclassOK
testInitSubclassWithCustomMetaclassOK
testInitSubclassWithImports
testInitSubclassWithImportsOK
testInitSubclassUnannotated
testInitSubclassUnannotatedMulti
testTooManyArgsForObject

# __getattribute__
testGetattribute
testDecoratedGetAttribute
testGetattributeSignature

# __getattr__
testGetattr
testDecoratedGetattr
testGetattrWithCall
testGetattrSignature
testIterableUnpackingWithGetAttr

# __setattr__
testSetattr
testDecoratedSetattr
testSetattrSignature
testGetattrAndSetattr

# "The return type of "__init__" must be None"
testConstructorWithReturnValueType
testConstructorWithAnyReturnValueType
testDecoratedConstructorWithAnyReturnValueType
testOverloadedConstructorWithAnyReturnValueType

# "Accessing "__init__" on an instance is unsound, since instance.__init__ could be from an incompatible subclass"
testAccessingInit

# Decorated constructors
testDecoratedConstructors
# "Unsupported decorated constructor type"
testDecoratedConstructorsBad

# "Cannot assign to a method"
testAssignToMethodViaInstance
testAssignToMethodViaClass
testAssignClassMethodOnClass
testAssignClassMethodOnInstance
testAssignStaticMethodOnInstance

# "Cannot assign to a type"
testAssignToNestedClassViaClass

# Invalid signature "Callable[[B], A]"
testReverseOperatorMethodInvalid

# Unsupported class scoped import
testClassScopeImports
testClassScopeImportModule
testClassScopeImportAlias
testClassScopeImportModuleStar
testClassScopeImportFunctionNested
testClassScopeImportUndefined
testClassScopeImportWithFollowImports
testClassScopeImportVarious
testClassScopeImportWithError
testClassScopeImportWithWrapperAndError
testImportInClassBody

# Unpacking a string is disallowed
testStringDisallowedUnpacking
# List unpacking
testMultipleAssignmentWithLists
testMultipleAssignmentWithListsInInitialization
testMultipleAssignmentWithListAndIndexing
testMultipleAssignmentAndGenericSubtyping
testInferringLvarTypesInNestedListAssignment
testInferringMultipleLvarDefinitionWithListRvalue
testInferMultipleLocalVariableTypesWithArrayRvalueAndNesting
testUnpackInExpression1-only_when_nocache
testNestedListAssignment
testNestedListAssignmentToTuple
testListAssignmentFromTuple
testListWithStarExpr
# list[<nothing>] against *args or never
testOverloadVarargsSelection

# List inference unions are special (list meets)
testListLiteralWithFunctionsErasesNames
testListLiteralWithSimilarFunctionsErasesName
testListLiteralWithNameOnlyArgsDoesNotEraseNames
testLiteralMeets
testLiteralMeetsWithStrictOptional
testInferredTypeIsObjectMismatch
testNestedListExpressions
testLiteralInferredInListContext
testGenericJoinCovariant
testGenericJoinContravariant
testGenericJoinRecursiveTypes
testGenericJoinRecursiveInvariant
testGenericJoinNestedInvariantAny
testTypeEquivalentTypeAny2
testExtremeForwardReferencing

# union creation / vs. object / vs. any from ternary
testConditionalExpressionUnionWithAny
# join callables
testOverloadedInIter
# join sub and super classes
testOverloadInferUnionWithDifferingLengths
testForLoopOverTupleAndSubtyping
# join tuple iter
testMutuallyRecursiveNamedTuplesJoin
testCallerTupleVarArgsAndGenericCalleeVarArg
# tuple joins
testFixedTupleJoinVarTuple
testFixedTupleJoinList
testEmptyTupleJoin
testTupleJoinIrregular
testTupleSubclassJoinIrregular
# namedtuple joins
testNamedTupleJoinNamedTuple
testNamedTupleJoinTuple

# __setitem__
testInferOptionalDictKeyValueTypes
testIndexingAsLvalue
testInplaceSetitem

# inplace operator methods
testInplaceOperatorMethods

# List/Set/Dict Inferring type of variable when initialized to an empty collection
testInferListInitialized*
testInferSetInitializedToEmpty
testInferSetInitializedToEmptyUsingDiscard
testInferSetInitializedToEmptyUsingUpdate
testInferDictInitialized*
testSpecialCaseEmptyListInitialization
testSpecialCaseEmptyListInitialization2
testInferListInitializedToEmptyAndAssigned
testInferOrderedDictInitializedToEmpty
testEmptyCollectionAssignedToVariableTwiceIncremental
testEmptyCollectionAssignedToVariableTwiceNoReadIncremental
testInferAttributeInitializedToEmpty*
testInferAttributeInitializedToNoneAndAssigned
testInferAttributeInitializedToNoneAndAssignedOtherMethod
testInferAttributeInitializedToNoneAndAssignedClassBody
testInferFromEmptyDictWhenUsingIn
testInferFromEmptyDictWhenUsingInSpecialCase
testInferListTypeFromInplaceAdd
testInferSetTypeFromInplaceOr
testConditionalExpressionWithEmptyListAndUnionWithAny
testConditionalExpressionWithEmptyIteableAndUnionWithAny
testLiteralFinalErasureInMutableDatastructures2
testInferNonOptionalListType
testInferNonOptionalDictType

# Type Var Value in func
testCheckGenericFunctionBodyWithTypeVarValues
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testTypeVarValuesAndNestedCalls
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testTypevarValuesSpecialCase1
testGenericTypeAliasesTypeVarConstraints
testWideOuterContextValuesOverlapping
testTypevarValuesWithOverloadedFunctionSpecialCase
testReferenceToDecoratedFunctionAndTypeVarValues
testLiteralAndGenericsRespectsValueRestriction
testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2
testTypingSelfWithValuesExpansion
testOverloadingInferUnionReturnWithTypevarsAndValueRestrictions

# Callable[..., int] | Callable[..., str] lambda inference may conflict
testOptionalLambdaInference

# - Signature of "f" incompatible with supertype "Parent"
testSelfTypeOverrideCompatibility
testSelfTypeOverrideCompatibilityTypeVar-xfail
testSubtypeOverloadWithOverlappingArgumentsButWrongReturnType
testSelfTypeOverrideCompatibilityGeneric
testInvalidOverrideArgumentCountWithImplicitSignature2
testInvalidOverrideArgumentCountWithImplicitSignature3
# Overloaded operator methods cannot have wider argument types in overrides
testOperatorMethodOverrideIntroducingOverloading
testOverloadedOperatorMethodOverrideWithNewItem
#     Overload variants must be defined in the same order as they are in "Parent"
testOverrideOverloadSwapped
testOverrideOverloadSwappedWithExtraVariants
testOverrideOverloadSwappedWithAdjustedVariants
testOverrideOverloadedMethodWithMoreSpecificArgumentTypes
testOverloadWithIncompatibleMethodOverrideAndImplementation
testOverloadFaultyClassMethodInheritance
testOverloadClassMethodMixingInheritance
testOverloadFaultyStaticMethodInheritance
testOverloadStaticMethodMixingInheritance
testOverloadStaticMethodImplementation
testOverloadedStaticMethodOnInstance
testUnsafeDunderOverlapInSubclass
# - Overload does not consistently use the "@classmethod" decorator on all function signatures
# - Overload does not consistently use the "@staticmethod" decorator on all function signatures
testOverloadWithInconsistentStaticMethods
# - Condition cannot be inferred, unable to merge overloads
testOverloadIf*
# Overloads are detected in name binder (imports can not be there)
testVeryBrokenOverload
testVeryBrokenOverload2
# overload rename in import (because of name binder issue)
testOverloadByAnyOtherName
# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2
# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload

# @final
testFinalAddFinalMethodOverrideFine
testFinalAddFinalMethodOverrideWithVarFine
testFinalAddFinalMethodOverrideOverloadFine
testFinalAddFinalPropertyWithVarFine
testFinalBodyReprocessedAndStillFinal
testFinalBodyReprocessedAndStillFinalOverloaded-only_when_cache
testFinalBodyReprocessedAndStillFinalOverloaded2-only_when_nocache
testTypingSelfAllowAliasUseInFinalClasses
testFinalClassWithAbstractAttributes
testFinalClassWithoutABCMeta
testFinalClassInheritedAbstractAttributes
# Final: Cannot assign to final name "x"
testNewAnalyzerFinalReassignModuleReexport
testNewAnalyzerFinalOverrideInSubclass
testFinalAddFinalVarAssignFine
testFinalAddFinalVarOverrideFine
testNewAnalyzerFinalReassignModuleVar
testLiteralFinalMismatchCausesError

# Conditional definitions
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionalFuncDefer
testNewAnalyzerConditionallyDefineFuncOverVar
testRedefineFunctionDefinedAsVariableInitializedToNone
testRedefineNestedFunctionDefinedAsVariableInitializedToNone
testConditionalFunctionDefinitionUsingDecorator2
testConditionalFunctionDefinitionUnreachable

# All conditional function variants must have identical signatures
testIncompatibleConditionalFunctionDefinition
testIncompatibleConditionalFunctionDefinition2
testIncompatibleConditionalFunctionDefinition3
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition1
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition2
testIncompatibleConditionalMethodDefinition

# TYPE_CHECKING
testIfTypeCheckingUnreachableClass

# if sys.version
testNewAnalyzerVersionCheck
testNewAnalyzerVersionCheck2
testPromoteMemoryviewToBytes
# NamedTuple magic attribute __match_args__ in py >= 3.10
testNamedTupleHasMatchArgs

# callable()
testFineGrainedCallable

# isinstance
testLiteralErrorsWithIsInstanceAndIsSubclass
# isinstance narrowing
testUnionGenericWithBoundedVariable
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues2
testTypeCheckOverloadImplementationTypeVarWithValueRestriction
testTypeCheckOverloadImplementationTypeVarDifferingUsage1
testIntersectionUsingPromotion1
testIntersectionUsingPromotion2
testIntersectionUsingPromotion3
testIntersectionUsingPromotion4
testIntersectionUsingPromotion5
testIntersectionUsingPromotion6
testIntersectionUsingPromotion7
testIntersectionUsingPromotion8
testCorrectIsinstanceWithForwardUnion
testNewTypeWithIsInstanceAndIsSubclass
testNarrowingDownNamedTupleUnion
testRecursiveAliasViaNamedTuple
testSimpleIsinstance
testSimpleIsinstance2
testSimpleIsinstance3
testMultipleIsinstanceTests
testMultipleIsinstanceTests2
testIsinstanceAndElif
testIsinstanceAndAnyType
testIsinstanceAndGenericType
testTupleMeetTupleAny
testTupleMeetTupleAnyComplex
testTupleMeetTupleAnyAfter
testNamedTupleSubclassMulti
testNarrowSelfType
# issubclass narrowing
testIsInstanceTypeIsSubclass
testIsInstanceTypeTypeVar
testIsInstanceTypeSubclass
testIsSubClassNarrowDownTypesOfTypeVariables
# isinstance & union
testUnion1
testUnion2
testUnion3
testUnionAnyIsInstance
testNestedUnionsProcessedCorrectly
testGenericTypeAliasesUnion
testOverloadsIgnorePromotions
testParamSpecLiteralJoin
testUnionOrSyntaxInIsinstance
testUnionOrSyntaxInIsinstanceNotSupported
# --enable-recursive-aliases & isinstance
testRecursiveAliasBasic
testRecursiveAliasesRestrictions
testRecursiveAliasesRestrictions2
testRecursiveAliasBasicGenericInference
testRecursiveAliasNewStyleSupported
#  --enable-recursive-aliases & is not None
testTupleTypeUpdateNonRecursiveToRecursiveFine
testTypeAliasUpdateNonRecursiveToRecursiveFine
# narrowing if with literals
testConditionalBoolLiteralUnionNarrowing
# narrowing optional with if
testOptionalTypeNarrowedByGenericCall
testOptionalTypeNarrowedByGenericCall2
testOptionalTypeNarrowedByGenericCall3
testOptionalTypeNarrowedByGenericCall5
testOptionalTypeNarrowedInBooleanStatement
testIsinstanceCases
testIfCases
testIfNotCases
testIsNotNoneCases
testIsNoneCases
testAnyCanBeNone
testOrCases
testAndCases
testOptionalAssignAny1
testOptionalAssignAny2
testOptionalAssignAny3
testInferEqualsNotOptional
testInferEqualsNotOptionalWithUnion
testInferEqualsNotOptionalWithOverlap
testInferEqualsStillOptionalWithNoOverlap
testInferEqualsNotOptionalWithMultipleArgs
testTernaryWithNone
testNoneListTernary
testIsinstanceAndOptionalAndAnyBase
testGenericTypeAliasesOptional
testCastConfusion
testBasicRecursiveNamedTuple
testBasicRecursiveNamedTupleSpecial
testBasicRecursiveNamedTupleClass
testNamedTupleUpdateNonRecursiveToRecursiveFine
testTupleOverlapDifferentTuples
# narrowing with or/and
testRestrictedTypeAnd
testRestrictedTypeOr
testRestrictedBoolAndOrWithGenerics
testOptionalTypeOrTypeBothOptional
testOptionalTypeOrTypeComplexUnion
testOptionalTypeOrTypeNoTriggerPlain
testOptionalTypeOrTypeNoTriggerTypeVar
testInvalidBooleanBranchIgnored
testOptionalTypeOrTypeTypeVar
testNoneOrStringIsString
testNoneOrTypeVarIsTypeVar
testNoneAndStringIsNone
testInferInWithErasedTypes
testUnionTruthinessTracking
testRegression11705_Strict
testRegression11705_NoStrict
testBinaryOperationsWithDynamicLeftOperand
testBinaryOperationsWithDynamicAsRightOperand
# or/and
testBooleanAndOr
testNonBooleanOr
# narrowing with assert
testNarrowOptionalOutsideLambda
testNarrowOptionalOutsideLambdaWithDeferred
testIsInstanceTypeVsUnionOfType
testIsInstanceTypeByAssert
testIsInstanceTypeVsMetaclass
# General assert
testFastParseMalformedAssert
testFastParseAssertMessage
# narrowing assignments
testNarrowingFromObjectToOptional
testDynamicWithMemberAccess
testTupleCompatibleWithSequence
testTupleInstanceCompatibleWithIterable
testTupleTypeCompatibleWithIterable
testAugmentedAssignmentIntFloat
testAugmentedAssignmentIntFloatMember
testAugmentedAssignmentIntFloatDict

# None late binding, because it's None (x = None; x = 3)
*PartialType*
testAssigningAnyStrToNone
testLocalVariablePartiallyInitializedToNone
testLocalVariablePartiallyTwiceInitializedToNone
testGvarPartiallyInitializedToNone
testPartiallyInitializedToNone*
testPartiallyInitializedVariableDoesNotEscapeScope2
testAttributePartiallyInitializedToNoneWithMissingAnnotation
testGlobalInitializedToNoneSetFromFunction
testGlobalInitializedToNoneSetFromMethod
testNoCrashOnPartialVariable
testNoCrashOnPartialVariable3
testInferOptionalType
testInferOptionalTypeLocallyBound
testInferOptionalAnyType
testInferOptionalTypeFromOptional
testDeferredAndOptionalInferenceSpecialCase
testInheritedAttributeNoStrictOptional
testIncompatibleInheritedAttributeNoStrictOptional
testInheritedAttributeStrictOptional
testIgnoreTypeInferenceError2

# Weird Name binder type definitions (overwritten?)
testLiteralBinderLastValueErased
# weird narrowing
testInferredTypeIsSimpleNestedList
testInferredTypeIsSimpleNestedIterable
testInferredTypeIsSimpleNestedListLoop
testInferredTypeIsSimpleNestedIterableLoop
testNarrowingDownFromPromoteTargetType
testNarrowingDownFromPromoteTargetType2
testNewAnalyzerBuiltinAliasesFixed
testAssignAnyToUnionWithAny
testOverloadsAndNoReturnNarrowTypeNoStrictOptional1
testOverloadsAndNoReturnNarrowTypeWithStrictOptional1
testOverloadsAndNoReturnNarrowTypeNoStrictOptional2
testOverloadsAndNoReturnNarrowTypeWithStrictOptional2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional3
testOverloadsAndNoReturnNarrowTypeWithStrictOptional3

# Function local self attribute name binding
testOptionalDescriptorsBinder
testUnionDescriptorsBinder
testSubclassDescriptorsBinder
# Use x instead of self as first argument (probably name binding issue)
testNonStandardNameForSelfAndInit

# All conditional function variants must have identical signatures (flow analysis)
testUnionOrderEquivalence

# flow graph
testAssignAndConditionalImport
testAssignAndConditionalStarImport
testRedefineImportedFunctionViaImport
testImportedVariableViaImport

# Multi definition ifs
testNewAnalyzerFirstAliasTargetWins
testNewAnalyzerFirstVarDefinitionWins
testOptionalBackwards1
testOptionalBackwards2
testOptionalBackwards3
testOptionalBackwards4

# Multiple arguments missing
testMissingPositionalArguments

# Intersection types
testIsInstanceAdHocIntersectionFineGrainedIncrementalNoChange
testIsInstanceAdHocIntersectionFineGrainedIncrementalIsInstanceChange
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnderlyingObjChang
testIsInstanceAdHocIntersectionFineGrainedIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnreachaableToIntersection

# "Name "C" is used before definition"
testNewAnalyzerNewTypeForwardClassAliasReversed

# Import Redefinition
testRedefineTypeViaImport
# Redefinition (Name "X" already defined on line X)
testGlobalVarRedefinition
testLocalVarRedefinition
testClassVarRedefinition
testMultipleClassDefinitions
testMultipleMixedDefinitions
testMultipleMethodDefinition
testMultipleNestedFunctionDef
testRedefineVariableAsTypevar
testRedefineTypevar
testRedefineTypevar2
testRedefineTypevar3
testRedefineTypevar4
testImportTwoModulesWithSameNameInFunction
testImportTwoModulesWithSameNameInGlobalContext
testTypeRedeclarationNoSpuriousWarnings
testDuplicateDef*
testTypeVarClassDup
testAliasDup
testImportFuncDup
testIgnoredImportDup
testNewAnalyzerRedefinitionAndDeferral*
testNewAnalyzerImportStarForwardRef*
testNewAnalyzerImportOverExistingInCycle
testNewAnalyzerImportOverExistingInCycleStar1
testNewAnalyzerImportOverExistingInCycleStar2
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionallyDefineFuncOverClass
testNewAnalyzerMissingImportErrors
testNewAnalyzerMissingImportErrorsRedefinition
testNewAnalyzerDuplicateTypeVar
testNewAnalyzerDuplicateTypeVarImportCycle
testNewAnalyzerDuplicateTypeVarImportCycleWithAliases
testNewAnalyzerRedefineAsClass
testNewAnalyzerOverrideClassWithTypeAlias
testNewAnalyzerIdentityAssignment*
testProhibitReassigningAliases
testProhibitReassigningSubscriptedAliases
testProhibitReassigningGenericAliases
testUnknownModuleRedefinition
testStarImportOverlappingMismatch
testStarImportOverridingLocalImports
testRedefineFunctionViaImport
testDifferentImportSameNameTwice
testNewAnalyzerRedefineAsOverload
testImportOnTopOfAlias1
testImportOnTopOfAlias2
testUnconditionalRedefinitionOfConditionalFunction
testUnconditionalRedefinitionOfConditionalMethod
testRedefineFunction2
testMissingOverloadDecorator
testDecoratedRedefinitionIsNotOverload
testMultipleClassDefinition
testMemberRedefinition
testMemberRedefinitionDefinedInClass
testDecorateOverloadedFunction
# redefinition overload
testRedefinedOverloadedFunction
testFakeOverloadCrash
testFakeOverloadCrash2
testOverloadNotImportedNoCrash
testSingleOverload2
testCustomRedefinitionDecorator
# Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation
testAliasesInClassBodyNormalVsSubscripted
# Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2
# Incompatible redefinition (redefinition with type "Callable[[Any], Any]", original type "Callable[[], Any]")
testRedefineFunctionDefinedAsVariableWithInvalidSignature
testRedefinedFunctionInTryWithElse
# Incompatible redefinition
testRedefineFunctionDefinedAsVariableInitializedToEmptyList
# NewType Redefinition
testNewAnalyzerNewTypeRedefinition
testNewTypeRedefiningVariablesFails

# Invalid type comment or annotation, because of weird annotations
testFastParseTypeCommentSyntaxError
testFastParseFunctionAnnotationSyntaxError
testFastParseFunctionAnnotationSyntaxErrorSpaces
testFastParseInvalidFunctionAnnotation

# syntax errors
testPreferPackageOverFile
testPreferPackageOverFile2
testTrailingCommaInIfParsing
testDictWithStarExpr
testNotPreferPackageOverFileCase
testIgnoreImportBadModule
testIgnoreImportStarFromBadModule
testFastParseSyntaxError

# Yield
testYieldOutsideFunction
testYieldFrom
testYieldExpression
testYieldExpressionWithNone
testYieldFromIteratorHasNoValue
testYieldFromGeneratorHasValue
testYieldFromTupleExpression
testNoCrashOnLambdaGenerator
testReturnInGenerator
testSimpleYield
testTypeInferenceContextAndYield
testYieldWithNoValueWhenValueRequired
testGeneratorUnion
# ""yield" outside function"
testCannotIgnoreBlockingError
# yield from
testSimpleYieldFromWithIterator
testYieldFromInFunctionReturningFunction
testYieldFromNotIterableReturnType
testYieldFromNotAppliedIterator
testYieldFromCheckIncompatibleTypesTwoIterables
testYieldFromNotAppliedToNothing
testYieldFromAndYieldTogether
testYieldFromAny
testYieldFromGenericCall
testYieldFromTupleStatement

# "The return type of a generator should be "Generator" or one of its supertypes"
testYieldInFunctionReturningFunction
testWithInvalidInstanceReturnType

# async/await
testAwaitCoroutine
testAwaitDefaultContext
testAwaitAnyContext
testAwaitExplicitContext
testAwaitGeneratorError
testAwaitIteratorError
testAwaitArgumentError
testAwaitResultError
testAwaitReturnError
testYieldFromNoAwaitable
testAwaitableSubclass
testAwaitOverloadSpecialCase
testUnusedAwaitable
testAwaitMissingNote
testAsyncGeneratorExpressionAwait
testAwaitAndAsyncDef-only_when_nocache
testAwaitAnd__await__-only_when_nocache
testAsyncWith2-only_when_nocache
test__aiter__and__anext__
testNewNamedTupleWithMethods

# del statement
testIndexedDel
testDelGlobalName
testDelLocalName
testDelMultipleThings
testDelMultipleThingsInvalid
testDelStmtWithIndex
testDelStmtWithAttribute
testDelStatementWithTuple
testDelStmtWithTypeInfo
testDelStatementWithAssignmentSimple
testDelStatementWithAssignmentTuple
testDelStatementWithAssignmentList
testDelStatementWithAssignmentClass
testDelStatementWithConditions

# Except with multiple exceptions in parentheses
testExceptWithMultipleTypes
testExceptWithMultipleTypes2
testExceptWithMultipleTypes3
testExceptWithMultipleTypes4
testExceptWithAnyTypes
# "Trying to read deleted variable "e"
testReuseTryExceptionVariable
testReuseDefinedTryExceptionVariable

# With statement
testWithStmtAndInvalidExit
testWithStmtAndMissingExit
testWithStmtAndInvalidEnter
testWithStmtAndMissingEnter
testWithStmtAndMultipleExprs
testWithStmtAndResult
testWithStmtAndMultipleResults
testWithStmtAndComplexTarget
testWithStmtTypeComment
testWithStmtTupleTypeComment
testWithStmtComplexTypeComment
testWithStmtBoolExitReturnWithResultFalse
testWithStmtScopeBasics
testWithStmtScopeAndImport2
testWithStmtScopeNestedWith1
testWithStmtScopeNestedWith2
testWithStmtScopeInnerAndOuterScopes
testWithStmtScopeMultipleContextManagers
testWithStmtScopeMultipleAssignment
testWithStmtScopeComplexAssignments
testWithStmtScopeAndClass
testWithStmtScopeInnerScopeReference
testWithStmtScopeAndLambda

# match statement
testValuePattern
testCapturePattern
testCapturePatternOutliving
testNestedCapturePatterns
testMappingPatternRest
testAsPattern
testGuard
testCapturePatternInGuard
testAsPatternInGuard
testMatchUndefinedSubject
testMatchUndefinedValuePattern
testMatchUndefinedClassPattern
testNoneBindingWildcardPattern
testNoneBindingStarredWildcardPattern

# "Cannot determine type of"
testThreePassesRequired
testAccessGlobalVarBeforeItsTypeIsAvailable
testAccessDataAttributeBeforeItsTypeIsAvailable
testMultipassAndTopLevelVariable
testMultipassAndCircularDependency
testForwardReferenceToDecoratedClassMethod
testAccessingClassAttributeWithTypeInferenceIssue
testClassObjectsNotUnpackableWithoutIterableMetaclass
# "Cannot determine type of "X" in base class"
testCannotDetermineTypeInMultipleInheritance

# {**kwargs}
testSubtypingMappingUnpacking1
testSubtypingMappingUnpacking2
testSubtypingMappingUnpacking3
testNotDirectIterableAndMappingSubtyping
testUnpackInExpression3-only_when_nocache

# "???" does not return a value / Function does not return a value
testCallingVarArgsFunction
testFunctionTypeCompatibilityWithOtherTypes
testLvarInitializedToVoid
testForStatementInferenceWithVoid

# "Cannot call function of unknown type"
testUnknownFunctionNotCallable

# "Return value expected"
testReturnWithoutAValue
testEmptyReturnInGenerator

# No return value expected
testNonEmptyReturnInNoneTypedGenerator

# Implicit any param
testKwargsArgumentInFunctionBodyWithImplicitAny

# Weird Decorator Cases
testOverloadWithErrorDecorator
testBoundOnDecorator
testGenericClassPropertyBound
testOverloadDeferredNode
# Class decorator
testDecoratingClassesThatUseParamSpec
testClassDecoratorIsTypeChecked
testClassDecoratorIncorrect

# "Decorators on top of @property are not supported"
testDecoratedProperty

# Function Not checked, missing return annotations (--check-untyped-defs)
testPositionalAndKeywordForSameArg
testTypeCheckOverloadWithImplementationError
testCheckUntypedDefsSelf2
testCheckUntypedDefsSelf3
testLambdaInheritsCheckedContextFromFuncForced

# function type mismatch when untyped
testSubtypingFunctionsImplicitNames

# Global
testAssignToFuncDefViaGlobalDecl2
testTypeOfGlobalUsed
testGlobalWithoutInitialization

# Nonlocal
testInvalidNonlocalDecl
testNonlocalDeclNotMatchingGlobal
testNonlocalDeclConflictingWithParameter
testNonlocalDeclOutsideFunction
testGlobalAndNonlocalDecl
testNonlocalAndGlobalDecl
testNewAnalyzerRedefinedNonlocal
testTypeOfOuterMostNonlocalUsed
testTypeOfNonlocalUsed

# slice type checking
testNonIntSliceBounds

# __init__ None needed
testInitReturnTypeError

# Need type annotation for "X"
testNewAnalyzerLessErrorsNeedAnnotation
testNewAnalyzerLessErrorsNeedAnnotationNested
testErrorInTypeCheckSecondPassThroughPropagation
testGenericFunctionOnReturnTypeOnly
testUnderspecifiedInferenceResult
testNoCrashOnPartialMember
testDontMarkUnreachableAfterInferenceUninhabited
testDontMarkUnreachableAfterInferenceUninhabited2
testDontMarkUnreachableAfterInferenceUninhabited3
testNeedAnnotationForCallable
testPartialDefaultDict*
testInferenceOfFor1
testInferenceOfFor2
testInferenceOfFor3
testInferLocalVariableTypeWithUnderspecifiedGenericType
testLocalVariableInferenceFromEmptyList
testNoPartialInSupertypeAsContext
testSuggestPep604AnnotationForPartialNone
testSelfTypeRestrictedMethodOverloadInitFallBacks
testOverridePartialAttributeWithMethod
testInheritanceAndAttributeAssignment
testAssignmentToAttributeInMultipleMethods
testAccessingClassAttributeWithTypeInferenceIssue2
testTypeAnnotationNeededMultipleAssignment
testAssignmentToStarMissingAnnotation
testForLoopOverEmptyTuple
testTupleWithoutContext

# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames

# "Perhaps you need a type annotation for "x"? Suggestion: "List[str | int]""
testInferredTypeSubTypeOfReturnType

# Module __getattr__
testNewAnalyzerModuleGetattrSerialize_incremental
testModuleLevelGetattr*
testModuleGetattr*
testModuleGetAttr*
testGetAttrImportAnnotation
testGetAttrImportBaseClass
testGetAttrDescriptor

# __get__/__set__ not callable
testDescriptorUncallableDunderGet
testDescriptorUncallableDunderSet

# attrs
testAttrs*

# Special case for assignment to '_'
testUnusedTargetLocal
testUnusedTargetNotClass
testUnusedTargetNotClass2
testUnusedTargetTupleUnpacking
testUnusedTargetMultipleTargets
testUnusedTargetNotImport
testUnderscoreClass
testUnusedTargetForLoop
testUnusedTargetWithClause
testUnusedTargetNotExceptClause

# weird files
testScriptsAreNotModules

# __doc__ definitions
testNewNamedTupleDocString

# Formatting qualified module names
testMetaclassPlaceholderNode
testSubmoduleMixingImportFromAndImport2
testErrorFromGoogleCloud
testStubPackageSubModule
testReExportChildStubs3
testImportFromReExportInCycleUsingRelativeImport1
testImportReExportInCycleUsingRelativeImport2
testModuleLookupWeird
testModuleLookupWeird2
testModuleLookupWeird3
testModuleLookupWeird5
testModuleLookupWeird6
# Qualified nested class name
testNewAnalyzerNamedTupleClassNestedMethod
testNewAnalyzerNamedTupleCallNested
testNewAnalyzerNamedTupleCallNestedMethod

# Formatting class in reveal_type (stashed in 860494e, see also https://github.com/python/mypy/issues/13062)
testNewAnalyzerShadowOuterDefinitionBasedOnOrderTwoPasses
testNewAnalyzerPlaceholderFromOuterScope
testAliasInImportCycle3
testNewAnalyzerTypeVarForwardReferenceErrors

# Aliases in Mypy define generics as X = Foo as Foo[Any, Any]
testAliasToTupleAndCallable

# Formatting Module as types ("ModuleType" instead of Module)
testInvalidOperationsOnModules
testConditionalImportAndAssignInvalidToModule
testModuleAliasRepeatedWithAnnotation

# qualified name for NewType for different module
testNewTypeInMultipleFiles
# NewType formatting instead of internal type
testNewTypeDependencies3

# tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5

# parser recovery in type comments / types in string literals
testInvalidStrLiteralSpaces
testInvalidStrLiteralStrayBrace
testInvalidMultilineLiteralType
testLiteralInvalidString

# Syntax error in type annotation
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2
# Suggestion: Use tuple[()] instead of () for an empty tuple, or None for a function without a return value
testReturnEmptyTuple

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same error twice
testOperatorAssignmentWithIndexLvalue1

# Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4
# "Too many values to unpack (2 expected, 3 provided)"
testInferringLvarTypesInMultiDefWithInvalidTuple
testMultipleAssignmentWithDynamic
testMultipleAssignmentWithInvalidNumberOfValues
testInitializationWithMultipleValues
testNestedTupleAssignment2
# "Unsupported target for indexed assignment ("tuple[A, B]")"
testAssigningToTupleItems
# star unpacking for tuples
testAssignmentToStarAnnotation
testAssignmentToStarCount1
testAssignmentToStarCount2
testAssignmentToStarFromAny
testAssignmentToComplexStar
testAssignmentToStarFromTupleType
# star input for tuple
testTupleWithStarExpr2
testTupleWithStarExpr3
testTupleWithStarExpr
# "Can use starred expression only as assignment target"
testUnpackSyntaxError
# union tuple index
testUnionOfTupleIndex
testUnionOfTupleIndexMixed
# tuple concatenation
testFixedLengthTupleConcatenation
# tuple multiplication
testMultiplyTupleByIntegerLiteral
testMultiplyTupleByIntegerLiteralReverse
# "Expression tuple item 8 has type "str"; "int" expected;"
testAssigningWithLongTupleInitializer
# Tuple operator in
testTupleMethods
# tuple maybe ok error messages?
testTupleWithUndersizedContext
testTupleWithOversizedContext
testAssignEmptyBogus

# EllipsisType
testUnionWithEllipsis
# Ellipsis / raise NotimplementedError / pass are considered stubs in normal files 
testEllipsisDefaultArgValueInNonStub
testEllipsisDefaultArgValueInNonStubsMethods

# NotImplemented
testOperatorMethodAgainstSameType

# The type "Type[type]" is not generic and not indexable
testTypeApplicationCrash

# "bool" is not a valid base class
testTestExtendPrimitives

# "By default the bodies of untyped functions are not checked, consider using --check-untyped-defs"
testContextForAttributeDeclaredInInit
testDeclareAttributeTypeInInit
testAccessAttributeDeclaredInInitBeforeDeclaration
testNoteUncheckedAnnotation

# Probably fixed eventually by updating mypy or typeshed
testDecoratorTypeAfterReprocessing

# type ignore on statement, but not exact line
testIgnoreImportFromErrorMultiline
# type: ignore on type computation of too many type arguments
testIgnoreTooManyTypeArguments
# type ignore whole module
testIgnoreWholeModule2
testIgnoreWholeModule3
testIgnoreWholeModule4
testIgnoreWholeModule5
testDontIgnoreWholeModule2
testDontIgnoreWholeModule3
# Unused "type: ignore" comment
testIgnoreWholeModule1
# type: ignore[...]
testJoinWithAnyFallback

# Very weird annotation resolution order
testNewAnalyzerAnnotationConflictsWithAttributeSinglePass
testNewAnalyzerAnnotationConflictsWithAttributeTwoPasses
testNewAnalyzerNameConflictsAndMultiLineDefinition

# pyproject.toml
testMultipleModulesInOverridePyProjectTOML
testIgnoreErrorFromMissingStubs1
testIgnoreErrorFromMissingStubs2
testCaseInsensitivityDirPyProjectTOML
testPreferPackageOverFileCasePyProjectTOML
testClassicPackageInsideNamespacePackageCasePyProjectTOML

# mypy.ini
testRefreshIgnoreErrors1
testRefreshIgnoreErrors2
testRefreshOptions
testCaseInsensitivityDir
testPreferPackageOverFileCase
testClassicPackageInsideNamespacePackageCase

# strict optional with config file
testNewAnalyzerTypeArgBoundCheckWithStrictOptional
testNewAnalyzerTypeArgBoundCheckWithStrictOptionalPyProjectTOML
testPerFileStrictOptionalModule
testPerFileStrictOptionalModuleOnly
testPerFileStrictOptionalFunction
testPerFileStrictOptionalMethod
testStrictOptionalCovarianceCrossModule

# mypy extensions
testFlexibleAlias1
testFlexibleAlias2
testFlexibleAlias3

# enable-error-code="redundant-self"
# "Redundant Self annotation on method first argument"
testTypingSelfRedundantWarning

# --strict-equality strict equality
testStrictEqualityEq
testStrictEqualityIs
testStrictEqualityContains
testStrictEqualityUnions
testStrictEqualityNoPromotePy3
testStrictEqualityEqNoOptionalOverlap
testCustomEqCheckStrictEquality
testCustomEqCheckStrictEqualityTuple
testCustomEqCheckStrictEqualityMeta
testCustomContainsCheckStrictEquality
testStrictEqualityTypeVsCallable
testStrictEqualityMetaclass
testStrictEqualityWithALiteral
testStrictEqualityWithALiteralNewType
testStrictEqualityWithFixedLengthTupleInCheck
testStrictEqualityBytesSpecialUnion

# --show-column-numbers
testForwardInstanceWithBound

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext

# --allow-untyped-globals
testPermissiveAttributeOverride1

# --allow-redefinition
testStarLvalues
testRenameGlobalVariable
testNoRenameGlobalVariable
testCannotRenameExternalVarWithinClass

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testUnlimitedStubErrorVolume

# --disallow-any-generics
testErrorReportingNewAnalyzer

# --disallow-untyped-defs
testIgnoreInsideFunctionDoesntAffectWhole

# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --pretty
testReprocessMethodShowSource
testGenericTypeAliasesWithNestedArgs
testPrettyMessageSorting

# syntax not yet supported
testBreakOutsideLoop
testContinueOutsideLoop
testInvalidGlobalDecl
testAssignToTypeDef

# parser shit
testInvalidLvalues*
testTwoStarExpressions
testTwoStarExpressionsInForStmt
testTwoStarExpressionsInGeneratorExpr
testStarExpressionRhs
testStarExpressionInExp
testInvalidDel1
testInvalidDel2
testInvalidDel3
testInvalidTypeDeclaration
testIndexedAssignmentWithTypeDeclaration
testInvalidLvalueWithExplicitType
testInvalidLvalueWithExplicitType3
testInvalidWithTarget
testInvalidTypeAnnotation2

# "Not all union combinations were tried because there are too many unions"
testTooManyUnionsException

# - (with type vars) Overloaded function signatures 2 and 3 overlap with incompatible return types
#testOverloadMultipleVarargDefinitionComplex
#testOverloadPartialOverlapWithUnrestrictedTypeVar
#testOverloadPartialOverlapWithUnrestrictedTypeVarNested
#testOverloadedPartiallyOverlappingTypeVarsAndUnion
# Overlapping general
#testManyUnionsInOverload
#testOverloadInferUnionReturnFunctionsWithKwargs
#testOverloadWithOverlappingItemsAndAnyArgument5
#testIntersectionTypesAndVarArgs
#testLiteralInferredInOverloadContextWithTypevars
#testLiteralSubtypeOverlap
#testOverloadsAndNoneWithoutStrictOptional
#testOverloadsAndNoneWithStrictOptional
#testTypeTypeOverlapsWithObjectAndType
#testTypeOverlapsWithObject
#testAccessingGenericDescriptorFromInferredClass
#testAccessingGenericDescriptorFromClass
#testOverloadWithNonGenericDescriptorLookalike
#testOverloadWithGenericDescriptor
#testUnpackIterableClassWithOverloadedIter2

# `for ... in` type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2
testForStatementTypeComments
testForStatementMultipleTypeComments

# Won't support for now: "t" is a type variable and only valid in type context
testExpressionRefersToTypeVariable

# Won't support for now: "Use `from typing_extensions import _FutureFeatureFixture` instead"
testTypingExtensionsSuggestion

# Probably won't support: typing._promote
testListWithDucktypeCompatibility
testListWithDucktypeCompatibilityAndTransitivity
testSimpleDucktypeDecorator
testDucktypeTransitivityDecorator

# Probably won't support Type Var formatting
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName

# Probably won't support: Type comments for params
testFastParsePerArgumentAnnotations
testFastParsePerArgumentAnnotationsWithReturn
testFastParsePerArgumentAnnotationsWithAnnotatedBareStar
testFastParsePerArgumentAnnotationsWithReturnAndBareStar

# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments
testNestedFunctionInMethodWithTooFewArgumentsInTypeComment
testDeepNestedFunctionWithTooFewArgumentsInTypeComment
testDeepNestedMethodInTypeComment
testEllipsisWithArbitraryArgsOnBareFunctionWithKwargs
testEllipsisWithArbitraryArgsOnBareFunctionWithVarargs
testEllipsisWithSomethingAfterItFails
testEllipsisWithSomethingBeforeItFails
testMethodDefaultArgumentsAndSignatureAsComment
testDefaultArgumentsAndSignatureAsComment
testLiteralInsideOtherTypesTypeCommentsPython3
testLiteralInvalidTypeComment
testLiteralInvalidTypeComment2
testInferOptionalFromDefaultNoneComment
testNoInferOptionalFromDefaultNoneComment
testCheckUntypedDefsSelf1
testOperatorDoubleUnionDivision
testFasterParseTooManyArgumentsAnnotation
testFasterParseTooFewArgumentsAnnotation
testFastParserShowsMultipleErrors
testFastParserConsistentFunctionTypes

# --scripts-are-modules
testScriptsAreModules

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testInlineConfigFineGrained1
testInlineConfigFineGrained2

# Won't support: __eq__ called directly with a keyword argument (which is actually legal)
testMagicMethodPositionalOnlyArg
testMagicMethodPositionalOnlyArgFastparse

# Won't support: reveal_locals
testRevealLocalsFunction
testRevealLocalsOnClassVars
testRevealLocals

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Union Pipe "|" not allowed in 3.9
testUnionOrSyntaxWithinRuntimeContextNotAllowed
testUnionOrSyntaxWithinRuntimeContextNotAllowed2
testUnionOrSyntaxMissingFutureImport

# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support ever: python 2
testMypyPathAndPython2Dir

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testNoSubscriptionOfBuiltinAliases

# Won't support --disable-recursive-aliases
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerAliasToNotReadyDirectBaseFunction
testNewAnalyzerNewTypeForwardClassAliasDirect
testNewAnalyzerForwardTypeAliasInBase
testRecursiveForwardReferenceInUnion
testRecursiveAliasesErrors1
testRecursiveAliasesErrors2
testJSONAliasApproximation
testCrashOnSelfRecursiveNamedTupleVar
testSimpleSelfReferentialNamedTuple
testSelfRefNT1
testSelfRefNT2
testSelfRefNT3
testSelfRefNT4
testSelfRefNT5
testRecursiveNamedTupleInBases
testSubclassOfRecursiveNamedTuple

# Won't support --force-union-syntax
testOptionalErrorSyntax
testLiteralUnionErrorSyntax
testLiteralOptionalErrorSyntax

# Mypy test case issues
# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred

# Not working in interpreter
# Recursive class inheritance
testNewAnalyzerAliasToNotReadyNestedClass

# "Recursive types are not allowed at function scope"
testNoRecursiveTuplesAtFunctionScope
testRecursiveBoundFunctionScopeNoCrash

# xfail
testOpWithInheritedFromAny-xfail
# Skips
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testOverloadInferringArgumentsUsingContext2-skip
testUnionTwoPassInference-skip
testLiteralErrorsWhenInvoked-skip
