# Next up
testCachedProperty

# 3.7 tests
testNamedTupleDefaults
testAsyncForOutsideCoroutine
testAsyncWithOutsideCoroutine
testAwaitMissingNote
testIncrementalWithDifferentKindsOfNestedTypesWithinMethod
testTypeAliasWithNewStyleUnionInStub
testNewAnalyzerModuleGetAttrInPython37
# 3.8 tests
testParamSpecConcatenateNamedArgs
testCallablesAsParameters
testPEP570Calls
testPEP570Unannotated
testWalrus
testWalrusConditionalTypeBinder
testWalrusConditionalTypeCheck
testWalrusConditionalTypeCheck2
testWalrusAssignmentAndConditionScopeForLiteral
testWalrusAssignmentAndConditionScopeForProperty
testWalrusAssignmentAndConditionScopeForFunction
testWalrusUsedBeforeDef
testOverloadWithPositionalOnlySelf
testOverloadPositionalOnlyErrorMessage
testOverloadPositionalOnlyErrorMessageAllTypes
testOverloadPositionalOnlyErrorMessageMultiplePosArgs
testOverloadPositionalOnlyErrorMessageMethod
testOverloadPositionalOnlyErrorMessageClassMethod
testUnpackWithDuplicateNamePositionalOnly
testPossiblyUndefinedWithAssignmentExpr

# "Property "f" defined in "A" is read-only"
testAssigningToReadOnlyProperty
testAssigningToInheritedReadOnlyProperty
testDynamicallyTypedProperty
testPropertyWithSetter
testPropertyWithDeleterButNoSetter
testReadOnlyAbstractProperty
testReadOnlyAbstractPropertyForwardRef
testReadWriteAbstractProperty
testDynamicallyTypedReadOnlyAbstractProperty
testDynamicallyTypedReadOnlyAbstractPropertyForwardRef
testDynamicallyTypedReadWriteAbstractProperty
testSerializeReadOnlyProperty
testSerializeReadWriteProperty
testNewAnalyzerProperty

# Self in bound method shouldn't probably be there
testFunctionAssignedAsCallback
testErrorSettingCallbackWithDifferentFutureType

# EnumMeta does not inherit from ABCMeta anymore: https://github.com/python/typeshed/pull/10577
testStrEnumCreation
testRegression12258

# --new-type-inference
testInferenceAgainstGenericCallable
testInferenceAgainstGenericCallableNoLeak
testInferenceAgainstGenericCallableChain
testInferenceAgainstGenericCallableGeneric
testInferenceAgainstGenericCallableGenericReverse
testInferenceAgainstGenericCallableGenericArg
testInferenceAgainstGenericCallableGenericChain
testInferenceAgainstGenericCallableGenericNonLinear
testInferenceAgainstGenericCurry
testInferenceAgainstGenericCallableGenericAlias
testInferenceAgainstGenericCallableGenericProtocol
testInferenceAgainstGenericSplitOrder
testInferenceAgainstGenericSplitOrderGeneric
testInferenceAgainstGenericCallableNewVariable
testInferenceAgainstGenericBoundsAndValues
testDefaultDict
testGenericInferenceWithDataclass
testGenericInferenceWithItertools

# super with Type[...]
testSuperWithAny
testSuperInClassMethod
testSuperClassGetItem
testInvalidFirstSuperArg
testWrongSuperOutsideMethodNoCrash
testSuperWithTypeObjects
testSuperWithTypeTypeAsSecondArgument
# "super() outside of a method is not supported"
testSuperOutsideMethodNoCrash
# "super() requires one or more positional arguments in enclosing function"
testSuperInMethodWithNoArguments
# How do we deal with super() and Self or self type vars?
testSuperSelfTypeInstanceMethod
testSuperSelfTypeClassMethod
testTypingSelfOnSuperTypeVarValues
testSelfTypeSuper
testMixinProtocolSuper
# Super in classmethod or __new__
testSuperWithNew
testSuperNew
testMetaclassAndSuper

# Any base class now matches everything for union simplification
testUnionSimplificationSpecialCases2

# "Invalid type argument value for "C""
testErrorCodeInvalidTypeArg

# raise with brackets and no parentheses
testRaiseClassObjectCustomInit

# Flakey in --release
testReturnInIterator

# Remove Mode from inference_state
testSelfTypeRestrictedMethodOverloadInitBadTypeNoCrash
# Class is still set in InferenceState
testAsyncForComprehensionErrors
# TODO ^ also clean up dataclass field calculation

# typing.List used in inference
testTypeApplicationWithQualifiedTypeAlias
# typing.Union used in type alias
testUnionTypeAliasWithQualifiedUnion
# Type alias inference should be typing._SpecialForm
testTypeAliasWithNewStyleUnion

# Type var constraints not enforced in type alias
testValidTypeAliasValues
testValidTypeAliasValuesMoreRestrictive

# Type var finder recursion is not handled, because imports are involved.
testRecursiveAliasImported

# No recursion tests
testRecursiveDoubleUnionNoCrash
testNoRecursiveExpandInstanceUnionCrashGeneric
testNoRecursiveExpandInstanceUnionCrashInference

# Implement bitwise or
testUnionOrSyntaxWithTypeAliasWorking

# Callable formatting varargs
testUnionOfSimilarCallablesCrash
# Nicer Callable Errors
testCallableParsingFromExpr
testCallableParsing
testCallableTooManyVarArg
testCallableKindsOrdering

# Details around Never?
testStar2Context

# Invalid recursive aliases --enable-recursive-aliases
testRecursiveAliasesProhibitBadAliases
# Recursive Alias wrong type var inference --enable-recursive-aliases
testRecursiveAliasesJoins
# Recursive alias union type var inference --enable-recursive-aliases
testRecursiveAliasWithRecursiveInstanceInference
# Recursive alias class type aliases --enable-recursive-aliases
testRecursiveClassLevelAlias

# func type var in __init__
testInvalidNumberOfTypeArgs
testInheritedConstructor2
testMapStr
testVarArgsFunctionSubtyping

# Uses function context but is in fact in module context
testFunctionForwardRefAlias

# In A + B, if B is a subclass of A, __radd__ on B is called first
testReverseOperatorOrderingCase4
testReverseOperatorOrderingCase6
testReverseOperatorOrderingCase7
testReverseOperatorWithOverloads2
testFlattenTypeAliasWhenAliasedAsUnion
testOperatorDoubleUnionStandardSubtyping
# "Signatures of "__radd__" of "Fraction" and "__add__" of "T" are unsafely overlapping"
testReverseOperatorOrderingCase3
testReverseOperatorWithOverloads1
testDivReverseOperator
testReverseOperatorTypeVar1
testReverseOperatorTypeVar2a
testReverseOperatorTypeVar2b
testReverseOperatorTypeVar3
testReverseOperatorTypeType
testUnsafeOverlappingWithOperatorMethodsAndOverloading2
testUnsafeOverlappingWithLineNo
testReverseComparisonOperator
testUnsafeOverlappingNamedTuple
testOverlappingOperatorMethods
# "Forward operator "__add__" is not callable"
testReverseOperatorMethodForwardIsAny3
# Formatting?
testMiscBinaryOperators
# functools.total_ordering
testTotalOrderingEqLt
testTotalOrderingLambda
testTotalOrderingReturnNotBool
testTotalOrderingAllowsAny
testTotalOrderingWithForwardReference

# Overloaded function implementation does not accept all possible arguments with type vars
testOverloadAndClassTypes
# Overload class self variable matching (__init__ against __init__)
testUnpackIterableClassWithOverloadedIter
testUnpackIterableClassWithOverloadedIter2
# Overload union math for __init__
overload_union_math_on_class_init_constrained
# union math for None vs. TypeVar
testOverloadDetectsPossibleMatchesWithGenerics
# Overload __init__ formatting shows a return type
testOverloadedInitSupertype
testSerializeOverloaded__init__
# overload classmethod variants formatting cls type should be Class not any
testOverloadClassmethodDisappears
testGenericClassAlternativeConstructorPreciseOverloaded
testOverloaded__new__
testIOTypes

# Class function Foo.bar something like a BoundFunction
testParamSpecConstraintOnOtherParamSpec
testExpandNonBareParamSpecAgainstCallable

# Cannot use a covariant type variable as a parameter
testRejectCovariantArgument
testRejectCovariantArgumentSplitLine
testRejectCovariantArgumentInLambda
testBadVarianceInProtocols
# Cannot use a contravariant type variable as return type
testRejectContravariantReturnType
testAcceptCovariantReturnType
testAcceptContravariantArgument

# Union of empty lists dicts sets with used ones
testUnificationEmptyListLeft
testUnificationEmptyListRight
testUnificationEmptyListLeftInContext
testUnificationEmptyListRightInContext
testUnificationEmptySetLeft
testUnificationEmptyDictLeft
testUnificationEmptyDictRight
testUnificationDictWithEmptyListLeft
testUnificationDictWithEmptyListRight
testMisguidedSetItem
testOperatorWithEmptyListAndSum
testOrOperationWithGenericOperands
testOrOperationInferredFromContext

# Union not matching type vars (None | Any and int | None leads to None | Any)
testJoinUnionWithUnionAndAny
testNoComplainInferredNoneStrict

# Callable matching
testNoCrashOnNestedGenericCallable

# cycle for self.a = self.f(self.a) where f(T) -> T
testGenericTypeBody1
# import cycle
testBoundGenericMethodParamSpecFine
testCyclicUndefinedImportWithName
testCyclicUndefinedImportWithStar1
testCyclicUndefinedImportWithStar2
testCyclicUndefinedImportWithStar3
testNewAnalyzerTypeAnnotationCycle4
testBoundGenericMethodFine
testNewImportCycleTypeVarBound
testNewImportCycleTupleBase
# C = C Cycle
testOverrideByIdemAliasCorrectType
testOverrideByIdemAliasCorrectTypeReversed
testConditionalExceptionAlias
testListAssignmentUnequalAmountToUnpack
testSelfReferentialSubscriptExpression
testNewAnalyzerMemberNameMatchesNamedTuple
testVariableTypeWithQualifiedName
testNewAnalyzerMemberNameMatchesTypedDict

# Module attributes
testModuleImplicitAttributes
# Function attributes
testOverlappingClassCallables
# type attributes
testTypeEquivalentTypeAnyEdgeCase
testMetaclassMemberAccessViaType3

# Bound not respected
testLiteralAndGenericsRespectsUpperBound
testWideOuterContextEmptyError
# Value of type variable "P" of "new_pro" cannot be "U"
testTypeUsingTypeCTwoTypeVars
testOverloadedCallWithVariableTypes
# Bound formatting on errors
testBoundMethodUsage

# Tuple type var context
testTupleContextFromIterable
testComplexTypeInferenceWithTuple
testInferenceWithTypeVariableTwiceInReturnType
testInferenceWithTypeVariableTwiceInReturnTypeAndMultipleVariables
testLiteralFinalErasureInMutableDatastructures1
testLiteralFinalGoesOnlyOneLevelDown
testLiteralAndInstanceSubtyping
class_generics_recursion
# bottom up tuple inference
testLiteralInferredInTupleContext
# bottom up inference for tuple with *args
testCallerVarArgsListWithTypeInference
testCallerVarArgsTupleWithTypeInference
testCallerVarargsAndComplexTypeInference
testStarUnpackNestedUnderscore
# bottom up inference list multiply
testListMultiplyInContext
# bottom up dict
testDictionaryLiteralInContext
testLiteralInferredInDictContext
# "Dict entry 0 has incompatible type "int": "str"; expected "int": "int""
testErrorCodeListOrDictItem
testColumnListOrDictItemHasIncompatibleType
testDictWithKeywordArgs

# context inference from class statement
testSetDescriptorOnClass

# union list context inference
testUnpackingUnionOfListsInFunction
testNestedProtocolGenericUnions
testNestedProtocolGenericUnionsDeep
# union dict context inference
testNoCrashOnGenericUnionUnpacking
# Tuple iter fixes
testTupleBaseClass
# union context inference
testCrashOnComplexCheckWithNamedTupleNext

# Not able to infer context with unions and literals
testLiteralAndGenericWithUnion
testLiteralAndGenericsNoMatch

# Type variable "C.T" cannot be used as an expression
testClassMemberTypeVarInFunctionBody
# Type variable "__main__.Ts" is invalid as target for type alias
testTypeVarTupleIsNotValidAliasTarget
testGenericTypeAliasesWrongAliases
# Type variable "__main__.T" is unbound
# (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class)
# (Hint: Use "T" in function signature to bind "T" inside a function)
testGenericTypeAliasesRuntimeExpressionsInstance
testNestedGenericFunctionTypeApplication
# An unbound ParamSpec in type application
testParamSpecAliasNested

# ParamSpec is not unbound if working like a T in Callable?
testTrivialParametersHandledCorrectly

# type var backtracking
testUnionInference
unite_type_vars_mypy_issue_5874
multiple_lambda_mypy_issue_4226

# Chained assignments are not legal like a = b = [] if a and b are list[int]
# and list[str].
testChainedAssignmentInferenceContexts

# Nested type vars
testFunctionInGenericInnerClassTypeVariable-skip
testConstraintsBetweenConcatenatePrefixes
testParamSpecTestPropAccess
testTupleAndDictOperationsOnParamSpecArgsAndKwargs
testUnpackingParamsSpecArgsAndKwargs
testParamSpecConcatenateFromPep
param_spec_with_identity_mypy_issue_12278

# Param spec invalid definitions
testInvalidParamSpecDefinitionsWithArgsKwargs
testInvalidParamSpecAndConcatenateDefinitionsWithArgsKwargs
testUnboundParamSpec
testParamSpecArgsAndKwargsMissmatch
# Param spec invalid calls
testParamSpecInvalidCalls

# Callable type alias definition
testConcatDeferralNoCrash
# "Self type cannot be used in type alias target"
testTypingSelfNonAnnotationUses
# Weird alias applications
testNewAnalyzerAliasToNotReadyClassDoubleGeneric

# Are generics in self types always bound to the function?
# https://github.com/python/typing/discussions/1340
# https://github.com/python/mypy/issues/14729
testSelfTypeBadTypeIgnoredInConstructorGeneric
testSelfTypeRestrictedMethodOverloadInit

# NewType in function "A@6" as qualified name
testNewTypeInLocalScope
# class in class forward reference
testForwardReferenceToNestedClassWithinClass
testClassWithBaseClassWithinClass
testDeclarationReferenceToNestedClass
# class in function forward reference / type comment
testGenericClassWithinFunction
testGenericClassWithInvalidTypevarUseWithinFunction
testClassWithinFunction
testDeclareVariableWithNestedClassType
# function types in class body
testMethodRefInClassBody
# Class argument and __init__ as overloaded DbType
testOverloadedToGeneric

# name binding of type definitions within function/class scopes
testSerializeNamedTupleInMethod4
testForwardBoundFunctionScopeWorks
testIncrementalNestedTypeAlias

# object.__new__(cls) -> Self where object.__new__(int) leads to Never
testOverride__new__AndCallObject

# Self type classmethod access with type vars(no Self)
testSelfTypeClone
testNewAnalyzerTypeVarBoundInCycle
testSelfTypeVarIndexExpr
# classmethod self param in overload is not a self param
testOverloadClassMethodImplementation
testClassMethodBeforeInit3
# Recursion error wtf?
testRefMethodWithOverloadDecorator
# classmethod self type with overload
testSelfTypeClassMethodOverloadedOnInstance
SelfTypeOverloadedClassMethod
# "staticmethod" used with a non-method"
testStaticmethodAndNonMethod
# "classmethod" used with a non-method"
testClassmethodAndNonMethod
# Error for staticmethod: "Overloaded function implementation does not accept all possible arguments of signature 1"
testOverloadWithSwappedDecorators2
# "Static methods cannot use Self type"
testTypingSelfClassMethod
# staticmethod
testBuiltinStaticMethod
testRefMethodWithDecorator

# "The erased type of self "Type[__main__.A]" is not a supertype of its class "Type[__main__.B]""
testSelfTypeNonsensical
testSelfTypeNew
testSelfTypeNew_explicit

# dict specialities
testDictWithKeywordArgsOnly
testDictWithoutKeywordArgs
testDictFromList
testDictFromIterableAndKeywordArg
testDictFromIterableAndKeywordArg2
testDictFromIterableAndStarStarArgs
testDictFromIterableAndStarStarArgs2
testSpecialSignatureForSubclassOfDict
testSpecialSignatureForSubclassOfDict2
testDictWithStarStarExpr
testDictIncompatibleTypeErrorMessage
testDictIncompatibleKeyVerbosity
testDictIncompatibleValueVerbosity
testDictExpressionErrorLocations
# star star in dict literal
testDictStarInference
testDictStarAnyKeyJoinValue

# tuple() / tuple([1])
testTupleAsSubtypeOfSequence
testListInplaceAdd
# Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4
# "Too many values to unpack (2 expected, 3 provided)"
testInferringLvarTypesInMultiDefWithInvalidTuple
testMultipleAssignmentWithDynamic
testMultipleAssignmentWithInvalidNumberOfValues
testInitializationWithMultipleValues
testNestedTupleAssignment2
testUnionAlwaysTooMany
testUnionAlwaysTooFew
testUnionOfVariableLengthTupleUnpacking
# Union IteratorContent len() call
testUnionUnpackingChainedList2
# "Unsupported target for indexed assignment ("tuple[A, B]")"
testAssigningToTupleItems
testErrorCodeIndexing
testColumnInvalidIndexing
testNewSyntaxSpecialAssign
# star unpacking for tuples
testAssignmentToStarAnnotation
testAssignmentToStarCount1
testAssignmentToStarCount2
testAssignmentToStarFromAny
testAssignmentToComplexStar
testAssignmentToStarFromTupleType
testStarredExpressionsInForLoop
testStarExpression
testStarExpressionInFor
testTwoStarExpressions
testTwoStarExpressionsInForStmt
# star input for tuple
testTupleWithStarExpr2
testTupleWithStarExpr3
testTupleWithStarExpr
# "Can use starred expression only as assignment target"
testUnpackSyntaxError
# union tuple index
testUnionOfTupleIndex
testUnionOfTupleIndexMixed
# tuple concatenation
testFixedLengthTupleConcatenation
# tuple multiplication
testMultiplyTupleByIntegerLiteral
testMultiplyTupleByIntegerLiteralReverse
# "Expression tuple item 8 has type "str"; "int" expected;"
testAssigningWithLongTupleInitializer
# Tuple operator in
testTupleMethods
# tuple maybe ok error messages?
testTupleWithUndersizedContext
testTupleWithOversizedContext
testAssignEmptyBogus
# tuple assignment tuple[Any, ...] to tuple[A, A]
testSubtypingWithNamedTupleType

# Tuple Super Class
testGenericTupleTypeCreation
testGenericTupleTypeSubclassing
testTypeAliasesToNamedTuple
testNewAnalyzerTupleIteration
testValidTupleBaseClass2
testGenericClassWithTupleBaseClass
testTupleSubclassJoin
testTypeTupleCall
# Tuple indexing (including slices)
testLiteralIntelligentIndexingTuples
testLiteralIntelligentIndexingTupleUnions
testMutuallyRecursiveNamedTuplesClasses
testNonliteralTupleSlice
testIndexingWithDynamic
testIndexingTuples
testIndexingTuplesWithNegativeIntegers
testMultipleAssignmentWithIndexedLvalues
testTupleMeetTupleVariable
testNonliteralTupleIndex
# `Foo: NamedTuple` used as definition
testNamedTupleTypeIsASuperTypeOfOtherNamedTuples
testNamedTupleTypeIsASuperTypeOfOtherNamedTuplesReturns
# Semanal issues
testTypingNamedTupleWithTooFewArguments
# "Class has two incompatible bases derived from tuple"
testNamedTuplesTwoAsBaseClasses
testNamedTuplesTwoAsBaseClasses2
# "NamedTuple type as an attribute is not supported"
testAssignNamedTupleAsAttribute
testNoCrashUnsupportedNamedTuple
# "First argument to namedtuple() should be "A", not "X""
testNamedTupleTypeNameMatchesVariableName
testInvalidNamedTupleWithinFunction
testNamedTupleNameMismatch
testNewAnalyzerIncrementalBrokenNamedTuple
testNewAnalyzerIncrementalBrokenNamedTupleNested
# "Statement is unreachable"
testNamedTupleWithBoolNarrowsToBool
testUnreachableWithStdlibContextManagers
testUnreachableWithStdlibContextManagersNoStrictOptional
testSpecialTypingProtocols
# "Self type cannot be used in NamedTuple item type"
testNamedTupleSelfItemNotAllowed
# "Property "y" defined in "Point" is read-only"
testTypingExtensionsNamedTuple
testNamedTupleAttributesAreReadOnly
testNewNamedTupleAttributesAreReadOnly
# Namedtuple unpacking size messages
testNamedTupleUsedAsTuple
# Joining namedtuples (especially generic once)
testGenericNamedTupleJoin
testNewNamedTupleJoinNamedTuple
testNewNamedTupleJoinTuple
# "Generic named tuples are not supported for legacy class syntax"
testGenericNamedTupleNoLegacySyntax
# Recursive generic NamedTuple
testBasicRecursiveGenericNamedTuple
# NamedTuple generic used
testGenericNamedTupleCallSyntax
# ^ need to add generic namedtuple tests for call syntax
# NamedTuple special methods
testNewAnalyzerNamedTupleSpecialMethods
testNewAnalyzerNamedTupleBaseClass
testNamedTupleAsDict
testNamedTupleReplace
testNamedTupleReplaceAsClass
testNamedTupleReplaceTyped
testNamedTupleMake
testNamedTupleFields
testNamedTupleSource
testNamedTupleUnit
testNamedTupleFieldTypes
testNamedTupleSelfTypeReplace
testNamedTupleSelfTypeMake
testNamedTupleTypingSelfMethod
testGenericNamedTupleMethods
testUnionUnpackingInForTuple
testNewNamedTupleAsDict
testNewNamedTupleReplaceTyped
testNewNamedTupleFields
testNewNamedTupleUnit
testNamedTupleTypeInheritanceSpecialCase
# Namedtuple class attr access
testNamedTupleForwardFunctionIndirectReveal
testNamedTupleMissingClassAttribute
# Namedtuple bad overwrite of count etc
testNamedTupleIncompatibleRedefinition
testNewNamedTupleIllegalNames
# "Protocol member HasX.x expected settable variable, got read-only attribute"
testTypingNamedTupleAttributesAreReadOnly
# "NamedTuple field name cannot start with an underscore: _y"
testNewNamedTupleNoUnderscoreFields
# "NamedTuple should be a single base"
testNewNamedTupleShouldBeSingleBase
# Tuple Qualified nested class name
testNewAnalyzerNamedTupleClassNestedMethod
testNewAnalyzerNamedTupleCallNested
testNewAnalyzerNamedTupleCallNestedMethod
testIncrementalInnerClassAttrInMethodReveal
testSelfTypeProperSupertypeAttributeTuple
# Formatting qualified names like tuple[int, fallback=b.C.Hidden@5]
testNewAnalyzerIncrementalMethodNamedTuple

# __post_init__
testPostInitCorrectSignature
testPostInitSubclassing
testPostInitNotADataclassCheck
testPostInitMissingParam
testPostInitWrongTypeAndName
testPostInitExtraParam
testPostInitReturnType
testPostInitDecoratedMethodError
testPostInitIsNotAFunction
testPostInitClassMethod
testPostInitStaticMethod
testDataclassesInitVarNoOverride
# dataclass classmethod
testDataclassesClassmethods
testClassmethodShadowingFieldDoesNotCrash
# dataclass circular inheritance
testDataclassGenericWithBound
testNoCrashOnSelfWithForwardRefGenericDataclass
testDeferredDataclassInitSignature
# : TypeAlias in dataclasses
testTypeAliasInDataclassDoesNotCrash
# : Final in dataclasses
testFinalInDataclass
# dataclass order
testIncrementalDataclassesDunder
testDataclassUpdate6
# any base class
testDataclassesAnyInherit
# InitVar set default
testDataclassInitVarCannotBeSet
# context with optional
testNoComplainFieldNone
testNoComplainFieldNoneStrict
# dataclasses.replace
testReplaceUnion
testReplaceUnionOfTypeVar
testReplaceTypeVarBoundNotDataclass
testReplaceTypeVarBound
testReplaceAny
testReplaceNotDataclass
testReplaceGeneric
testDataclassReplace
testReplace
# __match_args__
testDataclassWithMatchArgs
# dataclass transform
updateDataclassTransformParameterViaDecorator
updateDataclassTransformParameterViaParentClass
updateBaseClassToUseDataclassTransform
frozenInheritanceViaDefault
testDataclassReplaceOptional

# Enum is also a NamedTuple. wtf?
testNamedTupleEnum
# int | str leads to object instead of Any when using Enum().value?
testEnumValueInhomogenous
# Enum binding IntEnum instead of the enum class, because it's not an actual class
testFunctionalEnumProtocols
testEnumFlag
testEnumIntFlag
# dict meets/joins should avoid ors in literals and just be str
testPrivateAttributeNotAsEnumMembers
# All members in a union lead to the enum again
testEnumTypeCompatibleWithLiteralUnion
# Enum Dict value inferred is int instead of Literal[1]
testFunctionalEnumDict
testFunctionalEnumListOfPairs
# enum member gathering
testFinalWithMethodAssignment
# Enum access merging leads to int | Any instead of Any
testEnumValueUnionSimplification
# Generic Enums
testGenericEnum
# "Cannot assign to final attribute "gold""
testEnumFinalValues
testEnumFinalSpecialProps
# "Cannot override writable attribute "x" with a final one"
testEnumNotFinalWithMethodsAndUninitializedValues
testEnumAreStillFinalAfterCache

# "Enum type as attribute is not supported"
testAssignEnumAsAttribute
# "TypedDict type as attribute is not supported"
testAssignTypedDictAsAttribute

testTypedDictUpdate2
testCrashInvalidArgsSyntheticClassSyntax
testCrashInvalidArgsSyntheticClassSyntaxReveals
# TypedDict recursions
testBasicRecursiveTypedDictExtending
testRecursiveGenericTypedDictExtending
testRecursiveTypedDictCreation
testRecursiveTypedDictMethods
testRecursiveTypedDictSubtyping
testRecursiveTypedDictJoin
testBasicRecursiveGenericTypedDict
testCorrectJoinOfSelfRecursiveTypedDicts
testCrashOnSelfRecursiveTypedDictVar
# Recursive type dict calls
testBasicRecursiveTypedDictCall
testRecursiveTypedDictWithList
# TypedDict recursion with imports
testNewImportCycleTypedDict
# "Incompatible types (expression has type "int", TypedDict item "x" has type "str")"
testCannotCreateTypedDictInstanceWithIncompatibleItemType
testNewAnalyzerTypedDictClassInheritance
testColumnTypedDict
testTypedDictDoesNotAcceptsFloatForInt
testTypedDictImportCycle
# Incompatible types in assignment (expression has type "__main__.A", variable has type "A")
testTypedDictSubtypingWithTotalFalse
testNonTotalTypedDictCanBeEmpty
# "Unpack item in ** argument must be a TypedDict"
testUnpackWithoutTypedDict
# "Missing named argument "radius" for "foo""
testUnpackTypedDictTotality
testErrorCodeTypedDict
# "Missing key "y" for TypedDict "Point"
testCannotCreateTypedDictInstanceWithMissingItems
testTypedDictDictLiterals
testTypedDictExplicitTypes
testTypedDictUppercaseKey
testDoesRecognizeRequiredInTypedDictWithClass
testDoesRecognizeRequiredInTypedDictWithAssignment
# "TypedDict "a.Dict[TValue]" has no key "x""
testTypedDictMissingEmptyKey
testGenericTypedDictWithError
# "Extra key "z" for TypedDict "Point""
testCannotCreateTypedDictInstanceWithExtraItems
testTypedDictConstructorWithTotalFalse
testTypedDictUnpackMissingOrExtraKey
# "Expected TypedDict key "x" but found keys ("x", "z")"
testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithExtraItems
testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithMissingItems
# "Expected TypedDict key to be string literal"
testTypedDictLiteralTypeKeyInCreation
testTypedDictBytesKey
# "Expected keyword arguments, {...}, or dict(...) in TypedDict constructor"
testCannotCreateTypedDictInstanceWithUnknownArgumentPattern
# "Inline TypedDict types not supported; use assignment to define TypedDict"
testCannotCreateTypedDictInstanceWithInlineTypedDict
# context inference of typed dicts
testErrorCodeTypedDictNoteIgnore
testErrorCodeTypedDictSubCodeIgnore
# "First argument "Bar" to TypedDict() does not match variable name "Foo"  [name-match]"
testTypedDictNameMismatch
# "Invalid statement in TypedDict definition; expected "field_name: field_type""
testTypedDictNestedClassRecheck
# class:678
testCanCreateTypedDictWithSubclass2
# database:1198
testTypedDictUnionSimplification
testTypedDictUnionSimplification2
# database:1102
testTypedDictUnionUnambiguousCase
testTypedDictUnionAmbiguousCaseBothMatch
testTypedDictUnionAmbiguousCaseNoMatch
# typed dict as base class
testCanCreateTypedDictWithClassOldVersion
testCannotCreateTypedDictWithClassOtherBases
testCannotCreateTypedDictWithDuplicateBases
# "Overwriting TypedDict field "x" while merging"
testCanCreateTypedDictWithClassOverwriting
# "Overwriting TypedDict field "x" while extending"
testCanCreateTypedDictWithClassOverwriting2
# Invalid NamedTuple
testCannotCreateTypedDictWithClassWithOtherStuff
testCannotCreateTypedDictWithClassWithFunctionUsedToCrash
testCannotCreateTypedDictWithDecoratedFunction
testTypedDictWithClassmethodAlternativeConstructorDoesNotCrash
# "Duplicate TypedDict key "x""
testCannotCreateTypedDictWithDuplicateKey1
testCannotCreateTypedDictWithDuplicateKey2
# dict() initializations
testTypedDictCreatedWithEmptyDict
# Unpack
testUnpackKeywordTypesTypedDict
testUnpackKwargsNonIdentifier
testUnpackKwargsSerialize
testDataclassFieldWithTypedDictUnpacking
testUnpackKwargsOverridesTypedDict
# dict unpacking
testTypedDictUnpackMultiple
testTypedDictUnpackNested
testTypedDictUnpackNestedError
testTypedDictUnpackOverrideRequired
testTypedDictUnpackUntypedDict
testTypedDictUnpackIntoUnion
testTypedDictUnpackFromUnion
testTypedDictUnpackUnionRequiredMissing
testTypedDictUnpackInference
testTypedDictUnpackStrictMode
testTypedDictUnpackAny
# structural matching
testCanConvertTypedDictToEquivalentTypedDict
testCanConvertTypedDictToNarrowerTypedDict
testTypedDictWithSimpleProtocol
testTypedDictWithSimpleProtocolInference
testTypedDictOverloading4
testTypedDictOverloading5
# matching mapping
testCanConvertTypedDictToCompatibleMapping
testForwardReferenceInTypedDict
testForwardReferenceInClassTypedDict
# Lookups
testOverloadKwargsSelectionWithTypedDict
testCachedBadProtocolNote
testErrorCodeSpecialArgTypeErrors
testCanConvertTypedDictToAnySuperclassOfMapping
testTypedDictMappingMethods
testCanCreateTypedDictInstanceWithKeywordArguments
testCanCreateTypedDictInstanceWithDictCall
testCanCreateTypedDictInstanceWithDictLiteral
testCanCreateTypedDictInstanceWithNoArguments
testTypedDictConstraintsAgainstIterable
testTypedDictMissingMethod
testTypedDictOverloading
testTypedDictOverloading2
testTypedDictAsStarStarArg
testTypedDictAsStarStarArgConstraints
testTypedDictAsStarStarArgCalleeKwargs
testTypedDictAsStarStarTwice
testTypedDictAsStarStarAndDictAsStarStar
testTypedDictUnionGetItem
testTypedDictUnionDelItem
testTypedDictAttributeOnClassObject
# __setitem__
testCanSetItemOfTypedDictWithValidStringLiteralKeyAndCompatibleValueType
testCannotSetItemOfTypedDictWithIncompatibleValueType
testCannotSetItemOfTypedDictWithInvalidStringLiteralKey
testCannotSetItemOfTypedDictWithNonLiteralKey
testTypedDictUnionSetItem
# "TypedDict "XXX" has no key "xxx" "
testCannotGetItemOfTypedDictWithInvalidStringLiteralKey
testCannotGetItemOfAnonymousTypedDictWithInvalidStringLiteralKey
testTypedDictTypeVarUnionSetItem
# Typed dict generics in getitem
testTypedDictUpdateGeneric
# generics
testGenericTypedDictSerialization
testGenericTypedDictCreation
testGenericTypedDictInference
testGenericTypedDictExtending
testGenericTypedDictExtendingErrors
testGenericTypedDictAlias
testGenericTypedDictMultipleGenerics
testGenericTypedDictCallSyntax
# Self type cannot be used in TypedDict item type
testTypedDictSelfItemNotAllowed
# Nested typed dict formatting
testSerializeTypedDictInMethod
# TypedDict .get() special case
testLiteralIntelligentIndexingUsingFinal
testLiteralIntelligentIndexingTypedDict
testLiteralIntelligentIndexingTypedDictUnions
testLiteralIntelligentIndexingMultiTypedDict
testTypedDictGet
testTypedDictGetMethod
testTypedDictGetMethodTypeContext
testTypedDictGetMethodInvalidArgs
testTypedDictChainedGetMethodWithDictFallback
testTypedDictGetDefaultParameterStillTypeChecked
testTypedDictChainedGetWithEmptyDictDefault
testTypedDictIndexingWithNonRequiredKey
testPluginUnionsOfTypedDicts
testPluginUnionsOfTypedDictsNonTotal
# Further special cases
testTypedDictPopMethod
testTypedDictDel
testTypedDictNonMappingMethods
testTypedDictOptionalUpdate
testUnionOfEquivalentTypedDictsInferred
testTypedDictFlexibleUpdate
testTypedDictFlexibleUpdateUnion
testTypedDictFlexibleUpdateUnionExtra
# --extra-checks
testTypedDictStrictUpdate
testTypedDictFlexibleUpdateUnionStrict
testTypedDictUnpackSame
testTypedDictUnpackCompatible
testTypedDictUnpackIncompatible
testTypedDictUnpackMultiple
# TypedDict total=false
testTypedDictUnionGetFull
testTypedDictClassWithTotalArgument
# Anonymous TypedDicts for join
testNonTotalTypedDictInErrorMessages
testAnonymousTypedDictInErrorMessages
testJoinOfTypedDictHasOnlyCommonKeysAndNewFallback
testJoinOfTypedDictRemovesNonequivalentKeys
testJoinOfDisjointTypedDictsIsEmptyTypedDict
testJoinOfTypedDictWithCompatibleMappingIsMapping
testJoinOfTypedDictWithCompatibleMappingSupertypeIsSupertype
testJoinOfTypedDictWithIncompatibleTypeIsObject
# join
testTypedDictJoinWithTotalFalse
# meet
testMeetOfTypedDictsWithCompatibleCommonKeysHasAllKeysAndNewFallback
testMeetOfTypedDictsWithIncompatibleCommonKeysIsUninhabited
testMeetOfTypedDictsWithNoCommonKeysHasAllKeysAndNewFallback
testMeetOfTypedDictWithCompatibleMappingIsUninhabitedForNow
testMeetOfTypedDictWithIncompatibleMappingIsUninhabited
testMeetOfTypedDictWithCompatibleMappingSuperclassIsUninhabitedForNow
testMeetOfTypedDictsWithNonTotal
testMeetOfTypedDictsWithNonTotalAndTotal
testMeetOfTypedDictsWithIncompatibleNonTotalAndTotal
# unions
testUnionOfEquivalentTypedDictsDeclared
testUnionOfEquivalentTypedDictsEmpty
testUnionOfEquivalentTypedDictsDistinct
testUnionOfEquivalentTypedDictsNested
# "Required[] can be only used in a TypedDict definition"
testDoesDisallowRequiredOutsideOfTypedDict
testDoesOnlyAllowRequiredInsideTypedDictAtTopLevel
testDoesDisallowRequiredInsideRequired
testDoesDisallowNotRequiredOutsideOfTypedDict
testDoesOnlyAllowNotRequiredInsideTypedDictAtTopLevel
testDoesDisallowNotRequiredInsideNotRequired
# "Required[] must have exactly one type argument"
testRequiredOnlyAllowsOneItem
testNotRequiredOnlyAllowsOneItem
# Required/ NotRequired
testRequiredExplicitAny
testNotRequiredExplicitAny
testDoesRecognizeNotRequiredInTypedDictWithClass
testDoesRecognizeNotRequiredInTypedDictWithAssignment
testTypedDictUnpackNotRequiredKeyIncompatible
testTypedDictUnpackNotRequiredKeyExtra
testTypedDictUnpackRequiredKeyMissing

# NoReturn
testNoReturnTypeAlias
testUnionWithNoReturn
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2
testDontNeedAnnotationForCallable
testLiteralCheckSubtypingStrictOptional
testLiteralCheckSubtypingNoStrictOptional
testNewAndInitNoReturn
testOverloadedNewAndInitNoReturn
testNoReturnImportFromTyping

# typing.no_type_check
testNoTypeCheckDecoratorOnMethod1
testNoTypeCheckDecoratorOnMethod2
testCallingNoTypeCheckFunction
testCallingNoTypeCheckFunction2
testNoTypeCheckDecoratorSemanticError

# Dynamic functions are ignored in classes and the super class is used?
testInferringTypesFromIterable

# Comprehensions
testNewAnalyzerListComprehension
testNewAnalyzerDictionaryComprehension
testEnumerateReturningSelfFromIter
testSimpleListComprehension
testSimpleListComprehensionNestedTuples
testSimpleListComprehensionNestedTuples2
testListComprehensionWithNonDirectMapping
testErrorInListComprehensionCondition
testTypeInferenceOfListComprehension
testSimpleListComprehensionInClassBody
testSimpleSetComprehension
testSimpleDictionaryComprehension
testDictionaryComprehensionWithNonDirectMapping
testSimpleGeneratorExpression
testGeneratorIncompatibleErrorMessage
testComprehensionShadowBinder
testIterableProtocolOnClass
testIterableProtocolOnMetaclass
testTwoStarExpressionsInGeneratorExpr
testYieldOutsideFunction
testDictUpdateInference
# comprehensions Scoping
testListComprehensionSpecialScoping
# "Assignment expression within a comprehension cannot be used in a class body"
testNoCrashOnAssignmentExprClass

# lambda
testIncrementalWithDecorators
testLambdaWithArguments
testLambdaDefaultTypeErrors
testLambdaDefaultContext
testLambdaVarargContext
testLambdaDeferredSpecialCase
testErasedTypeRuntimeCoverage
testLambdaJoinWithDynamicConstructor
testSelfTypeLambdaDefault
testEnclosingScopeLambdaNoCrash
testEnclosingScopeLambdaNoCrashExplicit
testLambdaAndReachability
testNoCrashOnPartialLambdaInference
testGenericLambdaGenericMethodNoCrash
testFastParserDuplicateNames
testLambda
testComplexLambda
testLambdaPrecedence
testListMethods
testMapWithLambdaSpecialCase
testSortedNoError
testReModuleBytes
testReModuleString
# lambda: Name "UNDEFINED" is not defined
testLambdaInheritsCheckedContextFromTypedFunc
testLambdaInheritsCheckedContextFromTypedFuncForced
testLambdaInheritsCheckedContextFromModule
testLambdaInheritsCheckedContextFromModuleForce
testLambdaInheritsCheckedContextFromModuleLambdaStack
testLambdaInheritsCheckedContextFromModuleLambdaStackForce
testLambdaInheritsCheckedContextFromFuncLambdaStackForce
testLambdaInheritsCheckedContextFromTypedFuncLambdaStack
testLambdaInheritsCheckedContextFromTypedFuncLambdaStackForce
testLambdaInheritsCheckedContextFromClassLambdaStack
testLambdaInheritsCheckedContextFromClassLambdaStackForce
testLambdaInheritsCheckedContextFromFuncForced
# Lambda with defined return types (inferred context)
testInferLambdaTypeUsingContext
testLambdaWithoutContext
testInvalidContextForLambda
testEllipsisContextForLambda
testEllipsisContextForLambda2
testIsinstanceInInferredLambda
testLambdaDeferredCrash
# Cannot infer type of lambda
testParamSpecLiteralsTypeApplication
# Param Spec lambda type inference
testParamSpecInferredFromLambda
# Generator in lambda
testNoCrashOnLambdaGenerator

# Random protocol issues
testEnumIterable
testDerivedEnumIterable
testEnumIterMetaInference
testIntEnumIterable
# Protocol invalid "Access to generic instance variables via class is ambiguous"
testGenericSubProtocols
testProtocolConcreteUpdateTypeMethodGeneric
testProtocolUpdateBaseGeneric
testProtocolConcreteUpdateBaseGeneric
testProtocolChangeGeneric
# NewType with Protocol
testNewAnalyzerNoCrashForwardRefToBrokenDoubleNewTypeClass
testNoCrashForwardRefToBrokenDoubleNewType
testNoCrashForwardRefToBrokenDoubleNewTypeClass
# iterable matching of [] 
testDictFromIterableAndKeywordArg3
# Namedtuple issues with protocols
testNamedTupleWithInvalidItems
testNamedTupleWithInvalidItems2
testNamedTupleNoBytes
# "Cannot instantiate protocol class "P""
testInstantiationProtocolInTypeForAliases
testInstantiationProtocolInTypeForFunctions
testSelfTypeProtocolMetaclassMatch
# Protocol instantiations in classmethods
testInstantiationProtocolInTypeForClassMethods
# "Can only assign concrete classes to a variable of type "Type[P]""
testInstantiationProtocolInTypeForVariables
# "NewType cannot be used with protocol classes"
testCannotUseNewTypeWithProtocols
# Recursion error
testSelfTypeProtocolClassmethodMatch
testSelfTypesWithProtocolsBehaveAsWithNominal
testTwoUncomfortablyIncompatibleProtocolsWithoutRunningInIssue9771
# "Protocol members cannot be defined via assignment to self"
testProhibitSelfDefinitionInProtocols
# "All bases of a protocol must be protocols"
testProtocolsCannotInheritFromNormal
# "Invariant type variable "T" used in protocol where covariant one is expected"
testProtocolVarianceWithCallableAndList
testProtocolVarianceWithUnusedVariable
testSubtleBadVarianceInProtocols
testAutomaticProtocolVariance
# "Protocol member P.x expected settable variable, got read-only attribute"
testFinalAttributeProtocol
testModuleAsProtocolImplementationFinal
# "All protocol members must have explicitly declared types"
testImplicitTypesInProtocols
# "Type aliases are prohibited in protocol bodies"
testTypeAliasInProtocolBody
# ... has no attribute "__iter__" (not iterable)
testWeAreCarefulWithBuiltinProtocols
testWeAreCarefullWithBuiltinProtocolsBase
# "Protocol member PPS.attr expected settable variable, got read-only attribute"
testPropertyInProtocols
testSettablePropertyInProtocols
testNotManyFlagConflitsShownInProtocols
# Protocol properties
testProtocolMethodVsAttributeErrors2
testMutuallyRecursiveProtocolsTypesWithSubteMismatch
testMutuallyRecursiveProtocolsTypesWithSubteMismatchWriteable
testProtocolClassObjectPropertyRejected
testModuleAsProtocolImplementationClassObject
testModuleAsProtocolImplementationTypeAlias
testNamedTupleWithNoArgsCallableField
testNamedTupleWithManyArgsCallableField
testErrorsForProtocolsInDifferentPlaces
testBasicNamedTupleStructuralSubtyping
testClassVarProtocolImmutable
# staticmethod/classmethod
testStaticAndClassMethodsInProtocols
testBuiltinClassMethod
# Protocol with ClassVar
testProtocolClassObjectAttribute
testModuleAsProtocolImplementationClassVar
testProtocolClassVarSelfType
testProtocolTypeTypeAttribute
testProtocolClassObjectAttributeAndCall
testDataclassCheckTypeVarBounds
testDataclassCheckTypeVarBoundsInReprocess
# small protocol formatting issues
testGenericSubProtocolsExtensionCovariant
# Protocol Override inheritance
testNoneDisablesProtocolSubclassingWithStrictOptional
# Context inference for protocols
testTupleContextFromIterable2
# Module reassignments in import as
testModuleAsProtocolRedefinitionTopLevel
testModuleAsProtocolRedefinitionImportFrom
# Flaky because of dict ordering
testProtocolIncompatibilityWithManyConflicts
# ""C" has constructor incompatible with "__call__" of "P""
testProtocolClassObjectPureCallback
# Too much? error output, but otherwise correct
testSimpleProtocolOneMethodOverride
testSimpleProtocolTwoMethodsMerge
testRecursiveProtocolSubtleMismatch
testBasicTupleStructuralSubtyping
testCallableProtocolVsProtocol
testProtocolClassObjectCallableError
protocol_class_object_callable_possible
# Protocol issues with unions
testInvalidTypeForKeywordVarArg
# regressions
testUnionsOfNormalClassesWithProtocols
testTypePromotionsDontInterfereWithProtocols
# meet/join protocol
testJoinProtocolWithProtocol
testJoinOfIncompatibleProtocols
testJoinProtocolWithNormal
testJoinProtocolCallback
testMeetOfIncompatibleProtocols
testMeetProtocolCallback
# no class in i_s
testProtocolsWithIncompatibleOverloads
testOverloadedMethodsInProtocols
testProtocolIncompatibilityWithManyOverloads
testMatchProtocolAgainstOverloadWithAmbiguity
testProtocolClassObjectInstanceMethodOverloaded
testDataclassFieldWithPositionalArguments
# param order ignored
testProtocolClassObjectInstanceMethod
testProtocolClassObjectInstanceMethodArg
testProtocolClassObjectGenericInstanceMethod
testProtocolClassObjectSelfTypeInstanceMethod
testProtocolTypeTypeInstanceMethod
testProtocolTypeTypeSelfTypeInstanceMethod
# random protocol tests
testDivmod
testGenericSubProtocolsExtensionInvariant
testWeirdRecursiveInferenceForProtocols-skip
testProtocolWithClassGetItem
# Protocol inference
testCallbackProtocolFunctionAttributesInference
testProtocolTypeTypeInference
testProtocolClassObjectInference
testInferenceViaTypeTypeMetaclass
# Import in Protocol
testProtocolImportNotMember
# TypeVar in Protocol Body
testTypeVarInProtocolBody
# typing_extensions.runtime_checkable
testProtocolAndRuntimeAreDefinedAlsoInTypingExtensions
testOverloadOnProtocol
testSimpleRuntimeProtocolCheck
testConcreteClassesInProtocolsIsInstance
testConcreteClassesUnionInProtocolsIsInstance
testOnlyMethodProtocolUsableWithIsSubclass
testPartialAttributeNoneType
testPartialAttributeNoneTypeStrictOptional
testProtocolSlotsAndRuntimeCheckable

# TypeVarTuple
testTypeVarTupleMixed
testTypeVarTupleChaining
testTypeVarTupleGenericClassDefn
testTypeVarTupleCached
testTypeVarTuplePep646ArrayExample
testTypeVarTuplePep646ArrayExampleWithDType
testTypeVarTuplePep646TypeVarTupleUnpacking
testTypeVarTuplePep646TypeVarStarArgsBasic
testTypeVarTuplePep646TypeVarStarArgs
testTypeVarTuplePep646TypeVarStarArgsFixedLengthTuple
testTypeVarTuplePep646TypeVarStarArgsVariableLengthTuple
testTypeVarTuplePep646Callable
testTypeVarTuplePep646CallableWithPrefixSuffix
testTypeVarTuplePep646UnspecifiedParameters
testTypeVarTuplePep646CallableStarArgs
testVariadicAliasBasicTuple
testVariadicAliasBasicCallable
testVariadicAliasUnpackFixedTupleArgs
testVariadicAliasUnpackFixedTupleTarget
testVariadicAliasWrongCallable
testVariadicAliasMultipleUnpacks
testVariadicAliasNoArgs
testVariadicAliasFewArgs
testVariadicAliasRecursiveUnpack
testVariadicAliasUpperBoundCheck
testVariadicAliasEmptyArg
testVariadicAliasVariadicTupleArg
testVariadicAliasVariadicTupleArgGeneric
testVariadicAliasVariadicTupleArgSplit
testTypeVarTuplePep646ArrayExampleInfer
testTypeVarTupleTypingExtensions
testTypeVarTupleDisabled_no_incomplete
# typing_extensions.Unpack
testRuntimeProtoTwoBases
testUnpackKwargsReveal
testUnpackOutsideOfKwargs
testUnpackWithDuplicateKeywords
testUnpackWithDuplicateKeywordKwargs
testUnpackKwargsEmpty
testUnpackUnexpectedKeyword
testUnpackKeywordTypes
testFunctionBodyWithUnpackedKwargs
testUnpackKwargsOverrides
testUnpackKwargsGeneric
testUnpackKwargsInference
testUnpackKwargsOverload
testUnpackKwargsJoin
testUnpackKwargsParamSpec
testUnpackKwargsUpdateFine
testUnpackNoCrashOnEmpty
testInvalidUnpackTypes
# Unpack item in ** argument must be a TypedDict
testTypeVarTuple

# Visibility of imports in pyi
testNewSemanticAnalyzerModulePrivateRefInMiddleOfQualified

# x: typing_extensions.TypeAlias = int
testClassLevelTypeAliasesInUnusualContexts
testMalformedTypeAliasRuntimeReassignments

# TypeAlias normal string interpreted as a forward reference
testTypeAliasWithNewStyleUnionChangedToVariable

# __builtins__ object
testBuiltinsUsingModule
# future imports (future is not part of stubs)
testNewAnalyzerMetaclassFuture1
testNewAnalyzerMetaclassFuture3
testNewAnalyzerMetaclassFuture4
testFutureMetaclass
testFromFutureMetaclass
testFutureMetaclassImportFrom
testFutureMetaclassImport
testFutureMetaclassAndBase
testFutureMetaclassGenerics
testFutureMetaclassErrors
testFutureMetaclassAny
# "Library stubs not installed for "requests""
testLibraryStubsNotInstalled
testIgnoreImportIfNoPython3StubAvailable
testNoPython3StubAvailable
# six imports
testNewAnalyzerMetaclassSix1
testNewAnalyzerMetaclassSix2
testNewAnalyzerMetaclassSix3
testNewAnalyzerMetaclassSix4
testSixMetaclassImportFrom
testSixMetaclassImport
testSixMetaclassAndBase
testSixMetaclassGenerics
testSixMetaclassErrors
testSixMetaclassAny
testSixMetaclass
testFromSixMetaclass
testSixMetaclassGenericBase
testIgnoreInsideClassDoesntAffectWhole
# import of typeshed stubs
testErrorFromGoogleCloud

# Override import cached files like typing types builtins etc.
testNoCrashDoubleReexportFunctionEmpty
testNoCrashDoubleReexportBaseEmpty
testNoCrashDoubleReexportMetaEmpty
testNoCrashDoubleReexportTupleEmpty
testNoCrashDoubleReexportOverloadEmpty
testNoCrashDoubleReexportTypedDictEmpty

# Module __all__
testNewAnalyzerExportedValuesInImportAll
testExportedValuesInImportAll
testAllMustBeSequenceStr
testUnderscoreExportedValuesInImportAll
testReExportAllInStub

# Module <M> has no attribute <missing_name>
testRelativeImportFromSameModule
testImportFromSameModule
# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions
testImportMisspellingSingleCandidate
testImportMisspellingMultipleCandidates
testImportMisspellingMultipleCandidatesTruncated
testColumnHasNoAttribute
testErrorCodeNoAttribute
testDequeWrongCase
# "C" has no attribute "__aenter__"; maybe "__enter__"?
testAsyncWithError

# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testKeywordMisspelling
testMultipleKeywordsForMisspelling
testKeywordMisspelling*

# Import submodules
testNewAnalyzerImportStarSpecialCase

# import a.b.c issues
testMissingSubmoduleImportedWithIgnoreMissingImportsStub
testMissingSubmoduleOfInstalledStubPackage
testAddedMissingStubsIgnorePackagePartial
testGenericAliasCollectionsABCReveal
# import a.b type: ignore
testFineAddedMissingStubsIgnorePackagePartial
# imports have different error codes, see https://github.com/python/mypy/commit/78339b97dc911c8c6841184eaddbbc30d0e406da
testErrorCodeMissingModule

# Complex Star import
testImportWithinMethod
testNoCrashOnImportFromStarNested
testSerializeStarImport
testImportStarWithinFunction
# Star import override
testAssignToFuncDefViaImport

# Module type does not contain module info
testMultiModuleAlias
testModuleAliasWithExplicitAnnotation

# Import itself / Extremely weird import orders
testNewAnalyzerImportCycleWithIgnoreMissingImports
testNewAnalyzerImportFromTopLevelFunction
testNewAnalyzerImportFromTopLevelAlias
testNewAnalyzerImportAmbiguousWithTopLevelFunction
testImportCycleSpecialCase
testPackagePath
testIncrementalNestedBrokenCascade

# Stub Reexport
testNoReExportFromStubs
testNoReExportFromStubsMemberType
testNoReExportFromStubsMemberVar
testNoReExportChildStubs
testReExportChildStubs
testReExportChildStubs2
testNoReExportNestedStub
testNoReExportFromMissingStubs
testMissingGenericImport
testStubFixupIssues
testNoReExportUnrelatedModule
testNoReExportUnrelatedSiblingPrefix
testUnimportedHintAny
testUnimportedHintAnyLower
testFromImportAsInStub
testImportAsInStub
testReExportChildStubs3
# underscore names are not exported in an import with stubs
testInternalBuiltinDefinition

# "mypy: "tmp/typing.py" shadows library module "typing""
testShadowTypingModule

# Metaclass descriptor
metaclass_descriptor
# Metaclass Union
testNotSimplifyingUnionWithMetaclass
# Metaclass iter/getitem/addition
testInferringLvarTypesUnpackedFromIterableClassObjectWithGenericIter
# Metaclass instance vs. class members
testMetaclassConflictingInstanceVars
testInferenceOfDunderDictOnClassObjects

# Use type(foo) when foo has a metaclass
testMetaclassTypeCallable
testMetaclassMemberAccessViaType
# Foo = type(...) used as `x: Foo` (type execution)
testNoneAlias
testNoneAliasStrict

# Type[Any] is object
testSimplifyingUnionWithTypeTypes2

# "Invalid assignment target"
testSuperWithReadWriteAbstractProperty
testAssignToBaseClassMethod
# "Call to abstract method "meth" of "Proto" with trivial body via super() is unsafe"
testEmptyBodyUnsafeAbstractSuper
testEmptyBodyUnsafeAbstractSuperOverloads
testEmptyBodyUnsafeAbstractSuperProperty
testErrorCodeUnsafeSuper_no_empty
testAbstractBodyTurnsEmpty
testAbstractBodyTurnsEmptyProtocol
testAbstractBodyTurnsEmptyCoarse
# ""abstractmethod" used with a non-method"
testAbstractNestedFunction
testAbstractGlobalFunction
# "Class a.B has abstract attributes "f""
# "If it is meant to be abstract, add 'abc.ABCMeta' as an explicit metaclass"
testAbstractClasses
# "Only concrete class can be given where "Type[C]" is expected"
testDedicatedErrorCodeTypeAbstract
testAbstractTypeInADict
# "Can only assign concrete classes to a variable of type "Type[A]""
testInstantiationAbstractsInTypeForVariables
# "Overloaded method has both abstract and non-abstract variants"
testOverloadedAbstractMethodVariantMissingDecorator0
testOverloadedAbstractMethodVariantMissingDecorator1
# class: "Cannot instantiate abstract class "C" with abstract attribute "f""
testInstantiatingAbstractClass
testInstantiatingClassWithInheritedAbstractMethod
testInstantiationAbstractsInTypeForFunctions
testInstantiationAbstractsInTypeForAliases
testOverloadedAbstractMethod
testOverloadedAbstractMethodWithAlternativeDecoratorOrder
testInstantiateClassWithReadOnlyAbstractProperty
testInstantiateClassWithReadWriteAbstractProperty
testNestedAbstractClass
testAbstractNewTypeAllowed
testSubclassOfABCFromDictionary
testAbstractPropertiesAllowed
# Cannot instantiate abstract class "A" with abstract attributes "a", "b", ... and "j" (7 methods suppressed)
testInstantiatingClassWithInheritedAbstractMethodAndSuppression
# Same but not from check-abstract.test
testAddAbstractMethod
testMakeClassAbstract
testAbstractInit
testErrorCodeInstantiateAbstract
testNewAnalyzerClassPropertiesInAllScopes
testSerializeAbstractClass
# protocol: "Cannot instantiate abstract class "C" with abstract attribute "x""
testNonProtocolToProtocol
testCannotInstantiateAbstractMethodExplicitProtocolSubtypes
testCannotInstantiateAbstractVariableExplicitProtocolSubtypes
testCannotInstantiateProtocolWithOverloadedUnimplementedMethod
testEmptyBodyImplicitlyAbstractProtocol
testEmptyBodyImplicitlyAbstractProtocolProperty
testEmptyBodyImplicitlyAbstractProtocolStub
testEmptyBodyVariationsImplicitlyAbstractProtocol
testEmptyBodyNoneCompatibleProtocol
testEmptyBodyWithFinal

# class types defined in super class
testInheritanceFromGenericWithImplicitDynamic

# "Invalid self argument "A[C]" to attribute function "f" with type "Callable[[A[B]], None]""
testInvalidMethodAsDataAttributeInGenericClass
# "Attribute function "f" with type "Callable[[], None]" does not accept self argument"
testMethodWithInvalidMethodAsDataAttribute
testClassValuedAttributesBasics
no_self

# ClassVar
testOverrideOnSelf
testOverrideOnSelfInSubclass
testMetaclassStrictSupertypeOfTypeWithClassmethods
testClassVarsInProtocols
# "ClassVar protocol member P.foo can never be matched by a class object"
testProtocolClassObjectClassVarRejected
# x = 1  # type: ClassVar
testClassVarWithoutArguments
testIncrementalClassVar

# "Variance of TypeVar "T_contra" incompatible with variance in parent type"
testIncompatibleVariance

# Self type variable type
testDecoratorUpdateNestedClass
testDecoratorUpdateClassInFunction
param_spec_with_generic_class

# Self tests
testTypingSelfAttrOldVsNewStyle
# "Method cannot have explicit self annotation and Self type"
testTypingSelfConflict
# "Self argument missing for a non-static method"
# "The erased type of self "None" is not a supertype of its class "__main__.A""
testSelfTypeNotSelfType

# "Maybe you forgot to use "await"?"
testErrorOneLessFutureInReturnType

# None as a default for class variables, even if not optional?
testNoneClassVariable
testNoneClassVariableInInit
testMultipleAssignmentNoneClassVariableInInit

# supertype context inference
testUseSupertypeAsInferenceContext
testUseSupertypeAsInferenceContextInvalidType
testUseSupertypeAsInferenceContextPartial
testUseSupertypeAsInferenceContextPartialError
testUseSupertypeAsInferenceContextPartialErrorProperty
testUseSupertypeAsInferenceContextConflict
testLiteralSubtypeContext
testLiteralSubtypeContextNested
testLiteralSubtypeContextGeneric
# Liskov context inference for list
testListObject

# keyword params do not matter, only order
testSuperOutsideClass
testSuperWithUnrelatedTypes
# Signature of "???" incompatible with supertype "???"
testOverloadedMethodSupertype-only_when_cache
testOverloadedMethodSupertype2-only_when_nocache
testOverloadedOperatorMethodOverrideWithSwitchedItemOrder
testVariableMethod
testSelfTypeOverrideCompatibilityTypeVar
testImplementAbstractPropertyViaPropertyInvalidType
# With overload
testSelfTypeOverrideCompatibility
testSubtypeOverloadWithOverlappingArgumentsButWrongReturnType
testSelfTypeOverrideCompatibilityGeneric
# Overloaded operator methods cannot have wider argument types in overrides
testOperatorMethodOverrideIntroducingOverloading
testOverloadedOperatorMethodOverrideWithNewItem
#     Overload variants must be defined in the same order as they are in "Parent"
testOverrideOverloadSwapped
testOverrideOverloadSwappedWithExtraVariants
testOverrideOverloadSwappedWithAdjustedVariants
testOverrideOverloadedMethodWithMoreSpecificArgumentTypes
testOverloadWithIncompatibleMethodOverrideAndImplementation
testOverloadFaultyClassMethodInheritance
testOverloadClassMethodMixingInheritance
testOverloadFaultyStaticMethodInheritance
testOverloadStaticMethodMixingInheritance
testOverloadStaticMethodImplementation
testOverloadedStaticMethodOnInstance
testUnsafeDunderOverlapInSubclass
# "Read-only property cannot override read-write property"
testColumnProperty
testOnlyImplementGetterOfReadWriteAbstractProperty
testReadWriteDeleteAbstractProperty
# Property access from class
testTypeAttributes
# Self definitions different from parent
testCantImplementAbstractPropertyViaInstanceVariable

# @override  "Method "g" is marked as an override, but no base method was found with this name"
explicitOverride
explicitOverrideStaticmethod
explicitOverrideClassmethod
explicitOverrideProperty
explicitOverrideSettableProperty
invalidExplicitOverride
explicitOverrideFromExtensions
explicitOverrideOverloads
explicitOverrideNotOnOverloadsImplementation
explicitOverrideOnMultipleOverloads
# @override
requireExplicitOverrideMethod
requireExplicitOverrideProperty
requireExplicitOverrideOverload
requireExplicitOverrideMultipleInheritance
# Liskov basics
testOverrideAttributeWithMethod
testAbstractGenericMethodInference
testAllowCovarianceInReadOnlyAttributes
testClassSpec
testNoneAnyFallbackDescriptor
testGenericOverridePreciseValid
testArgsKwargsInheritance
testMultipleInheritance_NestedVariableOverriddenWithCompatibleType
testSelfTypeOverrideCompatibilitySelfTypeVar
testDecoratorMethodCompat
testNamedTupleUpdate5
testOverrideWithNarrowedUnion
# Liskov abstract
testImplementingAbstractMethod
testImplementingAbstractMethodWithMultipleBaseClasses
testImplementingAbstractMethodWithExtension
testInvalidOverridingAbstractMethod
testAbstractClassCoAndContraVariance
testAbstractClassWithAllDynamicTypes2
testAbstractClassWithImplementationUsingDynamicTypes
testInstantiatingAbstractClassWithMultipleBaseClasses
# Dynamic liskov overrides not checked
testInvalidOverrideArgumentCountWithImplicitSignature1
testInvalidOverrideWithImplicitSignatureAndClassMethod1
testInvalidOverrideWithImplicitSignatureAndClassMethod2
testInvalidOverrideWithImplicitSignatureAndStaticMethod1
testInvalidOverrideWithImplicitSignatureAndStaticMethod2
# type: ignore[override]
testMultiLineMethodOverridingWithIncompatibleTypesIgnorableAtArgument
testMultiLineMethodOverridingWithIncompatibleTypesIgnorableAtDefinition
testIgnoreInvalidOverride
# Liskov with __ methods
testOperatorMethodOverrideWithIdenticalOverloadedType
testChainedCompResTyp
testCustomEqDecoratedStrictEquality
# Liskov overload
testSubtypeWithMoreOverloadsThanSupertypeSucceeds
testSubtypeOverloadCoveringMultipleSupertypeOverloadsSucceeds
testCyclicOverload
testCyclicOverloadDeferred
testImplementingOverloadedMethod
testOverrideOverloadedMethodWithMoreGeneralArgumentTypes
testOverloadWithMethodOverrideAndImplementation
testUnionMathTrickyOverload2
testSafeDunderOverlapInSubclass
# Liskov weird
testCyclicOverrideAny
# "This violates the Liskov substitution principle"
testOverrideGenericMethodInNonGenericClassGeneralize
testErrorCodeBadOverride
testColumnSignatureIncompatibleWithSuperType
# Liskov collection
testOverrideIncompatibleWithMultipleSupertypes
testLiskovFineDecorator
testLiskovFineVariableCleanDefInMethodStar-only_when_nocache
testLiskovFineDecoratorClean-only_when_nocache
testPositionalOverridingArgumentNameInsensitivity
testOverridingMethodInSimpleTypeInheritingGenericType
testOverridingMethodInGenericTypeInheritingSimpleType
testOverridingMethodInMultilevelHierarchyOfGenericTypes
testOverridingMethodInGenericTypeInheritingGenericType
testSubclassingGenericABC1
testSubclassingGenericABCWithDeepHierarchy
testSubclassingGenericABCWithDeepHierarchy2
testMethodOverridingWithIncompatibleTypes
testEqMethodsOverridingWithNonObjects
testMethodOverridingAcrossDeepInheritanceHierarchy1
testOverrideStaticMethodWithStaticMethod
testOverrideClassMethodWithClassMethod
testOverrideClassMethodWithStaticMethod
testOverrideStaticMethodWithClassMethod
testIntroducingInplaceOperatorInSubclass
testMethodOverridingWithIncompatibleTypesOnMultipleLines
testMultiLineMethodOverridingWithIncompatibleTypesWrongIgnore
testOverridingMethodAcrossHierarchy
testMultipleInheritance_MethodDefinitionsIncompatibleOverride
# classmethod/staticmethod Incompatible with superclass
testClassMethodSubclassing
testClassStaticMethodSubclassing
# "Dataclass attribute may only be overridden by another attribute"
testDataclassIncompatibleOverrides
testDataclassIncompatibleFrozenOverride
testDataclassInheritanceNoAnnotation2

# "Return type "int" of "foo" incompatible with return type "str" in supertype "B""
testPreviousErrorInDecoratedMethodOverride
testAddBaseClassMethodCausingInvalidOverride
testModifyBaseClassMethodCausingInvalidOverride
testSelfTypeBound
testMethodOverridingAcrossDeepInheritanceHierarchy2
testMethodOverridingWithVoidReturnValue
testNewNamedTupleMethodInheritance
# Signatures of "__ior__" and "__or__" are incompatible
testGenericOperatorMethodOverlapping
testGenericOperatorMethodOverlapping2
testOverlappingNormalAndInplaceOperatorMethod
testOverloadedNormalAndInplaceOperatorMethod
#  Incompatible types in assignment (expression has type "int", base class "BaseS" defined the type as "str")
testTypingSelfOverrideVarMulti
testOverrideMethodWithAttribute
testVariableSubclassAssignment
testClassAllBases
testVariableProperty
testClassSpecError
testClassStaticMethod
testClassStaticMethodIndirect
testClassMemberObject
testClassOrderOfError
testClassOneErrorPerLine
testClassIgnoreType_RedefinedAttributeAndGrandparentAttributeTypesNotIgnored
testAttributeDefOrder1
testAttributeDefOrder2
testGenericOverrideGeneric
testNamedTupleFallback
testMultipleInheritance_NestedVariableOverriddenWithIncompatibleType1
testErrorCodeAssignment
# List item 0 has incompatible type "str"; expected "int"
testVariableTypeVarList
testInWithInvalidArgs
 
# Signature of __exit__ is wrong
testWithStmtBoolExitReturnWithResultFalse
testErrorCode__exit__Return

# "Definition of "f" in base class "A" is incompatible with definition in base class "B""
# Defintition mismatch in classes lower than first classes
testGenericMultipleOverrideReplace
# method checks (variances) seem to be wrong
testMultipleInheritanceAndDifferentButCompatibleSignatures
# with decorator
testMultipleInheritanceOverridingOfFunctionsWithCallableInstances
testMixinTypedPropertyReversed
# "Cannot override class variable (previously declared on base class "A") with instance variable"
testOverrideWithNormalAttribute
# "Cannot override instance variable (previously declared on base class "A") with class variable"
testOverrideWithAttributeWithClassVar
testOverrideClassVarManyBases

# setting class attributes on self
self_instance_variable1

# verify class definitions when setting self
testInferAttributeTypeAndAssignInInit
testTypingSelfInternalSafe
testTypingSelfClashInBodies

# subclass preferred over class for types
testAddBaseClassAttributeCausingErrorInSubclass

# base class: callable
testInvalidBaseClass
# class base Any in combination with overload
testOverloadWithDerivedFromAny

# `class type` stuff
testObfuscatedTypeConstructorReturnsTypeType
testOtherTypeConstructorsSucceed
testTypeTypeComparisonWorks
# type vs type[object]
testNonTypeDoesNotMatchOverloadedFunctions
testTypeConstructorLookalikeFails
# `class type` access on class
testTypeUsingTypeCTypeAnyMemberFallback
testTypeUsingTypeCClassMethod
testTypeUsingTypeCClassMethodUnion
testTypeUsingTypeCClassMethodFromTypeVar
testTypeUsingTypeCClassMethodFromTypeVarUnionBound
testTypeUsingTypeCErrorUnsupportedType
testTypeUsingTypeCOverloadedClass
testTypeUsingTypeCTuple
testTypeUsingTypeCJoin

# __init_subclass__
testOverride__init_subclass__WithDifferentSignature
# "The return type of "__init_subclass__" must be None"
testInitSubclassWithReturnValueType
testInitSubclassWithAnyReturnValueType
testDecoratedInitSubclassWithAnyReturnValueType
testOverloadedInitSubclassWithAnyReturnValueType
testInitSubclassWrongType
testInitSubclassTooFewArgs
testInitSubclassTooFewArgs2
testInitSubclassOK
testInitSubclassWithMetaclassOK
testInitSubclassWithCustomMetaclassOK
testInitSubclassWithImports
testInitSubclassWithImportsOK
testInitSubclassUnannotated
testInitSubclassUnannotatedMulti
testTooManyArgsForObject

# __getattribute__
testGetattribute
testDecoratedGetAttribute
testGetattributeSignature

# __getattr__
testGetattr
testDecoratedGetattr
testGetattrWithCall
testGetattrSignature
testIterableUnpackingWithGetAttr
testProtocolAttrAccessDecoratedGetAttrDunder
testClassesGetattrWithProtocols

# __setattr__
testSetattr
testDecoratedSetattr
testSetattrSignature
testGetattrAndSetattr

# __slots__
testSlotsSerialization
testProtocolSlotsIsNotProtocolMember
testInvalidSlots
testSlotsDefinitionWithStrAndListAndTuple
testSlotsDefinitionWithDict
testSlotsDefinitionWithDynamicDict
testSlotsDefinitionWithSet
testSlotsDefinitionWithClassVar
testSlotsAssignmentEmptySlots
testSlotsAssignmentWithSuper
testSlotsAssignmentWithSuperDuplicateSlots
testSlotsAssignmentWithMixin
testSlotsAssignmentWithExplicitSetattr
testSlotsAssignmentWithParentSetattr
testSlotsAssignmentWithProps
testSlotsAssignmentWithMethodReassign
testSlotsAssignmentMultipleLeftValues
testSlotsAssignmentMultipleAssignments
testSlotsWithTupleCall
testSlotsWithDictCall
testSlotsWithClassVar
# dataclasses __slots__
testDataclassWithSlotsArg
testDataclassWithSlotsDef
testDataclassWithSlotsConflict
testDataclassWithSlotsArgBefore310
testDataclassWithSlotsRuntimeAttr
testSlotsDefinitionWithTwoPasses1
testSlotsDefinitionWithTwoPasses2
testSlotsDefinitionWithTwoPasses3
testSlotsDefinitionWithTwoPasses4

# "The return type of "__init__" must be None"
testConstructorWithReturnValueType
testConstructorWithAnyReturnValueType
testDecoratedConstructorWithAnyReturnValueType
testOverloadedConstructorWithAnyReturnValueType
testErrorCodeUnclassifiedError

# "Accessing "__init__" on an instance is unsound, since instance.__init__ could be from an incompatible subclass"
testAccessingInit

# Decorated constructors
testDecoratedConstructors
# "Unsupported decorated constructor type"
testDecoratedConstructorsBad

# "Cannot assign to a method"
testAssignToMethodViaInstance
testAssignToMethodViaClass
testAssignClassMethodOnClass
testAssignClassMethodOnInstance
testAssignStaticMethodOnInstance
testErrorCodeAssignToMethod
testNewAnalyzerNoCrashOnCustomProperty

# "Cannot assign to a type"
testAssignToNestedClassViaClass

# Invalid signature "Callable[[B], A]"
testReverseOperatorMethodInvalid

# Unsupported class scoped import
testClassScopeImports
testClassScopeImportModule
testClassScopeImportAlias
testClassScopeImportModuleStar
testClassScopeImportFunctionNested
testClassScopeImportUndefined
testClassScopeImportWithFollowImports
testClassScopeImportVarious
testClassScopeImportWithError
testClassScopeImportWithWrapperAndError
testImportInClassBody
testOverrideByBadVarClass
testOverrideByBadVarClassAlias
testIncrementalSilentImportsAndImportsInClass
testImportStarAddMissingDependencyWithinClass

# Unpacking a string is disallowed
testStringDisallowedUnpacking
testUnionOfNonIterableUnpacking
# List unpacking
testMultipleAssignmentWithLists
testMultipleAssignmentWithListsInInitialization
testMultipleAssignmentWithListAndIndexing
testMultipleAssignmentAndGenericSubtyping
testInferringLvarTypesInNestedListAssignment
testInferringMultipleLvarDefinitionWithListRvalue
testInferMultipleLocalVariableTypesWithArrayRvalueAndNesting
testUnpackInExpression1-only_when_nocache
testNestedListAssignment
testNestedListAssignmentToTuple
testListAssignmentFromTuple
testListWithStarExpr
# list[<nothing>] against *args or never
testOverloadVarargsSelection

# List inference unions are special (list meets)
testListLiteralWithFunctionsErasesNames
testListLiteralWithSimilarFunctionsErasesName
testListLiteralWithNameOnlyArgsDoesNotEraseNames
testLiteralMeets
testLiteralMeetsWithStrictOptional
testInferredTypeIsObjectMismatch
testNestedListExpressions
testLiteralInferredInListContext
testGenericJoinCovariant
testGenericJoinContravariant
testGenericJoinRecursiveTypes
testGenericJoinRecursiveInvariant
testGenericJoinNestedInvariantAny
testTypeEquivalentTypeAny2
testExtremeForwardReferencing

# union creation / vs. object / vs. any from ternary
testConditionalExpressionUnionWithAny
testJoinWithAnyFallback
# join callables
testCallableMeetAndJoin
# join sub and super classes
testOverloadInferUnionWithDifferingLengths
testForLoopOverTupleAndSubtyping
# join tuple iter
testMutuallyRecursiveNamedTuplesJoin
testCallerTupleVarArgsAndGenericCalleeVarArg
# tuple joins
testFixedTupleJoinVarTuple
testFixedTupleJoinList
testEmptyTupleJoin
testTupleJoinIrregular
testTupleSubclassJoinIrregular
# namedtuple joins
testNamedTupleJoinNamedTuple
testNamedTupleJoinTuple
# except join? B and C when A :> B and A :> C
testTupleValueAsExceptionType
testExceptWithMultipleTypes3
testExceptWithMultipleTypes4
testExceptWithAnyTypes
# Enum join of int | Literal[3] should lead to int
testEnumValueSomeAuto

# __setitem__
testInferOptionalDictKeyValueTypes
testIndexingAsLvalue
testInplaceSetitem
testUnionMultiassignIndexedWithError

# inplace operator methods
testInplaceOperatorMethods

# List/Set/Dict Inferring type of variable when initialized to an empty collection
testInferListInitialized*
testInferSetInitializedToEmpty
testInferSetInitializedToEmptyUsingDiscard
testInferSetInitializedToEmptyUsingUpdate
testInferDictInitialized*
testSpecialCaseEmptyListInitialization
testSpecialCaseEmptyListInitialization2
testInferListInitializedToEmptyAndAssigned
testInferOrderedDictInitializedToEmpty
testEmptyCollectionAssignedToVariableTwiceIncremental
testEmptyCollectionAssignedToVariableTwiceNoReadIncremental
testInferAttributeInitializedToEmpty*
testInferAttributeInitializedToNoneAndAssigned
testInferAttributeInitializedToNoneAndAssignedOtherMethod
testInferAttributeInitializedToNoneAndAssignedClassBody
testInferFromEmptyDictWhenUsingIn
testInferFromEmptyDictWhenUsingInSpecialCase
testInferListTypeFromInplaceAdd
testInferSetTypeFromInplaceOr
testConditionalExpressionWithEmptyListAndUnionWithAny
testConditionalExpressionWithEmptyIteableAndUnionWithAny
testLiteralFinalErasureInMutableDatastructures2
testInferNonOptionalListType
testInferNonOptionalDictType

# OrderedDict = _Alias()
testTypingExtensionsOrderedDictAlias

# Type Var Value in func
testCheckGenericFunctionBodyWithTypeVarValues
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testTypeVarValuesAndNestedCalls
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testTypevarValuesSpecialCase1
testGenericTypeAliasesTypeVarConstraints
testWideOuterContextValuesOverlapping
testTypevarValuesWithOverloadedFunctionSpecialCase
testReferenceToDecoratedFunctionAndTypeVarValues
testLiteralAndGenericsRespectsValueRestriction
testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2
testTypingSelfWithValuesExpansion
testOverloadingInferUnionReturnWithTypevarsAndValueRestrictions
testColumnFunctionWithTypeVarValues
testSuperWithTypeVarValues1
testSuperWithTypeVarValues2
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues
testNestedDecoratedCoroutineAndTypeVarValues
testAnyStr
testTypeVarWithTypedDictValueInIndexExpression

# Callable[..., int] | Callable[..., str] lambda inference may conflict
testOptionalLambdaInference

# Overload needs type var matcher probably (and maybe also overlapping)
overload_class_type_var_implementation_match_and_mismatch

# - Overload does not consistently use the "@classmethod" decorator on all function signatures
# - Overload does not consistently use the "@staticmethod" decorator on all function signatures
testOverloadWithInconsistentStaticMethods
# - Condition cannot be inferred, unable to merge overloads
testOverloadIf*
# Overloads are detected in name binder (imports can not be there)
testVeryBrokenOverload
testVeryBrokenOverload2
# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2
# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload

# @final
testFinalAddFinalMethodOverrideFine
testFinalAddFinalMethodOverrideWithVarFine
testFinalAddFinalMethodOverrideOverloadFine
testFinalAddFinalPropertyWithVarFine
testFinalBodyReprocessedAndStillFinal
testFinalBodyReprocessedAndStillFinalOverloaded-only_when_cache
testFinalBodyReprocessedAndStillFinalOverloaded2-only_when_nocache
testTypingSelfAllowAliasUseInFinalClasses
testFinalClassWithAbstractAttributes
testFinalClassWithoutABCMeta
testFinalClassInheritedAbstractAttributes
testEnumExplicitlyAndImplicitlyFinal
testCannotSubclassFinalTypedDict
testCannotSubclassFinalTypedDictWithForwardDeclarations
# Final: "Cannot assign to final name "x""
testNewAnalyzerFinalReassignModuleReexport
testNewAnalyzerFinalOverrideInSubclass
testFinalAddFinalVarAssignFine
testFinalAddFinalVarOverrideFine
testNewAnalyzerFinalReassignModuleVar
testLiteralFinalMismatchCausesError
testFinalAddFinalVarAssign
testFinalAddFinalVarOverride
# Final: "Cannot override final attribute "meth" (previously declared in base class "C")"
testFinalAddFinalMethodOverride
# Final literal issues
testLiteralWithFinalPropagation
testLiteralWithFinalPropagationIsNotLeaking
testEnumCreatedFromFinalValue
# "Cannot inherit from final class "bool""
testCannotExtendBoolUnlessIgnored

# Conditional definitions
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionalFuncDefer
testNewAnalyzerConditionallyDefineFuncOverVar
testRedefineFunctionDefinedAsVariableInitializedToNone
testRedefineNestedFunctionDefinedAsVariableInitializedToNone
testConditionalFunctionDefinitionUsingDecorator2
testConditionalFunctionDefinitionUnreachable

# All conditional function variants must have identical signatures
testIncompatibleConditionalFunctionDefinition
testIncompatibleConditionalFunctionDefinition2
testIncompatibleConditionalFunctionDefinition3
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition1
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition2
testIncompatibleConditionalMethodDefinition

# TYPE_CHECKING
testIfTypeCheckingUnreachableClass
# --always-true TRUTH
testIfConditionsInDefinition
testAlwaysTrueAlwaysFalseFlags

# if sys.version
testNewAnalyzerVersionCheck
testNewAnalyzerVersionCheck2
testPromoteMemoryviewToBytes
testDataclassesBadInit
testDataclassFieldDoesNotFailOnKwargsUnpacking
# NamedTuple magic attribute __match_args__ in py >= 3.10
testNamedTupleHasMatchArgs

# callable()
testFineGrainedCallable
testSerializeDummyType

# Except Foo as bar where bar is bound over its existence as a variable
testTryStarMultiple
# with scoping is special
testWithStmtScopeBasics
testWithStmtScopeNestedWith1
testWithStmtScopeNestedWith2
testWithStmtScopeInnerAndOuterScopes
testWithStmtScopeMultipleContextManagers
testWithStmtScopeMultipleAssignment
testWithStmtScopeComplexAssignments
testWithStmtScopeAndClass
testWithStmtScopeAndLambda

# isinstance
testLiteralErrorsWithIsInstanceAndIsSubclass
# isinstance narrowing
testUnionGenericWithBoundedVariable
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues2
testTypeCheckOverloadImplementationTypeVarWithValueRestriction
testTypeCheckOverloadImplementationTypeVarDifferingUsage1
testIntersectionUsingPromotion1
testIntersectionUsingPromotion2
testIntersectionUsingPromotion3
testIntersectionUsingPromotion4
testIntersectionUsingPromotion5
testIntersectionUsingPromotion6
testIntersectionUsingPromotion7
testIntersectionUsingPromotion8
testCorrectIsinstanceWithForwardUnion
testNewTypeWithIsInstanceAndIsSubclass
testNarrowingDownNamedTupleUnion
testRecursiveAliasViaNamedTuple
testSimpleIsinstance
testSimpleIsinstance2
testSimpleIsinstance3
testMultipleIsinstanceTests
testMultipleIsinstanceTests2
testIsinstanceAndElif
testIsinstanceAndAnyType
testIsinstanceAndGenericType
testTupleMeetTupleAny
testTupleMeetTupleAnyComplex
testTupleMeetTupleAnyAfter
testNamedTupleSubclassMulti
testNarrowSelfType
testRuntimeIterableProtocolCheck
testColumnsSimpleIsinstance
testTypeshedRecursiveTypesExample
testTypedDictIsInstance
testTypedDictIsInstanceABCs
# issubclass narrowing
testIsInstanceTypeIsSubclass
testIsInstanceTypeTypeVar
testIsInstanceTypeSubclass
testIsSubClassNarrowDownTypesOfTypeVariables
# "Cannot use isinstance() with TypedDict type"
testTypedDictWithIsInstanceAndIsSubclass
# isinstance & union
testUnion1
testUnion2
testUnion3
testUnionAnyIsInstance
testNestedUnionsProcessedCorrectly
testGenericTypeAliasesUnion
testOverloadsIgnorePromotions
testParamSpecLiteralJoin
testUnionOrSyntaxInIsinstance
testUnionOrSyntaxInIsinstanceNotSupported
# --enable-recursive-aliases & isinstance
testRecursiveAliasBasic
testRecursiveAliasesRestrictions
testRecursiveAliasesRestrictions2
testRecursiveAliasBasicGenericInference
testRecursiveAliasNewStyleSupported
#  --enable-recursive-aliases & is not None
testTupleTypeUpdateNonRecursiveToRecursiveFine
testTypeAliasUpdateNonRecursiveToRecursiveFine
# narrowing if with literals
testConditionalBoolLiteralUnionNarrowing
testRecursiveAliasTuple
# narrowing optional with if
testOptionalTypeNarrowedByGenericCall
testOptionalTypeNarrowedByGenericCall2
testOptionalTypeNarrowedByGenericCall3
testOptionalTypeNarrowedByGenericCall5
testOptionalTypeNarrowedInBooleanStatement
testIsinstanceCases
testIfCases
testIfNotCases
testIsNotNoneCases
testIsNoneCases
testAnyCanBeNone
testOrCases
testAndCases
testOptionalAssignAny1
testOptionalAssignAny2
testOptionalAssignAny3
testInferEqualsNotOptional
testInferEqualsNotOptionalWithUnion
testInferEqualsNotOptionalWithOverlap
testInferEqualsStillOptionalWithNoOverlap
testInferEqualsNotOptionalWithMultipleArgs
testTernaryWithNone
testNoneListTernary
testIsinstanceAndOptionalAndAnyBase
testGenericTypeAliasesOptional
testCastConfusion
testBasicRecursiveNamedTuple
testBasicRecursiveNamedTupleSpecial
testBasicRecursiveNamedTupleClass
testNamedTupleUpdateNonRecursiveToRecursiveFine
testTupleOverlapDifferentTuples
testUnpackUnionNoCrashOnPartialNone
testUnpackUnionNoCrashOnPartialNone2
testNamedTupleUpdateNonRecursiveToRecursiveCoarse
testTupleTypeUpdateNonRecursiveToRecursiveCoarse
testTypeAliasUpdateNonRecursiveToRecursiveCoarse
testTypedDictUpdateNonRecursiveToRecursiveCoarse
testNarrowedVariableInNestedFunctionBasic
testNarrowedVariableInNestedFunctionMore1
testNarrowedVariableInNestedFunctionMore2
testAliasRecursiveUnpackMultiple
testNarrowOnSelfInGeneric
testNarrowedVariableInNestedModifiedInWalrus
testTypedDictTypeNarrowingWithFinalKey
# narrowing if is
testEnumReachabilityChecksBasic
testEnumReachabilityChecksWithOrdering
testEnumReachabilityChecksIndirect
testEnumReachabilityWithNone
testEnumReachabilityWithMultipleEnums
testEnumReachabilityPEP484ExampleWithFinal
testEnumReachabilityPEP484ExampleWithMultipleValues
testEnumReachabilityPEP484ExampleSingleton
testEnumReachabilityPEP484ExampleSingletonWithMethod
testEnumReachabilityWithChaining
testEnumReachabilityWithChainingDisjoint
testEnumReachabilityWithChainingDirectConflict
testEnumReachabilityWithChainingBigDisjoints
testEnumNarrowedToTwoLiterals
# narrowing with or/and
testRestrictedTypeAnd
testRestrictedTypeOr
testRestrictedBoolAndOrWithGenerics
testOptionalTypeOrTypeBothOptional
testOptionalTypeOrTypeComplexUnion
testOptionalTypeOrTypeNoTriggerPlain
testOptionalTypeOrTypeNoTriggerTypeVar
testInvalidBooleanBranchIgnored
testOptionalTypeOrTypeTypeVar
testNoneOrStringIsString
testNoneOrTypeVarIsTypeVar
testNoneAndStringIsNone
testInferInWithErasedTypes
testUnionTruthinessTracking
testRegression11705_Strict
testRegression11705_NoStrict
testBinaryOperationsWithDynamicLeftOperand
testBinaryOperationsWithDynamicAsRightOperand
# or/and
testBooleanAndOr
testNonBooleanOr
# narrowing with assert
testNarrowOptionalOutsideLambda
testNarrowOptionalOutsideLambdaWithDeferred
testIsInstanceTypeVsUnionOfType
testIsInstanceTypeByAssert
testIsInstanceTypeVsMetaclass
testIsInstanceAdHocIntersectionIncrementalNoChange
testIsInstanceAdHocIntersectionIncrementalNoChangeSameName
testIsInstanceAdHocIntersectionIncrementalNoChangeTuple
testIsInstanceAdHocIntersectionIncrementalIsInstanceChange
testIsInstanceAdHocIntersectionIncrementalUnderlyingObjChang
testIsInstanceAdHocIntersectionIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionIncrementalUnreachaableToIntersection
testGenericPatterns
testGenericMatch
testTypedDictUpdate3
# narrowing with in
testOperatorContainsNarrowsTypedDicts_unionWithList
testOperatorContainsNarrowsTypedDicts_total
testOperatorContainsNarrowsTypedDicts_partialThroughTotalFalse
testOperatorContainsNarrowsTypedDicts_partialThroughNotRequired
# General assert
testFastParseMalformedAssert
testFastParseAssertMessage
# narrowing assignments
testNarrowingFromObjectToOptional
testDynamicWithMemberAccess
testTupleCompatibleWithSequence
testTupleInstanceCompatibleWithIterable
testTupleTypeCompatibleWithIterable
testAugmentedAssignmentIntFloat
testAugmentedAssignmentIntFloatMember
testAugmentedAssignmentIntFloatDict
testUnionMultiassignRebind
testUnionMultiassignAlreadyDeclared
testUnionMultiassignPacked
testUnpackUnionNoCrashOnPartialNoneBinder
testNestedUnionUnpackingFromNestedTuplesBinder
testUnionUnpackingDoubleBinder
testExceptionVariableReuseInDeferredNode4
testExceptionVariableReuseInDeferredNode5
testExceptionVariableReuseInDeferredNode6
testSerializeNamedTuple
testDataclassesInitVars
# narrowing with dict keys
testNarrowTypeForDictKeys

# None late binding, because it's None (x = None; x = 3)
*PartialType*
testAssigningAnyStrToNone
testLocalVariablePartiallyInitializedToNone
testLocalVariablePartiallyTwiceInitializedToNone
testGvarPartiallyInitializedToNone
testPartiallyInitializedToNone*
testPartiallyInitializedVariableDoesNotEscapeScope2
testAttributePartiallyInitializedToNoneWithMissingAnnotation
testGlobalInitializedToNoneSetFromFunction
testGlobalInitializedToNoneSetFromMethod
testNoCrashOnPartialVariable
testNoCrashOnPartialVariable3
testInferOptionalType
testInferOptionalTypeLocallyBound
testInferOptionalAnyType
testInferOptionalTypeFromOptional
testDeferredAndOptionalInferenceSpecialCase
testInheritedAttributeNoStrictOptional
testIncompatibleInheritedAttributeNoStrictOptional
testInheritedAttributeStrictOptional
testIgnoreTypeInferenceError2

# Weird Name binder type definitions (overwritten?)
testLiteralBinderLastValueErased
# weird narrowing
testInferredTypeIsSimpleNestedList
testInferredTypeIsSimpleNestedIterable
testInferredTypeIsSimpleNestedListLoop
testInferredTypeIsSimpleNestedIterableLoop
testNarrowingDownFromPromoteTargetType
testNarrowingDownFromPromoteTargetType2
testNewAnalyzerBuiltinAliasesFixed
testAssignAnyToUnionWithAny
testOverloadsAndNoReturnNarrowTypeNoStrictOptional1
testOverloadsAndNoReturnNarrowTypeWithStrictOptional1
testOverloadsAndNoReturnNarrowTypeNoStrictOptional2
testOverloadsAndNoReturnNarrowTypeWithStrictOptional2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional3
testOverloadsAndNoReturnNarrowTypeWithStrictOptional3
# Maybe not even narrowing?
testRefreshImportIfMypyElse1

# TypeGuard
testSerializeTypeGuardFunction
testTypeGuardWithPositionalOnlyArg
testTypeGuardKeywordFollowingWalrus
testWalrusTypeGuard

# Function local self attribute name binding
testOptionalDescriptorsBinder
testUnionDescriptorsBinder
testSubclassDescriptorsBinder
testPropertyGetterBody
# Use x instead of self as first argument (probably name binding issue)
testNonStandardNameForSelfAndInit

# All conditional function variants must have identical signatures (flow analysis)
testUnionOrderEquivalence

# flow graph
testAssignAndConditionalImport
testAssignAndConditionalStarImport
testRedefineImportedFunctionViaImport
testImportedVariableViaImport

# Multi definition ifs
testNewAnalyzerFirstAliasTargetWins
testNewAnalyzerFirstVarDefinitionWins
testOptionalBackwards1
testOptionalBackwards2
testOptionalBackwards3
testOptionalBackwards4
# Multi definition name binder issues where essentially the same type is defined?
testOverrideByIdemAliasReversed
testOverrideByIdemAliasGeneric
testOverrideByIdemAliasImported
testConditionalExceptionAliasOverride

# Multiple arguments missing
testMissingPositionalArguments

# Intersection types
testIsInstanceAdHocIntersectionFineGrainedIncrementalNoChange
testIsInstanceAdHocIntersectionFineGrainedIncrementalIsInstanceChange
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnderlyingObjChang
testIsInstanceAdHocIntersectionFineGrainedIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnreachaableToIntersection
testIsInstanceAdHocIntersectionWithStrAndBytes

# "Name "C" is used before definition"
testNewAnalyzerNewTypeForwardClassAliasReversed
# undefined += 1 where undefined is a NameError
testOperatorAssignment
inplace_operator_on_undefined_target
testInvalidDel3

# Import Redefinition
testRedefineTypeViaImport
# Redefinition (Name "X" already defined on line X)
testGlobalVarRedefinition
testLocalVarRedefinition
testClassVarRedefinition
testMultipleClassDefinitions
testMultipleMixedDefinitions
testMultipleMethodDefinition
testMultipleNestedFunctionDef
testRedefineVariableAsTypevar
testRedefineTypevar
testRedefineTypevar2
testRedefineTypevar3
testRedefineTypevar4
testImportTwoModulesWithSameNameInFunction
testImportTwoModulesWithSameNameInGlobalContext
testTypeRedeclarationNoSpuriousWarnings
testDuplicateDef*
testTypeVarClassDup
testAliasDup
testImportFuncDup
testIgnoredImportDup
testNewAnalyzerRedefinitionAndDeferral*
testNewAnalyzerImportStarForwardRef*
testNewAnalyzerImportOverExistingInCycle
testNewAnalyzerImportOverExistingInCycleStar1
testNewAnalyzerImportOverExistingInCycleStar2
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionallyDefineFuncOverClass
testNewAnalyzerMissingImportErrors
testNewAnalyzerMissingImportErrorsRedefinition
testNewAnalyzerDuplicateTypeVar
testNewAnalyzerDuplicateTypeVarImportCycle
testNewAnalyzerDuplicateTypeVarImportCycleWithAliases
testNewAnalyzerRedefineAsClass
testNewAnalyzerOverrideClassWithTypeAlias
testNewAnalyzerIdentityAssignment*
testProhibitReassigningAliases
testProhibitReassigningSubscriptedAliases
testProhibitReassigningGenericAliases
testUnknownModuleRedefinition
testStarImportOverlappingMismatch
testStarImportOverridingLocalImports
testRedefineFunctionViaImport
testDifferentImportSameNameTwice
testNewAnalyzerRedefineAsOverload
testImportOnTopOfAlias1
testImportOnTopOfAlias2
testUnconditionalRedefinitionOfConditionalFunction
testUnconditionalRedefinitionOfConditionalMethod
testRedefineFunction2
testMissingOverloadDecorator
testDecoratedRedefinitionIsNotOverload
testMultipleClassDefinition
testMemberRedefinition
testMemberRedefinitionDefinedInClass
testDecorateOverloadedFunction
testErrorCodeAlreadyDefined
testNewAnalyzerEnumRedefinition
testNewSyntaxBasics
testDecoratedClassLine
testDataclassesInheritingDuplicateField
# redefinition overload
testRedefinedOverloadedFunction
testFakeOverloadCrash
testFakeOverloadCrash2
testOverloadNotImportedNoCrash
testSingleOverload2
testCustomRedefinitionDecorator
# Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation
testAliasesInClassBodyNormalVsSubscripted
# Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2
# Incompatible redefinition (redefinition with type "Callable[[Any], Any]", original type "Callable[[], Any]")
testRedefineFunctionDefinedAsVariableWithInvalidSignature
testRedefinedFunctionInTryWithElse
# Incompatible redefinition
testRedefineFunctionDefinedAsVariableInitializedToEmptyList
# NewType Redefinition
testNewAnalyzerNewTypeRedefinition
testNewTypeRedefiningVariablesFails

# except redefinition
testExceptionVariableReuseInDeferredNode1
testExceptionVariableReuseInDeferredNode2
testExceptionVariableReuseInDeferredNode3

# Invalid type comment or annotation, because of weird annotations
testFastParseTypeCommentSyntaxError
testFastParseFunctionAnnotationSyntaxError
testFastParseFunctionAnnotationSyntaxErrorSpaces
testFastParseInvalidFunctionAnnotation

# "Value of type "A" must be used"
# "Value of type "Coroutine[Any, Any, None]" must be used"
# "Are you missing an await?"
# --enable-error-code unused-awaitable
testUnusedAwaitable
testForwardRefToBadAsyncShouldNotCrash_newsemanal
# async await when is a generator comprehension becoming an asyncgenerator?
testAsyncGeneratorExpressionAwait
testAsyncForComprehension
# Crazy types.coroutine types
testFullCoroutineMatrix

# "Trying to read deleted variable "Foo""
testDelStmtWithTypeInfo
testDelStatementWithAssignmentSimple
testDelStatementWithAssignmentTuple
testDelStatementWithAssignmentList
testDelStatementWithConditions
testDel
testReuseTryExceptionVariable
testReuseDefinedTryExceptionVariable
testRaiseFromStatement

# match statement
testValuePattern
testCapturePattern
testCapturePatternOutliving
testNestedCapturePatterns
testMappingPatternRest
testAsPattern
testGuard
testCapturePatternInGuard
testAsPatternInGuard
testMatchUndefinedSubject
testMatchUndefinedValuePattern
testMatchUndefinedClassPattern
testNoneBindingWildcardPattern
testNoneBindingStarredWildcardPattern

# "Cannot determine type of"
testThreePassesRequired
testAccessGlobalVarBeforeItsTypeIsAvailable
testAccessDataAttributeBeforeItsTypeIsAvailable
testMultipassAndTopLevelVariable
testMultipassAndCircularDependency
testForwardReferenceToDecoratedClassMethod
testAccessingClassAttributeWithTypeInferenceIssue
testClassObjectsNotUnpackableWithoutIterableMetaclass
testErrorCodeCannotDetermineType
testCannotDetermineTypeFromOtherModule
testColumnCannotDetermineType
# "Cannot determine type of "X" in base class"
testCannotDetermineTypeInMultipleInheritance

# {**kwargs}
testSubtypingMappingUnpacking1
testSubtypingMappingUnpacking2
testSubtypingMappingUnpacking3
testNotDirectIterableAndMappingSubtyping
testUnpackInExpression3-only_when_nocache
functional_enum_starred_dict_literal_errors
testDictWithStarStarSpecialCase

# "Missing return statement"
testWarnNoReturnWorksWithStrictOptional
testAssertCurrentFrameIsNotUnreachable
testNoReturnInGenerator
testWithStmtBoolExitReturnOkay
testErrorCodeMissingReturn
testDedicatedErrorCodeForEmpty_no_empty
testEmptyBodyProhibitedFunction
testEmptyBodyProhibitedMethodNonAbstract
testEmptyBodyProhibitedPropertyNonAbstract
testEmptyBodyNoteABCMeta
testAsyncDefMissingReturn
testUnreachableWithStdlibContextManagers
testNoReturn
testNoReturnWhile
testNoReturnExcept
# "Use "-> None" if function does not return a value"
testDecoratedFunctionLine
testUntypedDef
testUnannotatedReturnWithOnlySelfArgument
testUntypedAsyncDef

# "Cannot call function of unknown type"
testUnknownFunctionNotCallable

# "Return value expected"
testReturnWithoutAValue
testEmptyReturnInGenerator
testErrorCodeMissingReturnValueInReturnStatement
testColumnReturnValueExpected
testAsyncDefReturnWithoutValue

# "No return value expected"
testNonEmptyReturnInNoneTypedGenerator
testErrorCodeReturnValueNotExpected

# Implicit any param
testKwargsArgumentInFunctionBodyWithImplicitAny

# "Decorators on top of @property are not supported"
testDecoratedProperty

# function type mismatch when untyped
testSubtypingFunctionsImplicitNames
# typing.assert_type in untyped functions
testAssertTypeUncheckedFunction
testAssertTypeUncheckedFunctionWithUntypedCheck
# untyped (inferred?) instance attributes
testChangeBaseClassAttributeType
testCheckUntypedDefsSelf2

# Global
testAssignToFuncDefViaGlobalDecl2
testTypeOfGlobalUsed
testGlobalWithoutInitialization

# Nonlocal
testInvalidNonlocalDecl
testNonlocalDeclNotMatchingGlobal
testNonlocalDeclConflictingWithParameter
testNonlocalDeclOutsideFunction
testGlobalAndNonlocalDecl
testNonlocalAndGlobalDecl
testNewAnalyzerRedefinedNonlocal
testTypeOfOuterMostNonlocalUsed
testTypeOfNonlocalUsed

# slice type checking
testNonIntSliceBounds

# __init__ None needed
testInitReturnTypeError

# Need type annotation for "X"
testNewAnalyzerLessErrorsNeedAnnotation
testNewAnalyzerLessErrorsNeedAnnotationNested
testErrorInTypeCheckSecondPassThroughPropagation
testGenericFunctionOnReturnTypeOnly
testUnderspecifiedInferenceResult
testNoCrashOnPartialMember
testDontMarkUnreachableAfterInferenceUninhabited
testDontMarkUnreachableAfterInferenceUninhabited2
testDontMarkUnreachableAfterInferenceUninhabited3
testNeedAnnotationForCallable
testPartialDefaultDict*
testInferenceOfFor1
testInferenceOfFor2
testInferenceOfFor3
testInferLocalVariableTypeWithUnderspecifiedGenericType
testLocalVariableInferenceFromEmptyList
testNoPartialInSupertypeAsContext
testSuggestPep604AnnotationForPartialNone
testSelfTypeRestrictedMethodOverloadInitFallBacks
testOverridePartialAttributeWithMethod
testInheritanceAndAttributeAssignment
testAssignmentToAttributeInMultipleMethods
testAccessingClassAttributeWithTypeInferenceIssue2
testTypeAnnotationNeededMultipleAssignment
testAssignmentToStarMissingAnnotation
testForLoopOverEmptyTuple
testTupleWithoutContext
testReusingInferredForIndex2
testErrorCodeNeedTypeAnnotation
testColumnNeedTypeAnnotation

# Formatting better verbosity
testDistinctTypes
# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames

# "Perhaps you need a type annotation for "x"? Suggestion: "List[str | int]""
testInferredTypeSubTypeOfReturnType

# Module __getattr__
testNewAnalyzerModuleGetattrSerialize_incremental
testModuleLevelGetattr*
testModuleGetattr*
testModuleGetAttr*
testGetAttrImportAnnotation
testGetAttrImportBaseClass
testGetAttrDescriptor
testIncrementalNodeCreatedFromGetattr
testAddedMissingStubsPackagePartialGetAttr
testFineAddedMissingStubsPackagePartialGetAttr

# __get__/__set__ not callable
testDescriptorUncallableDunderGet
testDescriptorUncallableDunderSet

# attrs
testAttrs*
updateMagicField
magicAttributeConsistency
magicAttributeConsistency2-only_when_cache

# Special case for assignment to '_'
testUnusedTargetLocal
testUnusedTargetNotClass
testUnusedTargetNotClass2
testUnusedTargetTupleUnpacking
testUnusedTargetMultipleTargets
testUnusedTargetNotImport
testUnderscoreClass
testUnusedTargetForLoop
testUnusedTargetWithClause
testUnusedTargetNotExceptClause

# weird files
testScriptsAreNotModules

# __doc__ definitions
testNewNamedTupleDocString

# Aliases in Mypy define generics as X = Foo as Foo[Any, Any]
testAliasToTupleAndCallable

# Formatting Module as types ("ModuleType" instead of Module)
testInvalidOperationsOnModules
testConditionalImportAndAssignInvalidToModule
testModuleAliasRepeatedWithAnnotation

# qualified name in function contains class path: __main__.Cls.FooEnum@4
testAnonymousFunctionalEnum
# qualified name for NewType for different module
testNewTypeInMultipleFiles
# qualified name for Enum for different module
testLiteralWithEnumsSimilarDefinitions
# NewType formatting instead of internal type
testNewTypeDependencies3

# Formatting C.__init__() call as "C" instead of "__init__" of "C"
testInitMethodUnbound

# tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same error twice
testOperatorAssignmentWithIndexLvalue1

# EllipsisType
testUnionWithEllipsis
# Ellipsis / raise NotimplementedError / pass are considered stubs in normal files 
testEllipsisDefaultArgValueInNonStub
testEllipsisDefaultArgValueInNonStubsMethods

# NotImplemented
testOperatorMethodAgainstSameType

# The type "Type[type]" is not generic and not indexable
testTypeApplicationCrash

# "bool" is not a valid base class
testTestExtendPrimitives

# Probably fixed eventually by updating mypy or typeshed
testDecoratorTypeAfterReprocessing

# type ignore whole module
testIgnoreWholeModule2
testIgnoreWholeModule3
testIgnoreWholeModule4
testDontIgnoreWholeModule2
testDontIgnoreWholeModule3
# type ignore leads to "Revealed type is "A?""
testSerializeIgnoredInvalidType
# bad type: ignore
testErrorCodeBadIgnore
testErrorCodeBadIgnoreNoExtraComment
# --disable-error-code
testUncheckedAnnotationSuppressed
testMethodAssignmentSuppressed
testMethodAssignCoveredByAssignmentFlag
testIncrementalInvalidNamedTupleInUnannotatedFunction
testDisableErrorCode
testDisableMultipleErrorCode
# --enable-error-code
testEnableDifferentErrorCode
testEnableMultipleErrorCode
# --warn-unused-ignores
# "Unused "type: ignore" comment"
testErrorCodeWarnUnusedIgnores1
testErrorCodeWarnUnusedIgnores2
testErrorCodeWarnUnusedIgnores3
testErrorCodeWarnUnusedIgnores4
testErrorCodeWarnUnusedIgnores5
testErrorCodeWarnUnusedIgnores6_NoDetailWhenSingleErrorCode
testMethodAssignCoveredByAssignmentUnused
testUnusedIgnoreTryExcept
testUnusedIgnoreEnableCode
testIgnoreDecoratedFunction1
testIgnoreScopeUnused1
testIgnoreScopeUnused2
testIgnoreScopeUnused3
testUnusedIgnoreVersionCheck
testUnusedTypeIgnore
testUnusedTypeIgnoreImport
# --warn-unused-ignores whole module
testIgnoreWholeModule1
testImportUnusedIgnore2
# --enable-error-code ignore-without-code
testErrorCodeMissingWhenRequired
testErrorCodeMissingDoesntTrampleUnusedIgnoresWarning
testErrorCodeMissingWholeFileIgnores
testErrorCodeMissingMultiple
# type: ignore blocking errors cannot be ignored: ""yield" outside function"
testCannotIgnoreBlockingError
# type: ignore on forward reference
testErrorCodeSyntaxErrorIgnoreNote
# mypy: ignore-errors=True
testAsyncIteratorWithIgnoredErrorsAndYieldFrom

# Very weird annotation resolution order
testNewAnalyzerAnnotationConflictsWithAttributeSinglePass
testNewAnalyzerAnnotationConflictsWithAttributeTwoPasses
testNewAnalyzerNameConflictsAndMultiLineDefinition

# pyproject.toml
testMultipleModulesInOverridePyProjectTOML
testIgnoreErrorFromMissingStubs1
testIgnoreErrorFromMissingStubs2
testCaseInsensitivityDirPyProjectTOML
testPreferPackageOverFileCasePyProjectTOML
testClassicPackageInsideNamespacePackageCasePyProjectTOML
testIncrementalFollowImportsVariablePyProjectTOML
testNamespacePackageWithMypyPathPyProjectTOML
testNamespacePackagePickFirstOnMypyPathCasePyProjectTOML
testPerFileIncompleteDefsBasicPyProjectTOML
testPerFileStrictOptionalBasicPyProjectTOML
testPerFileStrictOptionalBasicImportStandardPyProjectTOML
testPerFileStrictOptionalBasicImportOptionalPyProjectTOML
testPerFileStrictOptionalListItemImportOptionalPyProjectTOML
testPerFileStrictOptionalNoneArgumentsPyProjectTOML
testAlwaysTrueAlwaysFalseConfigFilePyProjectTOML
testDisableErrorCodeConfigFilePyProjectTOML
testStrictInConfigAnyGenericPyProjectTOML
testStrictFalseInConfigAnyGenericPyProjectTOML
testStrictEqualityPerFilePyProjectTOML
testNoImplicitReexportPyProjectTOML
testDisallowSubclassingAnyPyProjectTOML
testNoImplicitOptionalPerModulePyProjectTOML

# mypy.ini
testRefreshIgnoreErrors1
testRefreshIgnoreErrors2
testRefreshOptions
testCaseInsensitivityDir
testPreferPackageOverFileCase
testClassicPackageInsideNamespacePackageCase
testShowErrorCodesInConfig
testIncrementalFollowImportsVariable
testRegularUsesFgCache
testFgCacheNeedsFgCache
testIncrementalPerFileFlags
testClassicPackageIgnoresEarlierNamespacePackage
testClassicPackageInsideNamespacePackage
testNamespacePackageWithMypyPath
testNamespacePackagePickFirstOnMypyPath
testNamespacePackageInsideClassicPackage
testNamespacePackagePickFirstOnMypyPathCase
testTypedPkgNoSitePkgsIgnoredImports
testTypedPkg_config_nositepackages
testPerFileIncompleteDefsBasic
testPerFileStrictOptionalBasic
testPerFileStrictOptionalBasicImportStandard
testPerFileStrictOptionalBasicImportOptional
testPerFileStrictOptionalListItemImportOptional
testPerFileStrictOptionalNoneArguments
testAlwaysTrueAlwaysFalseConfigFile
testDisableErrorCodeConfigFile
testStrictInConfigAnyGeneric
testStrictFalseInConfigAnyGeneric
testStrictEqualityPerFile
testNoImplicitReexportMypyIni
testDisallowSubclassingAny
testNoImplicitOptionalPerModule
testDisallowUntypedCallsAllowListConfig
testPerModuleErrorCodes
testPerModuleErrorCodesOverride
testNoCrashFollowImportsForStubs
# Uses an environment variable in mypy.ini files=$MYPY_CONFIG_FILE_DIR/good.py
testEnvvar_MYPY_CONFIG_FILE_DIR

# Mypy plugins
testChangedPluginsInvalidateCache
testChangedPluginsInvalidateCache2
testAddedPluginsInvalidateCache
testRemovedPluginsInvalidateCache
testPluginConfigData
testIncrementalAddClassMethodPlugin

# Mypy inline config https://mypy.readthedocs.io/en/stable/inline_config.html
testOptionalIterator
testNoneVsProtocol

# strict optional with config file
testNewAnalyzerTypeArgBoundCheckWithStrictOptional
testNewAnalyzerTypeArgBoundCheckWithStrictOptionalPyProjectTOML
testPerFileStrictOptionalModule
testPerFileStrictOptionalModuleOnly
testPerFileStrictOptionalFunction
testPerFileStrictOptionalMethod
testStrictOptionalCovarianceCrossModule

# mypy extensions
testFlexibleAlias1
testFlexibleAlias2
testFlexibleAlias3

# flags: --warn-redundant-casts
# "Redundant cast to "int""
testErrorCodeRedundantCast
testColumnRedundantCast
testRedundantCast
testRedundantCastWithIsinstance

# enable-error-code="redundant-self"
# "Redundant "Self" annotation for the first method argument"
testTypingSelfRedundantWarning
testTypingSelfRedundantWarning_pep585

# --strict-equality strict equality
testStrictEqualityEq
testStrictEqualityIs
testStrictEqualityContains
testStrictEqualityUnions
testStrictEqualityNoPromotePy3
testStrictEqualityEqNoOptionalOverlap
testCustomEqCheckStrictEquality
testCustomEqCheckStrictEqualityTuple
testCustomEqCheckStrictEqualityMeta
testCustomContainsCheckStrictEquality
testStrictEqualityTypeVsCallable
testStrictEqualityMetaclass
testStrictEqualityWithALiteral
testStrictEqualityWithALiteralNewType
testStrictEqualityWithFixedLengthTupleInCheck
testStrictEqualityBytesSpecialUnion
testErrorCodeNonOverlappingEquality
testColumnNonOverlappingEqualityCheck
testStrictEqualityAndEnumWithCustomEq
testStrictEqualityAllowlist
testStrictEqualitywithParamSpec
testTypedDictOverlapWithDictNonOverlapping
testTypedDictOverlapWithDictNonTotalNonOverlapping
testTypedDictOverlapWithDictEmpty
testStrictAndStrictEquality

# --show-column-numbers and tuple targets
testColumnsAssignment
# --show-error-end
testCheckEndColumnPositions

# "type ignore with error code is not supported for modules; use `# mypy: disable-error-code="whatever"`"
testNoteAboutChangedTypedDictErrorCode
testRecommendErrorCode
testRecommendErrorCode2

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext
testShowErrorContextFunction
testShowErrorContextClass
testShowErrorContextMember
testShowErrorContextModule
testShowErrorContextTopLevel
testShowErrorContextFromHere

# --allow-untyped-globals
testPermissiveAttributeOverride1

# --allow-redefinition
testStarLvalues
testRenameGlobalVariable
testNoRenameGlobalVariable
testCannotRenameExternalVarWithinClass

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testUnlimitedStubErrorVolume
testDisallowAnyExprIncremental
testDisallowAnyExprSimple
testDisallowAnyExprExplicitAnyParam
testDisallowAnyExprAllowsAnyInCast
testDisallowAnyExprAllowsAnyInVariableAssignmentWithExplicitTypeAnnotation
testDisallowAnyExprGeneric

# --disallow-any-generics
testErrorReportingNewAnalyzer
testErrorCodeMissingTypeArg
testColumnMissingTypeParameters
testUnpackGenericTypedDictImplicitAnyDisabled
testCheckDisallowAnyGenericsNamedTuple
testCheckDisallowAnyGenericsTypedDict
testCheckDisallowAnyGenericsStubOnly
testCheckDisallowAnyGenericsAnyGeneric
testStrictAnyGeneric
testImplicitAnyOKForNoArgs
testDisallowAnyGenericsTupleNoTypeParams
testDisallowAnyGenericsTupleWithNoTypeParamsGeneric
testDisallowAnyGenericsTypeType
testDisallowAnyGenericsAliasGenericType
testDisallowAnyGenericsGenericAlias
testDisallowAnyGenericsPlainList
testDisallowAnyGenericsCustomGenericClass
testDisallowAnyGenericsForAliasesInRuntimeContext

# --disallow-any-unimported
testErrorCodeAnyFromUnfollowedImport
testDisallowImplicitTypesIgnoreMissingTypes
testDisallowImplicitTypes
testDisallowImplicitAnyVariableDefinition
testDisallowImplicitAnyGeneric
testDisallowImplicitAnyInherit
testDisallowImplicitAnyAlias
testDisallowImplicitAnyCast
testDisallowImplicitAnyNamedTuple
testDisallowImplicitAnyTypeVarConstraints
testDisallowImplicitAnyNewType
testDisallowImplicitAnyCallableAndTuple
testDisallowImplicitAnySubclassingExplicitAny
testDisallowImplicitAnyVarDeclaration
testDisallowUnimportedAnyTypedDictSimple
testDisallowUnimportedAnyTypedDictGeneric

# --disallow-any-decorated
testDisallowAnyDecoratedUnannotatedDecorator
testDisallowAnyDecoratedErrorIsReportedOnlyOnce
testDisallowAnyDecoratedReturnAny
testDisallowAnyDecoratedReturnCallable
testDisallowAnyDecoratedNonexistentDecorator
testDisallowAnyDecoratedPartlyTypedCallable
testDisallowAnyDecoratedTwoDecorators
# --disallow-untyped-decorators
testDisallowUntypedDefsUntypedDecorator
testDisallowUntypedDecoratorsUnresolvedDecorator
testDisallowUntypedDecoratorsPartialFunction
testDisallowUntypedDecoratorsMultipleDecorators
testDisallowUntypedDecoratorsCallableInstance
testDisallowUntypedDecoratorsCallableInstanceDecoratedCall

# --disallow-untyped-calls
testDisallowUntypedCallsArgType
# --untyped-calls-exclude=bar.A
testDisallowUntypedCallsAllowListFlags

# --disallow-subclassing-any
testMetaclassAsAnyWithAFlag
testSubclassingAny
testSubclassingAnyMultipleBaseClasses
testSubclassingAnySilentImports
testSubclassingAnySilentImports2

# --disallow-any-explicit
testDisallowAnyExplicitDefSignature
testDisallowAnyExplicitVarDeclaration
testDisallowAnyExplicitGenericVarDeclaration
testDisallowAnyExplicitInheritance
testDisallowAnyExplicitAlias
testDisallowAnyExplicitGenericAlias
testDisallowAnyExplicitCast
testDisallowAnyExplicitNamedTuple
testDisallowAnyExplicitTypeVarConstraint
testDisallowAnyExplicitNewType
testDisallowAnyExplicitTypedDictSimple
testDisallowAnyExplicitTypedDictGeneric

# --disallow-incomplete-defs
testDisallowIncompleteDefs
testDisallowIncompleteDefsPartiallyAnnotatedParams
testDisallowIncompleteDefsAttrsNoAnnotations
testDisallowIncompleteDefsAttrsWithAnnotations
testDisallowIncompleteDefsAttrsPartialAnnotations

# --warn-return-any
testErrorCodeReturnAny
testReturnAnyFromTypedFunction
testReturnAnyForNotImplementedInBinaryMagicMethods
testReturnAnyForNotImplementedInNormalMethods
testReturnAnyFromTypedFunctionWithSpecificFormatting
testReturnAnyLambda
# --warn-no-return
testNoReturnDisallowsReturn
testNoReturnDisallowsImplicitReturn
testNoReturnImplicitReturnCheckInDeferredNode
testNoReturnInExpr
testNoReturnAsync
# --no-warn-no-return
testNoWarnNoReturn

# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent
testErrorButDontIgnore1
testErrorButDontIgnore2
testErrorButDontIgnore3-skip
testErrorButDontIgnore4
testIncrementalFollowImportsError
testFollowImportsError
# --follow-imports=silent
testIncrementalFollowImportsSilent
testIncrementalWithSilentImports
testFollowImportsSilent
# --follow-imports=skip
testIncrementalUnsilencingModule
testIncrementalWithSilentImportsAndIgnore
testIncrementalSilentImportsWithBlatantError
testIncrementalImportIsNewlySilenced
testIncrementalSilencedModuleNoLongerCausesError
testIncrementalFollowImportsSkip
testFollowImportSkipNotInvalidatedOnAddedStubOnFollowForStubs
testAddedSkippedStubsPackageFrom
testAddPackage6
testAddPackage7
testSkipImports
testSkipImportsWithinPackage
testSkipButDontIgnore1
testSkipButDontIgnore2
testFineFollowImportSkipInvalidatedOnAddedStub-skip
testFineAddedSkippedStubsPackageFrom
testFileAddedAndImported
testFileAddedAndImported2
testDeleteFileWithErrors
testDoNotFollowImportToNonStubFile
testFollowImportsSkip

# --no-implicit-reexport
testNoImplicitReexport
testNoImplicitReexportRespectsAll
testNoImplicitReexportGetAttr
textNoImplicitReexportSuggestions

# --warn-unreachable
testOperatorContainsNarrowsTypedDicts_final

# --no-namespace-packages
testClassicNotPackage
testPackageWithoutInitFile
testDeletePackage4
testDeletePackage5
testDeletePackage6

# namespace multiple packages
testTypedPkgSimple
testTypedPkg_args_nositepackages
testTypedPkgStubs
testStubPrecedence
testTypedPkgSimpleEgg
testTypedPkgSimpleEditable
testTypedPkgSimpleEditableEgg
testTypedPkgNamespaceImportFrom
testTypedPkgNamespaceImportAs
testTypedPkgNamespaceRegImport
testTypedPkgNamespaceRegFromImportTwice
testNamespacePkgWStubs
testNamespacePkgWStubsWithNamespacePackagesFlag
testTypedPkgNamespaceRegFromImportTwiceMissing
testTypedPkgNamespaceRegFromImportTwiceMissing2

# --enable-error-code redundant-expr
# "If condition is always false"
testRedundantExpressions

# flags: --enable-error-code truthy-bool
testTruthyBool
testTruthyFunctions
testTruthyIterable
# flags: --disable-error-code truthy-bool
testDisableEnableErrorCodesIncremental

# --disable-bytearray-promotion
testDisableBytearrayPromotion
# --disable-memoryview-promotion
testDisableMemoryviewPromotion

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent
# cmd: mypy a.py
testErrorInReAddedModule
testFollowImportsNormalPackageInitFileStub
# Not all modules are checked even in default mypy
testPreferPackageOverFile
testPreferPackageOverFile2
testNotPreferPackageOverFileCase
testFollowImportsNormalDeleteFile4
testFollowImportsNormalDeleteFile5
testFollowImportsNormalDeleteFile6
testFollowImportsNormalDeleteFile7
testSubmoduleMixingImportFromAndImport
testSubmoduleImportFromDoesNotAddParents

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --pretty
testReprocessMethodShowSource
testGenericTypeAliasesWithNestedArgs
testPrettyMessageSorting
testParseErrorShowSource

# --no-silence-site-packages
testAddFileWhichImportsLibModuleWithErrors

# "Incompatible types in string interpolation (expression has type "str", placeholder has type "int")"
testErrorCodeFormatCall

# syntax not yet supported
# ""break" outside loop"
testBreakOutsideLoop
testNoCrashOnBreakOutsideLoopFunction
testNoCrashOnBreakOutsideLoopClass
testContinueOutsideLoop
testInvalidGlobalDecl
testAssignToTypeDef
testSemanticAnalysisBlockingError

# "unknown encoding: uft-8"
testInvalidEncoding
testInvalidEncoding2
testInvalidEncoding3
testDoubleEncoding
testDoubleEncoding2
# coding: ascii
testDecodeErrorBlocker1-posix
testDecodeErrorBlocker2-windows
testDecodeErrorBlockerOnInitialRun-posix

# "Syntax error in type annotation"
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2
# "Suggestion: Use tuple[()] instead of () for an empty tuple, or None for a function without a return value"
testReturnEmptyTuple
# "Suggestion: Is there a spurious trailing comma?"
testColumnSyntaxErrorInTypeAnnotation
# Syntax error in type comment, because used `# type:` twice
testErrorCodeTypeIgnoreMisspelled2

# invalid syntax, and therefore name errors, names should probably be Any
testModifyTwoFilesOneWithBlockingError1
testModifyTwoFilesOneWithBlockingError2
testModifyTwoFilesIntroduceTwoBlockingErrors

# All of these are really not important at all, because there are syntax
# errors, just not the fancy ones.
# Too many invalid syntax errors?
testInvalidFunction
testInvalidFuncDefArgs3
testInvalidFuncDefArgs4
testExceptCommaInPython3
# "unexpected indent"
testUnexpectedIndent
testInconsistentIndent
# "unindent does not match any outer indentation level"
testInconsistentIndent2
# "unexpected EOF while parsing"
testUnexpectedEof
testParseErrorInExtendedSlicing
testParseErrorInExtendedSlicing2
testParseErrorInExtendedSlicing3
# "positional argument follows keyword argument"
testInvalidKeywordArguments1
# "positional argument follows keyword argument unpacking"
testInvalidKeywordArguments2
# "named arguments must follow bare *"
testInvalidBareAsteriskAndVarArgs4
testInvalidBareAsterisk1
testInvalidBareAsterisk2
# "non-default argument follows default argument"
testInvalidFuncDefArgs1
# "invalid syntax. Perhaps you forgot a comma?"
testNotAsBinaryOp
testBinaryNegAsBinaryOp
testErrorCodeSyntaxError
testUpdateClassReferenceAcrossBlockingError
testAddFileWithBlockingError
testBlockingErrorRemainsUnfixed
testDeleteFileWithBlockingError-only_when_nocache
testDeleteFileWithBlockingError2-only_when_cache
testModifyFileWhileBlockingErrorElsewhere
testInitialBlocker
# "cannot delete function call"
testInvalidDel1
# "cannot delete expression"
testInvalidDel2
# "cannot assign to function call here. Maybe you meant '==' instead of '='?"
testInvalidLvalueWithExplicitType
testInvalidTypeDeclaration
# "Cannot assign to literal"
testInvalidWithTarget
# "cannot assign to literal here. Maybe you meant '==' instead of '='?"
testInvalidLvalues*
testInvalidTypeAnnotation2
# "cannot delete expression"
testDelMultipleThingsInvalid
# "Missing parentheses in call to 'print'. Did you mean print(1)?"
testPrintStatementInPython3
# "invalid character in identifier"
testSmartQuotes
# "expected ':'"
testParseError
testParseErrorMultipleTimes
testBlockingErrorWithPreviousError

# Needs lib-stub/blocker.pyi
testImportBringsAnotherFileWithBlockingError1
testImportBringsAnotherFileWithSemanticAnalysisBlockingError
testFixingBlockingErrorBringsInAnotherModuleWithBlocker

# "Not all union combinations were tried because there are too many unions"
testTooManyUnionsException

# - (with type vars) Overloaded function signatures 2 and 3 overlap with incompatible return types
#testOverloadMultipleVarargDefinitionComplex
#testOverloadPartialOverlapWithUnrestrictedTypeVar
#testOverloadPartialOverlapWithUnrestrictedTypeVarNested
#testOverloadedPartiallyOverlappingTypeVarsAndUnion
# Overlapping general
#testManyUnionsInOverload
#testOverloadInferUnionReturnFunctionsWithKwargs
#testOverloadWithOverlappingItemsAndAnyArgument5
#testIntersectionTypesAndVarArgs
#testLiteralInferredInOverloadContextWithTypevars
#testLiteralSubtypeOverlap
#testOverloadsAndNoneWithoutStrictOptional
#testOverloadsAndNoneWithStrictOptional
#testTypeTypeOverlapsWithObjectAndType
#testTypeOverlapsWithObject
#testAccessingGenericDescriptorFromInferredClass
#testAccessingGenericDescriptorFromClass
#testOverloadWithNonGenericDescriptorLookalike
#testOverloadWithGenericDescriptor
#testUnpackIterableClassWithOverloadedIter2

# Note ""<Foo>.__call__" has type "Callable[[Arg(str, 'x'), VarArg(int)], None]"
# Curently ignored

# Mypy is probably wrong here, but we might need to revisit
testConstructorJoinsWithCustomMetaclass

# `for ... in` type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2
testForStatementTypeComments
testForStatementMultipleTypeComments
testForIndex
testForIndexInClassBody
testErrorCodeSyntaxError3
testAsyncForTypeComments
# with type comment
testWithStmt
testWithStmtInClassBody
testWithStmtTypeComment
testWithStmtTupleTypeComment
testWithStmtComplexTypeComment
testAsyncWithTypeComments
testNewAnalyzerTypeArgBoundCheckDifferentNodes
testForwardRefsInWithStatement

# Type Vars qualified names
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName
testSerializeSimpleTypeVar
testSerializeBoundedTypeVar
testSerializeTypeVarWithValues
testSerializeTypeVarInClassBody

# "Access to generic class variables is ambiguous" (unimportant, because similar lint exists)
testClassVarWithGeneric
testClassVarWithNestedGeneric
# ""foo" is considered instance variable, to make it class variable use ClassVar[...]"
testSuggestClassVarOnTooFewArgumentsMethod

# Create a class with a base class based on Type[..] of self.foo
testNewAnalyzerUnsupportedBaseClassInsideFunction

# My own hard/special tests
class_context_super_class
namedtuple__new__
generic_method_on_class_access_no_overload
generic_method_on_class_access_overload

# Weird native types of mypy like `from mypy_extensions import i64, i32`
testNativeIntTypes

# Won't support for now --show-error-code-links
testShowErrorCodeLinks

# Won't support for now: "t" is a type variable and only valid in type context
testExpressionRefersToTypeVariable

# Won't support for now: "Use `from typing_extensions import _FutureFeatureFixture` instead"
testTypingExtensionsSuggestion

# Probably won't support: invalid version numbers for # flags: --python-version 3.99
testFeatureVersionSuggestion

# Probably won't support: typing._promote
testListWithDucktypeCompatibility
testListWithDucktypeCompatibilityAndTransitivity
testSimpleDucktypeDecorator
testDucktypeTransitivityDecorator
testOverloadingAndDucktypeCompatibility

# Probably won't support: Type comments for params
testFastParsePerArgumentAnnotations
testFastParsePerArgumentAnnotationsWithReturn
testFastParsePerArgumentAnnotationsWithAnnotatedBareStar
testFastParsePerArgumentAnnotationsWithReturnAndBareStar

# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments
testNestedFunctionInMethodWithTooFewArgumentsInTypeComment
testDeepNestedFunctionWithTooFewArgumentsInTypeComment
testDeepNestedMethodInTypeComment
testEllipsisWithArbitraryArgsOnBareFunctionWithKwargs
testEllipsisWithArbitraryArgsOnBareFunctionWithVarargs
testEllipsisWithSomethingAfterItFails
testEllipsisWithSomethingBeforeItFails
testMethodDefaultArgumentsAndSignatureAsComment
testDefaultArgumentsAndSignatureAsComment
testLiteralInsideOtherTypesTypeCommentsPython3
testLiteralInvalidTypeComment
testLiteralInvalidTypeComment2
testInferOptionalFromDefaultNoneComment
testNoInferOptionalFromDefaultNoneComment
testCheckUntypedDefsSelf1
testOperatorDoubleUnionDivision
testFasterParseTooManyArgumentsAnnotation
testFasterParseTooFewArgumentsAnnotation
testFastParserShowsMultipleErrors
testFastParserConsistentFunctionTypes
testErrorCodeInvalidCommentSignature
testErrorCodeIgnoreAfterArgComment
testColumnsMethodDefaultArgumentsAndSignatureAsComment
testColumnTypeSignatureHasTooFewArguments
testInvalidSignatureInComment*
testDuplicateSignatures1
testDuplicateSignatures2
testTooManyTypes
testTooFewTypes
testCommentFunctionAnnotationVarArgMispatch-skip
testCommentFunctionAnnotationVarArgMispatch2-skip
testErrorCodeSyntaxError2

# --scripts-are-modules
testScriptsAreModules

# --custom-typeshed-dir 
testIgnoreErrorsFromTypeshed

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testInlineConfigFineGrained1
testInlineConfigFineGrained2
testNoCrashOnDeletedWithCacheOnCmdline
testFollowImportsNormalSearchPathUpdate-only_when_nocache
testFollowImportsNormalSearchPathUpdate2-only_when_cache
testAddNonPackageSubdir
testAddPackage5

# Won't support: __eq__ called directly with a keyword argument (which is actually legal)
testMagicMethodPositionalOnlyArg
testMagicMethodPositionalOnlyArgFastparse

# Won't support: reveal_locals
testRevealLocalsFunction
testRevealLocalsOnClassVars
testRevealLocals

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Union Pipe "|" not allowed in 3.9
testUnionOrSyntaxWithinRuntimeContextNotAllowed
testUnionOrSyntaxWithinRuntimeContextNotAllowed2
testUnionOrSyntaxMissingFutureImport
testTypeAliasNotSupportedWithNewStyleUnion

# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support ever: python 2
testMypyPathAndPython2Dir
# Won't support: Python 3.7 specialties
testGenericBuiltinWarning
testGenericBuiltinSetWarning
testGenericCollectionsWarning
testNoSubcriptionOfStdlibCollections
# Won't support: Python 3.8 specialties
testTupleWithDifferentArgsPy38
# Won't support Pyhton 3.9 specialities
testDataclassWithMatchArgsOldVersion

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testNoSubscriptionOfBuiltinAliases

# Won't support --disable-recursive-aliases
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerAliasToNotReadyDirectBaseFunction
testNewAnalyzerNewTypeForwardClassAliasDirect
testNewAnalyzerForwardTypeAliasInBase
testRecursiveForwardReferenceInUnion
testRecursiveAliasesErrors1
testRecursiveAliasesErrors2
testJSONAliasApproximation
testCrashOnSelfRecursiveNamedTupleVar
testSimpleSelfReferentialNamedTuple
testSelfRefNT1
testSelfRefNT2
testSelfRefNT3
testSelfRefNT4
testSelfRefNT5
testRecursiveNamedTupleInBases
testSubclassOfRecursiveNamedTuple
testSelfRecursiveTypedDictInheriting
testSubclassOfRecursiveTypedDict

# Won't support --force-union-syntax
testOptionalErrorSyntax
testLiteralUnionErrorSyntax
testLiteralOptionalErrorSyntax

# Mypy test case issues
# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred

# Not working in interpreter
# Recursive class inheritance
testNewAnalyzerAliasToNotReadyNestedClass

# "Recursive types are not allowed at function scope"
testNoRecursiveTuplesAtFunctionScope
testRecursiveBoundFunctionScopeNoCrash

# Won't support: Mypy internals
testIncrCacheBustedProtocol
testIncrementalBustedFineGrainedCache1
testIncrementalBustedFineGrainedCache3
testInvalidateCachePart

# xfail
testOpWithInheritedFromAny-xfail
# Skips
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testOverloadInferringArgumentsUsingContext2-skip
testUnionTwoPassInference-skip
testLiteralErrorsWhenInvoked-skip
testRecursiveNamedTupleTypedDict-skip
