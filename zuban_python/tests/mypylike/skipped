# Next up

# Fails only without --release
testModuleAsTypeNoCrash
testNonStrictOptional

# new param spec in aliases etc changes
testValidTypeAliasValues
testValidTypeAliasValuesMoreRestrictive
testInvalidParamSpecDefinitionsWithArgsKwargs
testInvalidParamSpecAndConcatenateDefinitionsWithArgsKwargs
testUnboundParamSpec
testParamSpecClassConstructor
testParamSpecInTypeAliasBasic
testParamSpecInTypeAliasConcatenate
testParamSpecInTypeAliasRecursive
testParamSpecAliasInRuntimeContext
testParamSpecAliasInvalidLocations
testTrivialParametersHandledCorrectly
testParamSpecAliasNested
testGenericUnionMemberWithTypeVarConstraints

# No recursion tests
testRecursiveDoubleUnionNoCrash
testNoRecursiveExpandInstanceUnionCrashGeneric
testNoRecursiveExpandInstanceUnionCrashInference

#  Method must have at least one argument. Did you forget the "self" argument?
testMissingSelf
testMissingSelfInMethod
testReprocessMethodInNestedClassSemanal
testPreviousErrorInMethodSemanal1

# Implement bitwise or
testUnionOrSyntaxWithTypeAliasWorking

# "<typing special form>"
testGenericTypeAliasesRuntimeExpressionsOther

# Generics self assignment
testGenericTypeBodyWithMultipleVariables
self_valid_method
# generics issues
testCompatibilityOfTypeVarWithObject
# formatting Self
testRemoveAttributeInBaseClass
testRemoveBaseClass
testRemoveBaseClass2
testBaseClassDeleted
testBaseClassOfNestedClassDeleted

# Nicer Callable Errors
testCallableParsingFromExpr
testCallableParsing
testCallableTooManyVarArg
testCallableKindsOrdering

# Details around Never?
testStar2Context

# Invalid recursive aliases --enable-recursive-aliases
testRecursiveAliasesProhibitBadAliases
# Recursive Alias wrong type var inference --enable-recursive-aliases
testRecursiveAliasesJoins
# Recursive alias union type var inference --enable-recursive-aliases
testRecursiveAliasWithRecursiveInstanceInference
# Recursive alias class type aliases --enable-recursive-aliases
testRecursiveClassLevelAlias

# func type var in __init__
testInvalidNumberOfTypeArgs
testInheritedConstructor2

# Uses function context but is in fact in module context
testFunctionForwardRefAlias

# Maybe implement reverse operator
testFlattenTypeAliasWhenAliasedAsUnion

# Overloads should not promote
testOverloadWithOverlappingItemsAndAnyArgument5
# Overloading
testOverloadBadArgumentsInferredToAny1
testOverloadBadArgumentsInferredToAny2
# Overloading __init__
testOverloadedToGeneric
# *args/**kwargs input use Any if length unclear
testOverloadWithOverlappingItemsAndAnyArgument6
testOverloadWithOverlappingItemsAndAnyArgument11
# *args *params should be preferred in overload
testOverloadVarargInputAndVarargDefinition
testOverloadMultipleVarargDefinition
testOverloadVarargsSelection
testOverloadVarargsAndKwargsSelection
# - wtf Argument 1 to "f1" has incompatible type "Union[A, B]"; expected "A"
#       Argument 1 to "foo" has incompatible type "Union[WrapperCo[A], WrapperContra[C]]"; expected "WrapperCo[B]"
testOverloadInferUnionReturnBasic
testOverloadsUsingAny
testOverloadInferUnionReturnMultipleArguments
testOverloadInferUnionRespectsVariance
testUnionMathTrickyOverload1
testUnionMathTrickyOverload2
testLiteralInferredInOverloadContextUnionMath
testLiteralInferredInOverloadContextUnionMathOverloadingReturnsBestType
testLiteralInferredInOverloadContextUnionMathTrickyOverload
testManyUnionsInOverload
testOverloadAndSelfTypes
# - 3352-3500 Union/Type vars/overloads weird combinations
testOverloadInferUnionIfParameterNamesAreDifferent
testOverloadInferUnionReturnFunctionsWithKwargs
testOverloadInferUnionWithDifferingLengths
testOverloadInferUnionWithMixOfPositionalAndOptionalArgs
testOverloadingInferUnionReturn*
testOverloadInferUnionReturnWithInconsistentTypevarNames
overload_union_math_on_class_init_constrained
# - Not all union combinations were tried because there are too many unions
testTooManyUnionsException
# Overloads maybe later
testOverloadedCallWithVariableTypes
testOverloadOverlapWithTypeVarsWithValues
testOverloadMultipleVarargDefinitionComplex
# overloading for loop
testOverloadedInIter
# overload operator
testOverloadedLtAndGtMethods
testOverloadedForwardMethodAndCallingReverseMethod
testTypeInferenceSpecialCaseWithOverloading

# Class function Foo.bar something like a BoundFunction
testParamSpecConstraintOnOtherParamSpec
testExpandNonBareParamSpecAgainstCallable

# Cannot use a covariant type variable as a parameter
testRejectCovariantArgument
testRejectCovariantArgumentSplitLine
testRejectCovariantArgumentInLambda
# Cannot use a contravariant type variable as return type
testRejectContravariantReturnType
testAcceptCovariantReturnType
testAcceptContravariantArgument

# Union of empty lists dicts sets with used ones
testUnificationEmptyListLeft
testUnificationEmptyListRight
testUnificationEmptyListLeftInContext
testUnificationEmptyListRightInContext
testUnificationEmptySetLeft
testUnificationEmptyDictLeft
testUnificationEmptyDictRight
testUnificationDictWithEmptyListLeft
testUnificationDictWithEmptyListRight
testMisguidedSetItem

# Union Not matching type vars
testJoinUnionWithUnionAndAny

# Duplicate base class
testIncludingBaseClassTwice

# Cycle for bytes -> ReadOnlyBuffer -> bytes?
testPromoteBytearrayToByte
# import cycle
testBoundGenericMethodParamSpecFine
# Cycles
testCyclicUndefinedImportWithName
testCyclicUndefinedImportWithStar1
testCyclicUndefinedImportWithStar2
testCyclicUndefinedImportWithStar3
testNewAnalyzerTypeAnnotationCycle4
testNewAnalyzerVarTypeVarNoCrashImportCycle
testBoundGenericMethodFine
testSelfReferentialSubscriptExpression
testOverrideByIdemAliasCorrectType
testOverrideByIdemAliasCorrectTypeReversed
testConditionalExceptionAlias

# Module attributes
testModuleImplicitAttributes
testSpecialAttrsAreAvaliableInClasses
testSpecialModulesNameImplicitAttr
# Function attributes
testInvalidRvalueTypeInInferredMultipleLvarDefinition
# None attributes
testNoneHasBool

# boolean operators
testOrOperationWithGenericOperands
testOrOperationInferredFromContext

# Bound with Union: Item "{}" of the upper bound "{}" of type variable "{}" has no attribute "{}"
testTypeVarBoundToOldUnionAttributeAccess
testTypeVarBoundToNewUnionAttributeAccess
testUnboundedTypevarUnpacking
# Tuple Bound with iter unpacking
testIterableBoundUnpacking
# Bound not respected
testLiteralAndGenericsRespectsUpperBound
testWideOuterContextEmptyError

# *args on TypeVar
testInvalidTypevarValues

# Tuple type var context
testTupleContextFromIterable
testComplexTypeInferenceWithTuple
testInferenceWithTypeVariableTwiceInReturnType
testInferenceWithTypeVariableTwiceInReturnTypeAndMultipleVariables
class_generics_recursion
# bottom up tuple inference
testLiteralInferredInTupleContext
# bottom up inference for tuple with *args
testCallerVarArgsListWithTypeInference
testCallerVarArgsTupleWithTypeInference
testCallerVarargsAndComplexTypeInference
# bottom up inference list multiply
testListMultiplyInContext
# bottom up dict
testDictionaryLiteralInContext
testLiteralInferredInDictContext

# Not able to infer context with unions and literals
testLiteralAndGenericWithUnion
testLiteralAndGenericsNoMatch

# Type variable "C.T" cannot be used as an expression
testClassMemberTypeVarInFunctionBody
# Type variable "__main__.Ts" is invalid as target for type alias
testTypeVarTupleIsNotValidAliasTarget
# Type variable "__main__.T" is unbound
# (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class)
# (Hint: Use "T" in function signature to bind "T" inside a function)
testGenericTypeAliasesRuntimeExpressionsInstance
testNestedGenericFunctionTypeApplication


# type var backtracking
testUnionInference
testMapWithOverloadedFunc
unite_type_vars_mypy_issue_5874
multiple_lambda_mypy_issue_4226

# Chained assignments are not legal like a = b = [] if a and b are list[int]
# and list[str].
testChainedAssignmentInferenceContexts

# Nested type vars
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues
testGenericClassInnerFunctionTypeVariable
testFunctionInGenericInnerClassTypeVariable-skip
testSubtypingWithGenericInnerFunctions
testNestedGenericFunctions
testInnerFunctionTypeVar
testConstraintsBetweenConcatenatePrefixes
testParamSpecDecoratorImplementation
testParamSpecArgsAndKwargsMissmatch
testParamSpecTestPropAccess
testTupleAndDictOperationsOnParamSpecArgsAndKwargs
testUnpackingParamsSpecArgsAndKwargs
testParamSpecConcatenateFromPep
param_spec_with_identity_mypy_issue_12278

# Param spec invalid calls
testParamSpecInvalidCalls

# strict optional
testNoComplainInferredNoneStrict
testInheritedAttributeNoStrictOptional
testIncompatibleInheritedAttributeNoStrictOptional
testInheritedAttributeStrictOptional
testOverloadsAndNoneWithoutStrictOptional
testOverloadsAndNoneWithStrictOptional
testOverloadsNoneAndTypeVarsWithNoStrictOptional
testOverloadsNoneAndTypeVarsWithStrictOptional
testAssignToFuncDefViaImport
testRegression11705_Strict
testGenericMethodCalledInGenericContext
# non strict call on Optional[T]
testCastConfusion
# None | Iterable[X] -> ignore None
testNewAnalyzerNoCrashForwardRefToBrokenDoubleNewTypeClass
# strict optional with config file
testNewAnalyzerTypeArgBoundCheckWithStrictOptional
testNewAnalyzerTypeArgBoundCheckWithStrictOptionalPyProjectTOML
testPerFileStrictOptionalModule
testPerFileStrictOptionalModuleOnly
testPerFileStrictOptionalFunction
testPerFileStrictOptionalMethod

# function call in class of function in class
testCallConditionalMethodInClassBody

# Class in function special cases
testNewAnalyzerUnsupportedBaseClassInsideFunction
testInfiniteLoop

# Nested class / class in class
testGenericClassInsideOtherGenericClass

# Class: generic access from outside
testGenericTypeAliasesTypeVarBinding

# descriptors
testOverloadWithNonGenericDescriptor
testOverloadWithNonGenericDescriptorLookalike
testOverloadWithGenericDescriptor
testOverloadWithGenericDescriptorLookalike

# Property
testNonMethodProperty
testInvalidArgCountForProperty
testNewAnalyzerProperty
testNewAnalyzerNoCrashOnCustomProperty
testOverloadNotConfusedForProperty
testForwardReferenceToDynamicallyTypedProperty
testForwardReferenceToStaticallyTypedProperty
# Decorated property not supported
testOverloadedProperty
testOverloadedProperty2
testDecoratedPropertySetter

# classmethod
testAliasToClassMethod
testGenericClassMethod*
testClassmethodAndNonMethod
testAddBaseClassMethodCausingInvalidOverride
testModifyBaseClassMethodCausingInvalidOverride
testClassImportAccessedInMethod
testSelfTypeVarIndexExpr
testNewAnalyzerTypeVarBoundInCycle
testOverloadClassmethodDisappears
testOverloadWithClassMethods
testOverloadWithInconsistentClassMethods
testOverloadAndClassTypes
testForwardReferenceToDynamicallyTypedClassMethod
testForwardReferenceToStaticallyTypedClassMethod
testGenericClassClsNonGeneric
testGenericClassUnrelatedVars
testGenericClassDirectCall
testGenericClassInGenericFunction
testGenericClassInGenericFunctionOverloadedConstructor-skip
testGenericClassAlternativeConstructorPrecise
testGenericClassAlternativeConstructorPreciseOverloaded
testGenericClassAlternativeConstructorPrecise2
testNoGenericAccessOnImplicitAttributes
testOverloadClassMethodImplementation
testOverloadWithSwappedDecorators
testForwardReferenceToDecoratedClassMethod
# Self type classmethod
testTypingSelfClassMethod
testTypingSelfAlternativeGenericConstructor
testTypingSelfRedundantAllowed
testTypingSelfRedundantWarning
testTypingSelfDifferentImport
# Self type with final
testTypingSelfAllowAliasUseInFinalClasses

# staticmethod
testStaticmethodAndNonMethod
testBoundStaticMethod
testForwardReferenceToDynamicallyTypedStaticMethod
testForwardReferenceToStaticallyTypedStaticMethod
testOverloadWithSwappedDecorators2
testOverloadWithStaticMethods

# Typing stuff
testInvalidAssertType
testInvalidAnyCall
testInvalidTypeInTypeApplication
testBaseClassAnnotatedWithoutArgs
# typing assert_type
testTypingSelfAssertType

# Explicit Type Aliases
testInvalidPep613

# Final
testNewAnalyzerFinalDefiningModuleVar
testNewAnalyzerFinalDefiningInstanceVar
testNewAnalyzerFinalReassignModuleVar
testNewAnalyzerFinalReassignModuleReexport
testNewAnalyzerFinalOverrideInSubclass
testNewAnalyzerFinalLiteralInferredAsLiteralWithDeferral
testFinalAddFinalVarAssignFine
testFinalAddFinalVarOverrideFine
testFinalAddFinalMethodOverrideFine
testFinalAddFinalMethodOverrideWithVarFine
testFinalAddFinalMethodOverrideOverloadFine
testFinalAddFinalPropertyWithVarFine
testFinalBodyReprocessedAndStillFinal
testFinalBodyReprocessedAndStillFinalOverloaded-only_when_cache
testFinalBodyReprocessedAndStillFinalOverloaded2-only_when_nocache
testLiteralFineGrainedChainedViaFinal
testLiteralFinalInferredAsLiteral
testLiteralFinalDirectInstanceTypesSupercedeInferredLiteral
testLiteralFinalDirectLiteralTypesForceLiteral
testLiteralFinalErasureInMutableDatastructures1
testLiteralFinalErasureInMutableDatastructures2
testLiteralFinalMismatchCausesError
testLiteralFinalGoesOnlyOneLevelDown
testLiteralFinalCollectionPropagation
testLiteralFinalStringTypesPython3
testLiteralFinalPropagatesThroughGenerics
testLiteralFinalUsedInLiteralType
testLiteralWithFinalPropagation
testLiteralWithFinalPropagationIsNotLeaking
testLiteralIntelligentIndexingUsingFinal
testNegativeIntLiteralWithFinal
testLiteralAndInstanceSubtyping
testNewAnalyzerNewTypeSpecialCase

# NamedTuple
*NamedTuple*
testNewAnalyzerTupleIteration
testDistinctTypes
testInfiniteLoop2
testNewAnalyzerTypeArgBoundCheckDifferentNodes
testRegression11705_NoStrict
testNewAnalyzerCastForward3
testRecursiveAliasViaBaseClass3
testNoRecursiveTuplesAtFunctionScope
testRecursiveTupleClassesNewType
testLiteralIntelligentIndexingTuples
testLiteralIntelligentIndexingTupleUnions
# namedtuple
testCallableParsingInInheritence

# data class (currently all are passing)

# Enum
testNewAnalyzerEnumRedefinition
testRefreshFunctionalEnum
testRefreshClassBasedEnum
testRefreshClassBasedIntEnum
testClassBasedEnumPropagation1
testClassBasedEnumPropagation2
testRefreshFuncBasedEnum
testRefreshFuncBasedIntEnum
testFuncBasedEnumPropagation1
testFuncBasedEnumPropagation2
testLiteralWithEnumsBasic
testLiteralWithEnumsDefinedInClass
testLiteralWithEnumsSimilarDefinitions
testLiteralWithEnumsDeclaredUsingCallSyntax
testLiteralWithEnumsDerivedEnums
testLiteralWithEnumsAliases
testLiteralUsingEnumAttributesInLiteralContexts
testLiteralUsingEnumAttributeNamesInLiteralContexts
testAliasForEnumTypeAsLiteral
testInvariance

# TypedDict
testNewAnalyzerTypedDictClass
testNewAnalyzerTypedDictClassInheritance
testNewAnalyzerMemberNameMatchesTypedDict
testTypeVarWithTypedDictBoundInIndexExpression
testTypeVarWithUnionTypedDictBoundInIndexExpression
testTypeVarWithTypedDictValueInIndexExpression
testDirectlyImportTypedDictObjectAtTopLevel
testUnpackWithoutTypedDict
testUnpackTypedDictTotality
testUnpackKeywordTypesTypedDict
testUnpackKwargsOverridesTypedDict
testUnpackGenericTypedDictImplicitAnyEnabled
testUnpackGenericTypedDictImplicitAnyDisabled
testOverloadKwargsSelectionWithTypedDict
testOverloadTypedDictDifferentRequiredKeysMeansDictsAreDisjoint
testOverloadedTypedDictPartiallyOverlappingRequiredKeys
testOverloadedTypedDictFullyNonTotalDictsAreAlwaysPartiallyOverlapping
testOverloadedTotalAndNonTotalTypedDictsCanPartiallyOverlap
testOverloadedTypedDictsWithSomeOptionalKeysArePartiallyOverlapping
testBasicRecursiveTypedDictClass
testBasicRecursiveTypedDictCall
testBasicRecursiveTypedDictExtending
testRecursiveTypedDictCreation
testRecursiveTypedDictMethods
testRecursiveTypedDictSubtyping
testRecursiveTypedDictJoin
testBasicRecursiveGenericTypedDict
testRecursiveGenericTypedDictExtending
testTypedDictRefresh
testTypedDictUpdate
testTypedDictUpdate2
testTypedDictUpdate3
testTypedDictCrashFallbackAfterDeletedMeet
testTypedDictCrashFallbackAfterDeletedJoin
testTypedDictUpdateGeneric
testLiteralIntelligentIndexingTypedDict
testLiteralIntelligentIndexingTypedDictUnions
testLiteralIntelligentIndexingMultiTypedDict
testUnpackKwargsNonIdentifier
testTypedDictNestedClassRecheck

# NoReturn
testNoReturnTypeAlias
testUnionWithNoReturn
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2
testDontNeedAnnotationForCallable
testLiteralCheckSubtypingStrictOptional
testLiteralCheckSubtypingNoStrictOptional

# Type application vs. type declaration
testParamSpecApplyConcatenateTwice
testNewAnalyzerAliasToNotReadyClassDoubleGeneric
testTypeAliasesResultingInPlainInstance

# typing.no_type_check
testNoTypeCheckDecoratorOnMethod1
testNoTypeCheckDecoratorOnMethod2
testCallingNoTypeCheckFunction
testCallingNoTypeCheckFunction2
testNoTypeCheckDecoratorSemanticError

# Union attribute error: Item "D" of "C | D" has no attribute "y"
testUnionAttributeAccess

# Union iter()
testUnionMultiassignSingle
testUnionMultiassignDouble
testUnionMultiassignGeneric
testUnionMultiassignAny
testUnionMultiassignNotJoin
testUnionMultiassignRebind
testUnionMultiassignAlreadyDeclared
testUnionMultiassignIndexed
testUnionMultiassignIndexedWithError
testUnionMultiassignPacked
testUnpackingUnionOfListsInFunction
testUnionOfVariableLengthTupleUnpacking
testUnionOfNonIterableUnpacking
testUnionAlwaysTooMany
testUnionAlwaysTooFew
testUnionUnpacking*
testNestedUnionUnpackingFromNestedTuples
testNestedUnionUnpackingFromNestedTuplesBinder
testUnpackUnionNoCrashOnPartialNone
testUnpackUnionNoCrashOnPartialNone2
testUnpackUnionNoCrashOnPartialNoneBinder
testUnpackUnionNoCrashOnPartialNoneList
testReusingInferredForIndex
testReusingInferredForIndex2
testNestedProtocolUnions
testNestedProtocolGenericUnions
testNestedProtocolGenericUnionsDeep
testNestedInstanceUnsimplifiedUnion
testNestedInstanceTypeAlias
testNestedInstanceTypeAliasUnsimplifiedUnion

# Dynamic functions are not type checked?!
testNoInvalidTypeInDynamicFunctions
testCallGenericFunctionWithTypeVarValueRestrictionInDynamicFunc
testDynamicallyTypedNestedFunction
testInferringImplicitDynamicTypeForLvar
testInferringMultipleLvarDefinitionWithImplicitDynamicRvalue
# Dynamic functions are ignored in classes and the super class is used?
testInferringTypesFromIterable

# Comprehensions
testNewAnalyzerListComprehension
testNewAnalyzerDictionaryComprehension
# comprehensions Scoping
testListComprehensionSpecialScoping

# lambda
testLambdaDefaultTypeErrors
testLambdaDefaultContext
testLambdaVarargContext
testLambdaDeferredSpecialCase
testErasedTypeRuntimeCoverage
testLambdaJoinWithDynamicConstructor
# Lambda with defined return types (inferred context)
testInferLambdaTypeUsingContext
testLambdaWithoutContext
testInvalidContextForLambda
testEllipsisContextForLambda
testEllipsisContextForLambda2
testIsinstanceInInferredLambda
testLambdaDeferredCrash
# Cannot infer type of lambda
testParamSpecLiteralsTypeApplication
# Param Spec lambda type inference
testParamSpecInferredFromLambda

# Protocol
testProtocolUpdateTypeInVariable
testProtocolUpdateTypeInFunction
testProtocolUpdateTypeInClass
testProtocolAddAttrInFunction
testProtocolRemoveAttrInClass
testProtocolConcreteUpdateTypeFunction
testProtocolConcreteUpdateTypeMethodGeneric
testProtocolConcreteRemoveAttrVariable
testProtocolConcreteUpdateBaseGeneric
testProtocolUpdateBaseGeneric
testProtocolChangeGeneric
testNonProtocolToProtocol
testInvalidateProtocolViaSuperClass
testProtocolInvalidateConcreteViaSuperClassUpdateType
testProtocolInvalidateConcreteViaSuperClassAddAttr
testProtocolInvalidateConcreteViaSuperClassRemoveAttr
testTwoProtocolsTwoFilesCrossedUpdateType-only_when_nocache
testTwoProtocolsTwoFilesCrossedDeleteAttr-only_when_cache
testProtocolsInvalidateByRemovingBase
testProtocolVsProtocolSubUpdated
testProtocolVsProtocolSuperUpdated
testProtocolVsProtocolSuperUpdated2
testProtocolVsProtocolSuperUpdated3
testProtocolMultipleUpdates
testWeAreCarefulWithBuiltinProtocols
testWeAreCarefullWithBuiltinProtocolsBase
testModuleAsProtocolImplementationFine
# Duck typing
testOverloadingAndDucktypeCompatibility

# TypeVarTuple
testTypeVarTupleMixed
testTypeVarTupleChaining
testTypeVarTupleGenericClassDefn
testTypeVarTupleCached
testTypeVarTuplePep646ArrayExample
testTypeVarTuplePep646ArrayExampleWithDType
testTypeVarTuplePep646TypeVarTupleUnpacking
testTypeVarTuplePep646TypeVarStarArgsBasic
testTypeVarTuplePep646TypeVarStarArgs
testTypeVarTuplePep646TypeVarStarArgsFixedLengthTuple
testTypeVarTuplePep646TypeVarStarArgsVariableLengthTuple
testTypeVarTuplePep646Callable
# typing_extensions.Unpack
testRuntimeProtoTwoBases
testUnpackKwargsReveal
testUnpackOutsideOfKwargs
testUnpackWithDuplicateKeywords
testUnpackWithDuplicateKeywordKwargs
testUnpackKwargsEmpty
testUnpackUnexpectedKeyword
testUnpackKeywordTypes
testFunctionBodyWithUnpackedKwargs
testUnpackKwargsOverrides
testUnpackKwargsGeneric
testUnpackKwargsInference
testUnpackKwargsOverload
testUnpackKwargsJoin
testUnpackKwargsParamSpec
testUnpackKwargsUpdateFine
testUnpackNoCrashOnEmpty
testInvalidUnpackTypes
# Unpack item in ** argument must be a TypedDict
testTypeVarTuple

# Visibility of imports in pyi
testNewSemanticAnalyzerModulePrivateRefInMiddleOfQualified

# x: typing_extensions.TypeAlias = int
testClassLevelTypeAliasesInUnusualContexts
testMalformedTypeAliasRuntimeReassignments

# TypeAlias normal string interpreted as a forward reference
testTypeAliasWithNewStyleUnionChangedToVariable

# stdlib imports
testOverloadSpecialCase
testSubclassingGenericABCWithImplicitAny
testSubclassingGenericABCWithImplicitAnyAndDeepHierarchy
testImplementingGenericABCWithImplicitAnyAndDeepHierarchy2
testSubtypingAndABCExtension
testAccessingGenericABCMembers
testAccessingInheritedGenericABCMembers
testPrecedenceOfFirstBaseAsInferenceResult
type_var_with_co_and_contra_real_life

# Module __all__
testNewAnalyzerExportedValuesInImportAll
testExportedValuesInImportAll
testAllMustBeSequenceStr
testUnderscoreExportedValuesInImportAll
testReExportAllInStub

# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions

# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testKeywordMisspelling
testMultipleKeywordsForMisspelling
testKeywordMisspelling*

# Import submodules
testNewAnalyzerImportStarSpecialCase

# Submodule was not imported
testSubmoduleImportFromDoesNotAddParents
testSubmoduleMixingImportFromAndImport

# import a.b.c issues
testMissingSubmoduleImportedWithIgnoreMissingImports
testMissingSubmoduleImportedWithIgnoreMissingImportsStub
testMissingSubmoduleImportedWithIgnoreMissingImportsNested
testMissingSubmoduleOfInstalledStubPackage
testGenericAliasCollectionsABCReveal

# Complex Star import
testImportWithinMethod

# Module type does not contain module info
testMultiModuleAlias
testModuleAliasWithExplicitAnnotation

# Import itself / Extremely weird import orders
testNewAnalyzerImportCycleWithIgnoreMissingImports
testNewAnalyzerImportFromTopLevelFunction
testNewAnalyzerImportFromTopLevelAlias
testNewAnalyzerImportAmbiguousWithTopLevelFunction
testImportCycleSpecialCase
testPackagePath

# namespace packages
testClassicNotPackage
testNamespacePackage*
testClassicPackageIgnoresEarlierNamespacePackage
testClassicPackageInsideNamespacePackage

# Stub Reexport
testNoReExportFromStubs
testNoReExportFromStubsMemberType
testNoReExportFromStubsMemberVar
testNoReExportChildStubs
testReExportChildStubs
testReExportChildStubs2
testNoReExportNestedStub
testNoReExportFromMissingStubs
testMissingGenericImport
testStubFixupIssues
testNoReExportUnrelatedModule
testNoReExportUnrelatedSiblingPrefix

# Metaclass
testInvalidMetaclass
testInvalidQualifiedMetaclass
testNonClassMetaclass
testNewAnalyzerMetaclass1
testNewAnalyzerMetaclass2
testNewAnalyzerMetaclassPlaceholder
testNewAnalyzerMetaclassSix1
testNewAnalyzerMetaclassSix2
testNewAnalyzerMetaclassSix3
testNewAnalyzerMetaclassSix4
testNewAnalyzerMetaclassFuture1
testNewAnalyzerMetaclassFuture3
testNewAnalyzerMetaclassFuture4
testNotSimplifyingUnionWithMetaclass
testMetaclassAttributes
testMetaclassAttributesDirect
testMetaclassOperators
testMetaclassOperatorsDirect
testFineMetaclassUpdate
testFineMetaclassRecalculation
testFineMetaclassDeclaredUpdate
testFineMetaclassRemoveFromClass
testFineMetaclassRemoveFromClass2
testBadMetaclassCorrected
testFixedAttrOnAddedMetaclass
testIndirectSubclassReferenceMetaclass
testMetaclassDeletion
testFixMissingMetaclass
testGoodMetaclassSpoiled
testProtocolsInvalidateByRemovingMetaclass
testOverloadedToNormalMethodMetaclass
testNewAnalyzerClassKeywordsError
testNewAnalyzerNotAnAlias
testNewAnalyzerClassPropertiesInAllScopes
testIgnoredAttrReprocessedMeta
testImplementingOverloadedMethod
testTypingSelfMetaClassDisabled

# abstractmethod / ABCMeta
testMakeClassNoLongerAbstract1
testMakeClassNoLongerAbstract2
testAddAbstractMethod
testMakeClassAbstract
testMakeMethodNoLongerAbstract1
testMakeMethodNoLongerAbstract2
testAbstractBodyTurnsEmpty
testAbstractBodyTurnsEmptyProtocol
testAbstractGlobalFunction
testAbstractNestedFunction
testInferenceWithAbstractClassContext3

# Signature of "???" incompatible with supertype "???"
testKeywordOnlyArgumentOrderInsensitivity
testPositionalOverridingArgumentNamesCheckedWhenMismatchingPos
testOverrideGenericMethodInNonGenericClassLists
testOverrideGenericMethodInNonGenericClassGeneralize
testOverloadedMethodSupertype-only_when_cache
testOverloadedMethodSupertype2-only_when_nocache
testOverloadedInitSupertype
testIncompatibleOverrideFromCachedModuleIncremental

# supertype context inference
testUseSupertypeAsInferenceContext
testUseSupertypeAsInferenceContextInvalidType
testUseSupertypeAsInferenceContextPartial
testUseSupertypeAsInferenceContextPartialError
testUseSupertypeAsInferenceContextPartialErrorProperty
testUseSupertypeAsInferenceContextConflict
testLiteralSubtypeContext
testLiteralSubtypeContextNested
testLiteralSubtypeContextGeneric

# "Access to generic instance variables via class is ambiguous"
testGenericClassAttrUnboundOnClass
testGenericClassAttrUnboundOnSubClass

# super()
testSuperExpressionsWhenInheritingFromGenericType
testSuperExpressionsWhenInheritingFromGenericTypeAndDeepHierarchy
testSuperOutsideClass
testSuperField
testSuperBasics
testRefreshGenericSubclass
testConstrainedGenericSuper
testTypingSelfOnSuperTypeVarValues

# class types defined in super class
testInheritanceFromGenericWithImplicitDynamic

# "Invalid self argument "A[C]" to attribute function "f" with type "Callable[[A[B]], None]""
testInvalidMethodAsDataAttributeInGenericClass
# "Attribute function "f" with type "Callable[[], None]" does not accept self argument"
testMethodWithInvalidMethodAsDataAttribute

# ClassVar
testMethodAsDataAttribute
testMethodWithDynamicallyTypedMethodAsDataAttribute
testPartiallyTypedSelfInMethodDataAttribute
testCallableDataAttribute
testTypingSelfClassVar
testTypingSelfCallableClassVar

# "Variance of TypeVar "T_contra" incompatible with variance in parent type"
testIncompatibleVariance

# Self type variable type
DecoratorUpdateMethod
testDecoratorUpdateNestedClass
testDecoratorUpdateClassInFunction
testGenericTypeBody1
testSolveParamSpecWithSelfType
param_spec_with_generic_class

testSelfTypeInstance
testSelfTypeStaticAccess
testSelfTypeReturn
testSelfTypeClass
testSelfTypeOverride
testSelfTypeSuper
testSelfTypeRecursiveBinding
testSelfTypeBound
testSelfTypeClone
testSelfTypeGeneric
testSelfTypeNonsensical
testSelfTypeLambdaDefault
testSelfTypeNew
testSelfTypePropertyUnion
testSelfTypeProperSupertypeAttribute
testSelfTypeProperSupertypeAttributeTuple
testSelfTypeProperSupertypeAttributeMeta
testSelfTypeProperSupertypeAttributeGeneric
testSelfTypeRestrictedMethod
testSelfTypeRestrictedClassMethod
testSelfTypeRestrictedMethodOverload
testSelfTypeRestrictedMethodOverloadFallback
testSelfTypeRestrictedMethodOverloadInit
testSelfTypeRestrictedMethodOverloadInitFallBacks
testSelfTypeRestrictedMethodOverloadInitBadTypeNoCrash
testSelfTypeNarrowBinding
testSelfTypeTrickyExample
testSelfTypeReallyTrickyExample
testSelfTypeMutuallyExclusiveRestrictions
testSelfTypeStructureMetaclassMatch
testSelfTypeProtocolMetaclassMatch
testSelfTypeProtocolClassmethodMatch
testSelfTypeNotSelfType
testSelfTypeNoTypeVars
testSelfTypeNoTypeVarsRestrict
testSelfTypeMultipleTypeVars
testSelfTypeOnUnion
testSelfTypeOnUnionClassMethod
testSelfTypeClassMethodOnUnion
testSelfTypeClassMethodOnUnionGeneric
testSelfTypeClassMethodOnUnionList
testSelfTypeClassMethodOverloadedOnInstance
testSelfTypeBadTypeIgnoredInConstructor
testSelfTypeBadTypeIgnoredInConstructorGeneric
testSelfTypeBadTypeIgnoredInConstructorOverload
testSelfTypeBadTypeIgnoredInConstructorAbstract
testSelfTypeGenericClassNoClashInstanceMethod
testSelfTypeGenericClassNoClashClassMethod
testSelfTypeGenericClassNoClashClassMethodClassObject
testSelfTypeInGenericClassUsedFromAnotherGenericClass1
testSelfTypeVarIndexExpr
testSelfType
testSelfTypesWithProtocolsBehaveAsWithNominal
testMixinAllowedWithProtocol
testBadClassLevelDecoratorHack
testUnionPropertyField
SelfTypeOverloadedClassMethod
testEnumerateReturningSelfFromIter
testTypingSelfAttrOldVsNewStyle
testSelfTypeCallableClassVarOldStyle

# Self tests
testTypingSelfBasic
testTypingSelfConflict
testTypingSelfProperty
testTypingSelfOverrideVar
testTypingSelfOverrideVarMulti
testTypingSelfRecursiveInit
testTypingSelfCorrectName
testTypingSelfNonAnnotationUses
testTypingSelfInternalSafe
testTypingSelfTypeVarClash
testTypingSelfClashInBodies
testTypingSelfFine
testMixinProtocolSuper

# Liskov
testLiskovFineVariable
testLiskovFineVariableInFunction
testLiskovFineDecorator
testLiskovFineVariableClean-only_when_nocache
testLiskovFineVariableCleanDefInMethod-only_when_nocache
testLiskovFineVariableCleanDefInMethodStar-only_when_nocache
testLiskovFineVariableCleanDefInMethodNested-only_when_nocache
testLiskovFineVariableInFunctionClean-only_when_nocache
testLiskovFineDecoratorClean-only_when_nocache
testPositionalOverridingArgumentNameInsensitivity
testOverridingMethodInSimpleTypeInheritingGenericType
testOverridingMethodInGenericTypeInheritingSimpleType
testOverridingMethodInMultilevelHierarchyOfGenericTypes
testOverridingMethodInGenericTypeInheritingGenericType
testSubclassingGenericABC1
testSubclassingGenericABCWithDeepHierarchy
testSubclassingGenericABCWithDeepHierarchy2

# "Return type "int" of "foo" incompatible with return type "str" in supertype "B""
testPreviousErrorInDecoratedMethodOverride
# Signatures of "__ior__" and "__or__" are incompatible
testGenericOperatorMethodOverlapping
testGenericOperatorMethodOverlapping2

# class attributes
testInferAttributeTypeAndAssignInInit
self_instance_variable1
self_instance_variable3

# untyped (inferred?) instance attributes
testChangeBaseClassAttributeType

# class issues
testAddBaseClassAttributeCausingErrorInSubclass
testConstructorSignatureChanged2
testConstructorSignatureChanged3
testFineGrainedCallable
testRefreshSubclassNestedInFunction2
testAliasFineNormalClassBases
# class base Any in combination with overload
testOverloadWithDerivedFromAny

# __new__
testDunderNewUpdatedMethod
testDunderNewUpdatedSubclass
testDunderNewUpdatedAlias
testDunderNewUpdatedCallable
testDunderNewDefine
testDunderNewInsteadOfInit

# Unpacking a string is disallowed
testStringDisallowedUnpacking
# List unpacking
testMultipleAssignmentWithLists
testMultipleAssignmentWithListsInInitialization
testMultipleAssignmentWithListAndIndexing
testMultipleAssignmentAndGenericSubtyping
testInferringLvarTypesInNestedListAssignment
testInferringMultipleLvarDefinitionWithListRvalue
testInferMultipleLocalVariableTypesWithArrayRvalueAndNesting
testUnpackInExpression1-only_when_nocache

# List inference unions are special (list meets)
testListLiteralWithFunctionsErasesNames
testListLiteralWithSimilarFunctionsErasesName
testListLiteralWithNameOnlyArgsDoesNotEraseNames
testLiteralMeets
testLiteralMeetsWithStrictOptional
testInferredTypeIsObjectMismatch
testNestedListExpressions
testLiteralInferredInListContext
testGenericJoinCovariant
testGenericJoinContravariant
testGenericJoinRecursiveTypes
testGenericJoinRecursiveInvariant
testGenericJoinNestedInvariantAny

# List/Set/Dict Inferring type of variable when initialized to an empty collection
testInferListInitialized*
testInferSetInitializedToEmpty
testInferSetInitializedToEmptyUsingDiscard
testInferSetInitializedToEmptyUsingUpdate
testInferDictInitialized*
testSpecialCaseEmptyListInitialization
testSpecialCaseEmptyListInitialization2
testInferListInitializedToEmptyAndAssigned
testInferOrderedDictInitializedToEmpty
testEmptyCollectionAssignedToVariableTwiceIncremental
testEmptyCollectionAssignedToVariableTwiceNoReadIncremental
testInferAttributeInitializedToEmpty*
testInferAttributeInitializedToNoneAndAssigned
testInferAttributeInitializedToNoneAndAssignedOtherMethod
testInferAttributeInitializedToNoneAndAssignedClassBody
testInferFromEmptyDictWhenUsingIn
testInferFromEmptyDictWhenUsingInSpecialCase
testInferListTypeFromInplaceAdd
testInferSetTypeFromInplaceOr
testConditionalExpressionWithEmptyListAndUnionWithAny
testConditionalExpressionWithEmptyIteableAndUnionWithAny

# Type Var Value in func
testCheckGenericFunctionBodyWithTypeVarValues
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testTypeVarValuesAndNestedCalls
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testTypevarValuesSpecialCase1
testGenericTypeAliasesTypeVarConstraints
testWideOuterContextValuesOverlapping
testTypevarValuesWithOverloadedFunctionSpecialCase
testReferenceToDecoratedFunctionAndTypeVarValues
testLiteralAndGenericsRespectsValueRestriction
testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2

# overload argument expression uses context inference multiple times
testBadOverloadProbableMatch
testLiteralAndGenericsWithOverloads
testPreferExactSignatureMatchInOverload
testOverloadInferringArgumentsUsingContext1

# - (with type vars) Overloaded function signatures 2 and 3 overlap with incompatible return types
testOverloadPartialOverlapWithUnrestrictedTypeVar
testOverloadPartialOverlapWithUnrestrictedTypeVarNested
testOverloadedPartiallyOverlappingTypeVarsAndUnion
testOverloadingWithParamSpec
# Overlapping general
testIntersectionTypesAndVarArgs
testLiteralInferredInOverloadContextWithTypevars
testLiteralSubtypeOverlap
overload_overlapping_any

# - Signature of "f" incompatible with supertype "Parent"
testSelfTypeOverrideCompatibility
testSelfTypeOverrideCompatibilityTypeVar-xfail
#     Overload variants must be defined in the same order as they are in "Parent"
testOverrideOverloadSwapped
testOverrideOverloadSwappedWithExtraVariants
testOverrideOverloadSwappedWithAdjustedVariants
testOverrideOverloadedMethodWithMoreSpecificArgumentTypes
testOverloadWithIncompatibleMethodOverrideAndImplementation
testOverloadFaultyClassMethodInheritance
testOverloadClassMethodMixingInheritance
testOverloadFaultyStaticMethodInheritance
testOverloadStaticMethodMixingInheritance
testOverloadStaticMethodImplementation
testOverloadedStaticMethodOnInstance
testUnsafeDunderOverlapInSubclass
# - Overload does not consistently use the "@classmethod" decorator on all function signatures
# - Overload does not consistently use the "@staticmethod" decorator on all function signatures
testOverloadWithInconsistentStaticMethods
# - Condition cannot be inferred, unable to merge overloads
testOverloadIf*
# Overloads are detected in name binder (imports can not be there)
testVeryBrokenOverload
testVeryBrokenOverload2
# overload rename in import (because of name binder issue)
testOverloadByAnyOtherName
# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2
# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload

# Conditional definitions
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionalFuncDefer
testNewAnalyzerConditionallyDefineFuncOverVar
testRedefineFunctionDefinedAsVariableInitializedToNone
testRedefineNestedFunctionDefinedAsVariableInitializedToNone
testConditionalFunctionDefinitionUsingDecorator2
testConditionalFunctionDefinitionUnreachable

# All conditional function variants must have identical signatures
testIncompatibleConditionalFunctionDefinition
testIncompatibleConditionalFunctionDefinition2
testIncompatibleConditionalFunctionDefinition3
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition1
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition2
testIncompatibleConditionalMethodDefinition

# TYPE_CHECKING
testIfTypeCheckingUnreachableClass

# if sys.version
testNewAnalyzerVersionCheck
testNewAnalyzerVersionCheck2
testPromoteMemoryviewToBytes

# isinstance
testLiteralErrorsWithIsInstanceAndIsSubclass
# isinstance flow analysis
testUnionGenericWithBoundedVariable
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues2
testTypeCheckOverloadImplementationTypeVarWithValueRestriction
testTypeCheckOverloadImplementationTypeVarDifferingUsage1
testIntersectionUsingPromotion1
testIntersectionUsingPromotion2
testIntersectionUsingPromotion3
testIntersectionUsingPromotion4
testIntersectionUsingPromotion5
testIntersectionUsingPromotion6
testIntersectionUsingPromotion7
testIntersectionUsingPromotion8
# isinstance & union
testUnion1
testUnion2
testUnion3
testUnionAnyIsInstance
testNestedUnionsProcessedCorrectly
testGenericTypeAliasesUnion
testOverloadsIgnorePromotions
testParamSpecLiteralJoin
testUnionOrSyntaxInIsinstance
testUnionOrSyntaxInIsinstanceNotSupported
# --enable-recursive-aliases & isinstance
testRecursiveAliasBasic
testRecursiveAliasesRestrictions
testRecursiveAliasesRestrictions2
testRecursiveAliasBasicGenericInference
testRecursiveAliasNewStyleSupported
#  --enable-recursive-aliases & is not None
testTupleTypeUpdateNonRecursiveToRecursiveFine
testTypeAliasUpdateNonRecursiveToRecursiveFine
# narrowing if with literals
testConditionalBoolLiteralUnionNarrowing
# narrowing optional with if
testOptionalTypeNarrowedByGenericCall
testOptionalTypeNarrowedByGenericCall2
testOptionalTypeNarrowedByGenericCall3
testOptionalTypeNarrowedByGenericCall5

# Intersection types
testIsInstanceAdHocIntersectionFineGrainedIncrementalNoChange
testIsInstanceAdHocIntersectionFineGrainedIncrementalIsInstanceChange
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnderlyingObjChang
testIsInstanceAdHocIntersectionFineGrainedIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnreachaableToIntersection

# Weird Name binder type definitions (overwritten?)
testLiteralBinderLastValueErased
# weird narrowing
testInferredTypeIsSimpleNestedList
testInferredTypeIsSimpleNestedIterable
testInferredTypeIsSimpleNestedListLoop
testInferredTypeIsSimpleNestedIterableLoop
testNarrowingDownFromPromoteTargetType
testNarrowingDownFromPromoteTargetType2
testNewAnalyzerBuiltinAliasesFixed
testAssignAnyToUnionWithAny
testOverloadsAndNoReturnNarrowTypeNoStrictOptional1
testOverloadsAndNoReturnNarrowTypeWithStrictOptional1
testOverloadsAndNoReturnNarrowTypeNoStrictOptional2
testOverloadsAndNoReturnNarrowTypeWithStrictOptional2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional3
testOverloadsAndNoReturnNarrowTypeWithStrictOptional3

# All conditional function variants must have identical signatures (flow analysis)
testUnionOrderEquivalence

# flow graph
testAssignAndConditionalImport
testAssignAndConditionalStarImport
testRedefineImportedFunctionViaImport
testImportedVariableViaImport

# Multi definition ifs
testNewAnalyzerFirstAliasTargetWins
testNewAnalyzerFirstVarDefinitionWins

# Multiple arguments missing
testMissingPositionalArguments

# Import Redefinition
testRedefineTypeViaImport
# Redefinition (Name "X" already defined on line X)
testGlobalVarRedefinition
testLocalVarRedefinition
testClassVarRedefinition
testMultipleClassDefinitions
testMultipleMixedDefinitions
testMultipleMethodDefinition
testMultipleNestedFunctionDef
testRedefineVariableAsTypevar
testRedefineTypevar
testRedefineTypevar2
testRedefineTypevar3
testRedefineTypevar4
testImportTwoModulesWithSameNameInFunction
testImportTwoModulesWithSameNameInGlobalContext
testTypeRedeclarationNoSpuriousWarnings
testDuplicateDef*
testTypeVarClassDup
testAliasDup
testImportFuncDup
testIgnoredImportDup
testNewAnalyzerRedefinitionAndDeferral*
testNewAnalyzerImportStarForwardRef*
testNewAnalyzerImportOverExistingInCycle
testNewAnalyzerImportOverExistingInCycleStar1
testNewAnalyzerImportOverExistingInCycleStar2
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionallyDefineFuncOverClass
testNewAnalyzerMissingImportErrors
testNewAnalyzerMissingImportErrorsRedefinition
testNewAnalyzerDuplicateTypeVar
testNewAnalyzerDuplicateTypeVarImportCycle
testNewAnalyzerDuplicateTypeVarImportCycleWithAliases
testNewAnalyzerRedefineAsClass
testNewAnalyzerOverrideClassWithTypeAlias
testNewAnalyzerIdentityAssignment*
testProhibitReassigningAliases
testProhibitReassigningSubscriptedAliases
testProhibitReassigningGenericAliases
testUnknownModuleRedefinition
testStarImportOverlappingMismatch
testStarImportOverridingLocalImports
testRedefineFunctionViaImport
testDifferentImportSameNameTwice
testNewAnalyzerRedefineAsOverload
testImportOnTopOfAlias1
testImportOnTopOfAlias2
testUnconditionalRedefinitionOfConditionalFunction
testUnconditionalRedefinitionOfConditionalMethod
testRedefineFunction2
testMissingOverloadDecorator
testDecoratedRedefinitionIsNotOverload
# redefinition overload
testRedefinedOverloadedFunction
testFakeOverloadCrash
testFakeOverloadCrash2
testOverloadNotImportedNoCrash
testSingleOverload2
testCustomRedefinitionDecorator
# Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation
testAliasesInClassBodyNormalVsSubscripted
# Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2
# Incompatible redefinition (redefinition with type "Callable[[Any], Any]", original type "Callable[[], Any]")
testRedefineFunctionDefinedAsVariableWithInvalidSignature
# Incompatible redefinition
testRedefineFunctionDefinedAsVariableInitializedToEmptyList
# NewType Redefinition
testNewAnalyzerNewTypeRedefinition

# syntax errors
testPreferPackageOverFile
testPreferPackageOverFile2
testTrailingCommaParsing
testTrailingCommaInIfParsing

# Yield
testYieldOutsideFunction
testYieldFrom

# async/await
testAwaitCoroutine
testAwaitDefaultContext
testAwaitAnyContext
testAwaitExplicitContext
testAwaitGeneratorError
testAwaitIteratorError
testAwaitArgumentError
testAwaitResultError
testAwaitReturnError
testYieldFromNoAwaitable
testAwaitableSubclass
testAwaitOverloadSpecialCase
testUnusedAwaitable
testAwaitMissingNote
testAsyncGeneratorExpressionAwait
testAwaitAndAsyncDef-only_when_nocache
testAwaitAnd__await__-only_when_nocache
testAsyncWith2-only_when_nocache
test__aiter__and__anext__

# "Cannot determine type of"
testThreePassesRequired
testAccessGlobalVarBeforeItsTypeIsAvailable
testAccessDataAttributeBeforeItsTypeIsAvailable
testMultipassAndTopLevelVariable
testMultipassAndCircularDependency

# {**kwargs}
testSubtypingMappingUnpacking1
testSubtypingMappingUnpacking2
testSubtypingMappingUnpacking3
testNotDirectIterableAndMappingSubtyping
testUnpackInExpression3-only_when_nocache

# "???" does not return a value / Function does not return a value
testCallingVarArgsFunction
testFunctionTypeCompatibilityWithOtherTypes
testLvarInitializedToVoid
testForStatementInferenceWithVoid

# None late binding, because it's None (x = None; x = 3)
*PartialType*
testAssigningAnyStrToNone
testLocalVariablePartiallyInitializedToNone
testLocalVariablePartiallyTwiceInitializedToNone
testGvarPartiallyInitializedToNone
testPartiallyInitializedToNone*
testPartiallyInitializedVariableDoesNotEscapeScope2
testAttributePartiallyInitializedToNoneWithMissingAnnotation
testGlobalInitializedToNoneSetFromFunction
testGlobalInitializedToNoneSetFromMethod
testNoCrashOnPartialVariable
testNoCrashOnPartialVariable3

# "Cannot call function of unknown type"
testUnknownFunctionNotCallable

# Implicit any param
testKwargsArgumentInFunctionBodyWithImplicitAny

# Weird Decorator Cases
testOverloadWithErrorDecorator
testBoundOnDecorator
testGenericClassPropertyBound
testOverloadDeferredNode
# Class decorator
testDecoratingClassesThatUseParamSpec

# "Decorators on top of @property are not supported"
testDecoratedProperty

# Function Not checked, missing return annotations (check-untyped)
testPositionalAndKeywordForSameArg
testTypeCheckOverloadWithImplementationError

# function type mismatch when untyped
testSubtypingFunctionsImplicitNames

# Global
testAssignToFuncDefViaGlobalDecl2

# Nonlocal
testInvalidNonlocalDecl
testNonlocalDeclNotMatchingGlobal
testNonlocalDeclConflictingWithParameter
testNonlocalDeclOutsideFunction
testGlobalAndNonlocalDecl
testNonlocalAndGlobalDecl
testNewAnalyzerRedefinedNonlocal

# __init__ None needed
testInitReturnTypeError

# Need type annotation for "X"
testNewAnalyzerLessErrorsNeedAnnotation
testNewAnalyzerLessErrorsNeedAnnotationNested
testErrorInTypeCheckSecondPassThroughPropagation
testGenericFunctionOnReturnTypeOnly
testUnderspecifiedInferenceResult
testNoCrashOnPartialMember
testDontMarkUnreachableAfterInferenceUninhabited
testDontMarkUnreachableAfterInferenceUninhabited2
testDontMarkUnreachableAfterInferenceUninhabited3
testNeedAnnotationForCallable
testPartialDefaultDict*
testInferenceOfFor1
testInferenceOfFor2
testInferenceOfFor3
testInferLocalVariableTypeWithUnderspecifiedGenericType
testLocalVariableInferenceFromEmptyList
testNoPartialInSupertypeAsContext
testSuggestPep604AnnotationForPartialNone

# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames

# "Perhaps you need a type annotation for "x"? Suggestion: "List[str | int]""
testInferredTypeSubTypeOfReturnType

# Too many values to unpack (2 expected, 3 provided)
testInferringLvarTypesInMultiDefWithInvalidTuple

# Type[Any] is object
testSimplifyingUnionWithTypeTypes2

# Foo = type(...) used as `x: Foo` (type execution)
testNoneAlias
testNoneAliasStrict

# Module __getattr__
testNewAnalyzerModuleGetattrSerialize_incremental
testModuleLevelGetattr*
testModuleGetattr*
testModuleGetAttr*

# attrs
testAttrs*

# Special case for assignment to '_'
testUnusedTargetLocal
testUnusedTargetNotClass
testUnusedTargetNotClass2
testUnusedTargetTupleUnpacking
testUnusedTargetMultipleTargets
testUnusedTargetNotImport
testUnderscoreClass
testUnusedTargetForLoop
testUnusedTargetWithClause
testUnusedTargetNotExceptClause

# weird files
testScriptsAreNotModules

# Literal with ?
testNewAnalyzerBool
testCallerTupleVarArgsAndGenericCalleeVarArg

# Formatting qualified module names
testSubmoduleMixingImportFromAndImport2
testErrorFromGoogleCloud
testStubPackageSubModule
testReExportChildStubs3
testImportFromReExportInCycleUsingRelativeImport1
testImportReExportInCycleUsingRelativeImport2

# Formatting class in reveal_type (stashed in 860494e, see also https://github.com/python/mypy/issues/13062)
testNewAnalyzerShadowOuterDefinitionBasedOnOrderTwoPasses
testNewAnalyzerPlaceholderFromOuterScope
testAliasInImportCycle3
testNewAnalyzerTypeVarForwardReferenceErrors

# Aliases in Mypy define generics as X = Foo as Foo[Any, Any]
testAliasToTupleAndCallable
testNewAnalyzerAliasesFixedFew
testNewAnalyzerAliasesFixedMany

# Formatting Module as types ("ModuleType" instead of Module)
testInvalidOperationsOnModules
testConditionalImportAndAssignInvalidToModule
testModuleAliasRepeatedWithAnnotation

# NewType formatting instead of internal type
testNewTypeDependencies3

# tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5

# parser recovery in type comments / types in string literals
testInvalidStrLiteralSpaces
testInvalidStrLiteralStrayBrace
testInvalidMultilineLiteralType
testLiteralInvalidString

# Syntax error in type annotation
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2
# Suggestion: Use tuple[()] instead of () for an empty tuple, or None for a function without a return value
testReturnEmptyTuple

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same error twice
testOperatorAssignmentWithIndexLvalue1

# Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4

# EllipsisType
testUnionWithEllipsis
# Ellipsis / raise NotimplementedError / pass are considered stubs in normal files 
testEllipsisDefaultArgValueInNonStub
testEllipsisDefaultArgValueInNonStubsMethods

# The type "Type[type]" is not generic and not indexable
testTypeApplicationCrash

# "bool" is not a valid base class
testTestExtendPrimitives

# "By default the bodies of untyped functions are not checked, consider using --check-untyped-defs"
testContextForAttributeDeclaredInInit

# Probably fixed eventually by updating mypy or typeshed
testDecoratorTypeAfterReprocessing

# type: ignore leads to Any type?
testDunderCallAddition

# Very weird annotation resolution order
testNewAnalyzerAnnotationConflictsWithAttributeSinglePass
testNewAnalyzerAnnotationConflictsWithAttributeTwoPasses
testNewAnalyzerNameConflictsAndMultiLineDefinition

# pyproject.toml
testMultipleModulesInOverridePyProjectTOML
testIgnoreErrorFromMissingStubs1
testIgnoreErrorFromMissingStubs2

# mypy.ini
testRefreshIgnoreErrors1
testRefreshIgnoreErrors2
testRefreshOptions

# mypy extensions
testFlexibleAlias1
testFlexibleAlias2
testFlexibleAlias3

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext

# --allow-untyped-globals
testPermissiveAttributeOverride1

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testUnlimitedStubErrorVolume

# --disallow-any-generics
testErrorReportingNewAnalyzer

# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --pretty
testReprocessMethodShowSource
testGenericTypeAliasesWithNestedArgs
testPrettyMessageSorting

# syntax not yet supported
testBreakOutsideLoop
testContinueOutsideLoop
testInvalidGlobalDecl
testAssignToTypeDef

# parser shit
testInvalidLvalues*
testTwoStarExpressions
testTwoStarExpressionsInForStmt
testTwoStarExpressionsInGeneratorExpr
testStarExpressionRhs
testStarExpressionInExp
testInvalidDel1
testInvalidDel2
testInvalidDel3
testInvalidTypeDeclaration
testIndexedAssignmentWithTypeDeclaration
testInvalidLvalueWithExplicitType
testInvalidLvalueWithExplicitType3
testInvalidWithTarget
testInvalidTypeAnnotation2

# `for ... in` type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2

# Won't support for now: "t" is a type variable and only valid in type context
testExpressionRefersToTypeVariable

# Probably won't support: typing._promote
testListWithDucktypeCompatibility
testListWithDucktypeCompatibilityAndTransitivity

# Probably won't support Type Var formatting
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName

# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments
testNestedFunctionInMethodWithTooFewArgumentsInTypeComment
testDeepNestedFunctionWithTooFewArgumentsInTypeComment
testDeepNestedMethodInTypeComment
testEllipsisWithArbitraryArgsOnBareFunctionWithKwargs
testEllipsisWithArbitraryArgsOnBareFunctionWithVarargs
testEllipsisWithSomethingAfterItFails
testEllipsisWithSomethingBeforeItFails
testMethodDefaultArgumentsAndSignatureAsComment
testDefaultArgumentsAndSignatureAsComment
testLiteralInsideOtherTypesTypeCommentsPython3
testLiteralInvalidTypeComment
testLiteralInvalidTypeComment2

# --scripts-are-modules
testScriptsAreModules

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testInlineConfigFineGrained1
testInlineConfigFineGrained2

# Won't support: __eq__ called directly with a keyword argument (which is actually legal)
testMagicMethodPositionalOnlyArg
testMagicMethodPositionalOnlyArgFastparse

# Won't support: reveal_locals
testRevealLocalsFunction

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Union Pipe "|" not allowed in 3.9
testUnionOrSyntaxWithinRuntimeContextNotAllowed
testUnionOrSyntaxWithinRuntimeContextNotAllowed2
testUnionOrSyntaxMissingFutureImport

# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support ever: python 2
testMypyPathAndPython2Dir

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testNoSubscriptionOfBuiltinAliases

# Won't support --disable-recursive-alias
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerAliasToNotReadyDirectBaseFunction
testNewAnalyzerNewTypeForwardClassAliasDirect
testNewAnalyzerForwardTypeAliasInBase
testRecursiveForwardReferenceInUnion
testRecursiveAliasesErrors1
testRecursiveAliasesErrors2
testJSONAliasApproximation

# Mypy test case issues
# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred

# Not working in interpreter
# Recursive class inheritance
testNewAnalyzerAliasToNotReadyNestedClass

# Skips
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testOverloadInferringArgumentsUsingContext2-skip
testUnionTwoPassInference-skip
testLiteralErrorsWhenInvoked-skip
