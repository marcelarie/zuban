# Next up
testInferTypeVariableFromTwoGenericTypes4

nested_generic_mismatch_*
union_context_class_matching
contravariant_type_var
type_var_*
testGenericTypeAliasesBasic2
testGenericTypeAliasesRuntimeExpressionsOther

testNewAnalyzerAliasToNotReadyTwoDeferralsFunction
testForwardTypeAlias
testForwardTypeAliasGeneric
testTypeCheckPrio
testSubtypingFunctionsDoubleCorrespondence
testSubtypingFunctionsRequiredLeftArgNotPresent
testCallableWithArbitraryArgsSubtyping
testFunctionReturningGenericFunctionPartialBinding
testVarArgsFunctionSubtyping
testAliasFineGenericToNonGeneric

testSubtypingFunctionsDefaultsNames
testRedefineFunction
testOverloadInferringArgumentsUsingContext1

testBoundOnGenericFunction
testBoundGenericFunctions

testUnionContext
testWideOuterContextOptional
testWideOuterContextOptionalGenericReturn
testUseCovariantGenericOuterContext

testComplexTypeInferenceWithTuple

testOverloadWithOverlappingItemsAndAnyArgument1

testOverloadAnyIsConsideredValidReturnSubtype
testOverloadsTypesAndUnions
# Type var: Cannot infer type argument
testGenericTypeAliasesPEPBasedExample
testGenericTypeAliasesImporting

# Union type var matching weird cases
testUnionInference
unite_type_vars_mypy_issue_5874
# Union Not matching type vars
testJoinUnionWithUnionAndAny

overload_not_overlapping_none
overload_unmatchable_none
overload_not_overlapping_optional
overload_overlapping_any
type_var_value_restriction_in_callable
subtyping_only_result_generics
subtyping_complex_generics
callable_cannot_infer_type_var
union_context_class_matching_with_any
union_context_class_matching_with_overload
callable_return_from_method_nested_multiple1

testGenericFunctionSubtypingWithUnions
testOverloadOverlapWithTypeVars

# func type var in __init__
testInvalidNumberOfTypeArgs
testInheritedConstructor2

# weird returns
testOverloadWithOverlappingItemsAndAnyArgument5

# Function Subtyping inverse type var binding
testSubtypingWithGenericFunctionUsingTypevarWithValues
testGenericFunctionSubtypingWithTypevarValues
testSubtypingWithGenericFunctions
testSubtypingWithGenericInnerFunctions
testGenericFunctionsWithUnalignedIds
# callable return type to param bottom up
testCallableWithArbitraryArgsSubtypingWithGenericFunc

# Overloading
testOverloadBadArgumentsInferredToAny1
testOverloadBadArgumentsInferredToAny2
testOverloadedCallWithVariableTypes
testOverloadOverlapWithTypeVarsWithValues
testOverloadMultipleVarargDefinitionComplex

testOverloadsUsingAny
testOverloadWithOverlappingItemsAndAnyArgument4
testOverloadWithOverlappingItemsAndAnyArgument9
testOverloadWithOverlappingItemsAndAnyArgument14
testOverloadWithOverlappingItemsAndAnyArgument15
testOverloadWithOverlappingItemsAndAnyArgument16

testOverloadWithDerivedFromAny

# overload any fallback
testCovariantOverlappingOverloadSignaturesWithAnyType
testContravariantOverlappingOverloadSignaturesWithAnyType
testAnyIsOKAsFallbackInOverloads

# Overload List item 0 should not be generated on ALL mismatches
testPreferExactSignatureMatchInOverload
# Overload inference issue
testBadOverloadProbableMatch

# - No overload variant of "f" matches argument types "A", "A"
#     -> f(*(1,))() # E: No overload variant of "f" matches argument type "Tuple[int]"
# - No overload variant of "__add__" of "A" matches argument type "str"
# - wtf Value of type variable "AnyStr" of "g" cannot be "Sequence[object]
testOverloadsGenericTypevarUpdated
# - wtf Argument 2 to "f" has incompatible type "Tuple[int, str]"; expected "Tuple[str, ...]"
# - wtf Argument 1 to "single_plausible" has incompatible type "Type[Other]"; expected "Type[int]"
# - wtf Argument 1 to "f1" has incompatible type "Union[A, B]"; expected "A"
#       Argument 1 to "foo" has incompatible type "Union[WrapperCo[A], WrapperContra[C]]"; expected "WrapperCo[B]"
testOverloadInferUnionReturnBasic
testOverloadInferUnionReturnMultipleArguments
testOverloadInferUnionRespectsVariance
testUnionMathTrickyOverload1
testUnionMathTrickyOverload2
testManyUnionsInOverload
# - 3352-3500 Union/Type vars/overloads weird combinations
testOverloadInferUnionIfParameterNamesAreDifferent
testOverloadInferUnionReturnFunctionsWithKwargs
testOverloadInferUnionWithDifferingLengths
testOverloadInferUnionWithMixOfPositionalAndOptionalArgs
testOverloadingInferUnionReturn*
testOverloadInferUnionReturnWithInconsistentTypevarNames
# - Condition cannot be inferred, unable to merge overloads
testOverloadIf*
# - Not all union combinations were tried because there are too many unions
testTooManyUnionsException
# - An overloaded function outside a stub file must have an implementation
# - Signature of "f" incompatible with supertype "Parent"
#     Overload variants must be defined in the same order as they are in "Parent"
testOverrideOverloadSwapped
testOverrideOverloadSwappedWithExtraVariants
testOverrideOverloadSwappedWithAdjustedVariants
testOverrideOverloadedMethodWithMoreSpecificArgumentTypes
testOverloadWithIncompatibleMethodOverrideAndImplementation
testOverloadFaultyClassMethodInheritance
testOverloadClassMethodMixingInheritance
testOverloadFaultyStaticMethodInheritance
testOverloadStaticMethodMixingInheritance
testOverloadStaticMethodImplementation
testUnsafeDunderOverlapInSubclass
# - Single overload definition, multiple required
# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2

# - Overloaded function signatures 2 and 3 overlap with incompatible return types
testOverloadConstrainedTypevarNotShadowingAny
testOverloadBoundedTypevarNotShadowingAny
testOverloadPartialOverlapWithUnrestrictedTypeVar
testOverloadPartialOverlapWithUnrestrictedTypeVarNested
testOverloadPartialOverlapWithUnrestrictedTypeVarInClass
testOverloadPartialOverlapWithUnrestrictedTypeVarInClassNested
testOverloadedPartiallyOverlappingTypeVarsAndUnion
testOverloadPartiallyOverlappingTypeVarsIdentical
testNestedOverloadsTypeVarOverlap
# - Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
testOverloadOverlapWithTypeVarsWithValuesOrdering
testOverloadWithNonPositionalArgsIgnoresOrder
testOverloadFlagsPossibleMatches
testOverloadPossibleOverlapMixingNamedArgsWithKwargs
testOverloadRefresh

# - Overloaded function implementation does not accept all possible arguments of signature 2
testTypeCheckOverloadWithImplTooSpecificArg
# - Overloaded function implementation cannot produce return type of signature 2
testOverloadWithMethodOverrideAndImplementation
testTypeCheckOverloadWithImplTooSpecificRetType
testPreviousErrorInOverloadedFunction
testOverloadsUpdatedTypeRechekConsistency
testOverloadClassMethodImplementation
testOverloadItemHasMoreGeneralReturnType
# - Overloaded function implementation cannot satisfy signature 2 due to inconsistencies in how they use type variables
testTypeCheckOverloadWithImplTypeVarProblems
# - Overload does not consistently use the "@classmethod" decorator on all function signatures
# - Overload does not consistently use the "@staticmethod" decorator on all function signatures
testOverloadWithInconsistentStaticMethods

# OverloadFunction class
testTypevarValuesWithOverloadedFunctionSpecialCase
testIntersectionTypeCompatibility
testVeryBrokenOverload
testVeryBrokenOverload2
testFunctionTypesWithOverloads
testOverloadWithThreeItems
testMapWithOverloadedFunc
# overload self type
testOverloadAndSelfTypes
# overload operator
testOverloadedLtAndGtMethods
testOverloadedForwardMethodAndCallingReverseMethod
testTypeInferenceSpecialCaseWithOverloading
# overload rename in import
testOverloadByAnyOtherName
# overload none matching in non strict
testOptionalIsNotAUnionIfNoStrictOverload
testOptionalIsNotAUnionIfNoStrictOverloadStr

# Overload -> None formatting
testCallToOverloadedFunction
testCallToOverloadedMethod
testOverloadsRemovedOverload
testOverloadsGenericToNonGeneric
testCallableSpecificOverload
testOverloadErrorMessageManyMatches
# overloading for loop
testOverloadedInIter

# Overloading generated messages that were not necessary
testSubtypingIterableUnpacking1
testSubtypingIterableUnpacking2

# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload

# Param spec
testCallableWithNamedArg
testCallableWithOptionalArg
testCallableWithNamedArgFromExpr
testCallableWithOptionalArgFromExpr
testCallableParsingSameName
testCallableParsingFromExpr
testCallableParsing
testCallableTypeAnalysis
testCallableWrongTypeType
testCallableTooManyVarArg
testCallableFastParseGood
testCallableFastParseBadArgArgName
testCallableKindsOrdering
testCallableDuplicateNames
testCallableWithKeywordOnlyArg
testCallableWithKeywordOnlyOptionalArg
testCallableWithKwargs
testCallableWithVarArg
testCallableArgKindSubtyping
testParamSpec
testOverloadingWithParamSpec
testReprocessCallableArg

# Cannot use a covariant type variable as a parameter
testRejectCovariantArgument
testRejectCovariantArgumentSplitLine
testRejectCovariantArgumentInLambda
# Cannot use a contravariant type variable as return type
testRejectContravariantReturnType
testAcceptCovariantReturnType
testAcceptContravariantArgument

# Union of empty lists dicts sets with used ones
testUnificationEmptyList*
testUnificationEmptySet*
testUnificationEmptyDict*
testUnificationDictWithEmptyList*
testMisguidedSetItem

# Duplicate in Union
testUnionMethodCalls
testUnificationRedundantUnion

# Duplicate base class
testIncludingBaseClassTwice

# Cycles
testCyclicUndefinedImportWithName
testCyclicUndefinedImportWithStar1
testCyclicUndefinedImportWithStar2
testNewAnalyzerTypeAnnotationCycle4
testNewAnalyzerAliasToNotReadyMixed
testNewAnalyzerVarTypeVarNoCrashImportCycle
testNewAnalyzerFuncTypeVarNoCrashImportCycle
testRecursiveForwardReferenceInUnion
# Class generics cycles / + type alias cycles
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerAliasToNotReadyDirectBaseFunction
testNewAnalyzerForwardTypeAliasInBase
testRecursiveAliasesErrors*
testJSONAliasApproximation
testChangeBaseClassAttributeType
testGenericTypeBody1
# Class inheritance cycles
testNewAnalyzerAliasToNotReadyNestedClass
testNewAnalyzerAliasToNotReadyNestedClass2

# Module attributes
testModuleImplicitAttributes
# Function attributes
testInvalidRvalueTypeInInferredMultipleLvarDefinition

# boolean operators
testOrOperationWithGenericOperands
testOrOperationInferredFromContext

# Type Var Value in func
testCheckGenericFunctionBodyWithTypeVarValues
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testTypeVarValuesAndNestedCalls
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testTypevarValuesSpecialCase1
testGenericTypeAliasesTypeVarConstraints

testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2

# Bound with Union: Item "{}" of the upper bound "{}" of type variable "{}" has no attribute "{}"
testTypeVarBoundToOldUnionAttributeAccess
testTypeVarBoundToNewUnionAttributeAccess

# questionable list/dict type inference
testInferredTypeIsObjectMismatch
testCallableListJoinInference

# Tuple type var context
testInferenceWithTypeVariableTwiceInReturnType
testInferenceWithTypeVariableTwiceInReturnTypeAndMultipleVariables
# bottom up inference list multiply
testListMultiplyInContext
# bottom up dict
testDictionaryLiteralInContext

# Union nothing should disappear
testUnionWithGenericTypeItemContext
testUnionWithGenericTypeItemContextInMethod

# nothing is displayed (probably also used as Any)
tuple_methods_empty

# Type variable "C.T" cannot be used as an expression
testClassMemberTypeVarInFunctionBody

# "Cannot declare the type of a TypeVar or similar construct" (semanal)
testTypevarWithType

# Chained assignments are not legal like a = b = [] if a and b are list[int]
# and list[str].
testChainedAssignmentInferenceContexts

# Literal
testNewAnalyzerBool
testNoneHasBool
testNoneHasBoolShowNoneErrorsFalse
testLiteral*

# int -> float promotion
testNewAnalyzerPromotion
testProhibitUsingVariablesAsTypesAndAllowAliasesAsTypes
testSimplifyingUnionAndTypePromotions
testFlattenTypeAliasWhenAliasedAsUnion
testOverloadingAndIntFloatSubtyping

# Nested type vars
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues

# function call in class of function in class
testCallConditionalMethodInClassBody

# Class in function special cases
testNewAnalyzerUnsupportedBaseClassInsideFunction
testInfiniteLoop

# Nested class / class in class
testGenericClassInsideOtherGenericClass

# Class: generic access from outside
testGenericTypeAliasesTypeVarBinding
# Class alias with class type var prohibited
testProhibitBoundTypeVariableReuseForAliases
# General Scoping
testGenericInnerClass
testGenericClassInnerFunctionTypeVariable
testListComprehensionSpecialScoping

# Property
testNonMethodProperty
testInvalidArgCountForProperty
testNewAnalyzerProperty
testNewAnalyzerNoCrashOnCustomProperty
testOverloadNotConfusedForProperty
testForwardReferenceToDynamicallyTypedProperty
testForwardReferenceToStaticallyTypedProperty
# Decorated property not supported
testOverloadedProperty
testOverloadedProperty2

# descriptors
testOverloadWithNonGenericDescriptor
testOverloadWithNonGenericDescriptorLookalike
testOverloadWithGenericDescriptor
testOverloadWithGenericDescriptorLookalike

# classmethod
testAliasToClassMethod
testGenericClassMethod*
testClassmethodAndNonMethod
testAddBaseClassMethodCausingInvalidOverride
testModifyBaseClassMethodCausingInvalidOverride
testClassImportAccessedInMethod
testSelfTypeVarIndexExpr
testNewAnalyzerTypeVarBoundInCycle
testOverloadClassmethodDisappears
testOverloadWithClassMethods
testOverloadWithInconsistentClassMethods
testOverloadAndClassTypes
testForwardReferenceToDynamicallyTypedClassMethod
testForwardReferenceToStaticallyTypedClassMethod
testGenericClassClsNonGeneric
testGenericClassUnrelatedVars
testGenericClassDirectCall
testGenericClassInGenericFunction*
testGenericClassAlternativeConstructorPrecise*
testNoGenericAccessOnImplicitAttributes

# staticmethod
testStaticmethodAndNonMethod
testBoundStaticMethod
testForwardReferenceToDynamicallyTypedStaticMethod
testForwardReferenceToStaticallyTypedStaticMethod

# All conditional function variants must have identical signatures
testIncompatibleConditionalFunctionDefinition*
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition1
testConditionalRedefinitionOfAnUnconditionalFunctionDefinition2
testIncompatibleConditionalMethodDefinition

# NamedTuple
*NamedTuple*
testNewAnalyzerTupleIteration
testDistinctTypes
testInfiniteLoop2
testNewAnalyzerTypeArgBoundCheckDifferentNodes
testRegression11705_NoStrict
testNewAnalyzerCastForward3
# namedtuple
testCallableParsingInInheritence


# Typing stuff
testInvalidAssertType
testInvalidAnyCall
testInvalidTypeInTypeApplication
testBaseClassAnnotatedWithoutArgs
*Pep613
*Abstract*
*Final*

# TYPE_CHECKING
testIfTypeCheckingUnreachableClass

# stdlib
testDataclass*
testAttrs*
*PartialType*
*NewType*
*Enum*
*TypedDict*

# NoReturn
testNoReturnTypeAlias
testUnionWithNoReturn
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2
testDontNeedAnnotationForCallable

# Type application vs. type declaration
testNewAnalyzerAliasToNotReadyClassDoubleGeneric
testTypeAliasesResultingInPlainInstance

# typing.no_type_check
*NoTypeCheck*

# Incomplete Unions: `int | int`
testNewAnalyzerForwardAliasFromUnion
# Union simplification
testUnionSimplification*
testSimplifyingUnionWithTypeTypes2
testNewAnalyzerBuiltinAliasesFixed
testSimplifyUnionWithCallable

# Union attribute error: Item "D" of "C | D" has no attribute "y"
testUnionAttributeAccess

# Union iter()
testUnionMultiassignSingle
testUnionMultiassignDouble
testUnionMultiassignGeneric
testUnionMultiassignAny
testUnionMultiassignNotJoin
testUnionMultiassignRebind
testUnionMultiassignAlreadyDeclared
testUnionMultiassignIndexed
testUnionMultiassignIndexedWithError
testUnionMultiassignPacked
testUnpackingUnionOfListsInFunction
testUnionOfVariableLengthTupleUnpacking
testUnionOfNonIterableUnpacking
testUnionAlwaysTooMany
testUnionAlwaysTooFew
testUnionUnpacking*
testNestedUnionUnpackingFromNestedTuples
testNestedUnionUnpackingFromNestedTuplesBinder
testUnpackUnionNoCrashOnPartialNone*
testReusingInferredForIndex*
testNestedProtocolUnions
testNestedProtocolGenericUnions
testNestedProtocolGenericUnionsDeep
testNestedInstanceUnsimplifiedUnion
testNestedInstanceTypeAlias
testNestedInstanceTypeAliasUnsimplifiedUnion

# Unpacking a string is disallowed
testStringDisallowedUnpacking

# BoundMethod class
testKwargsAllowedInDunderCall
testKwargsAllowedInDunderCallKwOnly

# Dynamic functions are not type checked?!
testNoInvalidTypeInDynamicFunctions
testCallGenericFunctionWithTypeVarValueRestrictionInDynamicFunc
testDynamicallyTypedNestedFunction
testInferringImplicitDynamicTypeForLvar
testInferringMultipleLvarDefinitionWithImplicitDynamicRvalue
# Dynamic functions are ignored in classes and the super class is used?
testInferringTypesFromIterable

# Comprehensions
testNewAnalyzerListComprehension
testNewAnalyzerDictionaryComprehension

# if sys.version
testNewAnalyzerVersionCheck*

# lambda
testGenericTypeAliasesCallable
testNewAnalyzerVarTypeVarNoCrash
testOverloadLambdaUnpackingInference
testOverloadedToGeneric
testLambdaSemanal
testLambdaTypeCheck
testLambdaTypeInference
testLambdaDefaultTypeErrors
testInferLambdaType
testInferLambdaType2
testUninferableLambda
testUninferableLambdaWithTypeError
testInferLambdaNone
testLambdaDefaultContext
testLambdaVarargContext
testLambdaDeferredSpecialCase
testInferCallableReturningNone1
testInferCallableReturningNone2
testErasedTypeRuntimeCoverage
# Lambda with defined return types (inferred context)
testInferLambdaArgumentTypeUsingContext
testInferLambdaReturnTypeUsingContext
testInferLambdaTypeUsingContext
testInferLambdaAsGenericFunctionArgument
testLambdaWithoutContext
testLambdaContextVararg
testInvalidContextForLambda
testEllipsisContextForLambda
testEllipsisContextForLambda2
testLambdaNoneInContext
testIsinstanceInInferredLambda
testLambdaInListAndHigherOrderFunction
testLambdaInGenericFunction
testLambdaInGenericClass
testLambdaDeferredCrash
testWideOuterContextOptionalTypeVarReturnLambda

# Conditional definitions
testNewAnalyzerConditionalFunc*
testNewAnalyzerConditionallyDefineFuncOverVar
testRedefineFunctionDefinedAsVariableInitializedToNone
testRedefineNestedFunctionDefinedAsVariableInitializedToNone

# isinstance flow analysis
testUnionGenericWithBoundedVariable
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues*
testTypeCheckOverloadImplementationTypeVarWithValueRestriction
testTypeCheckOverloadImplementationTypeVarDifferingUsage1
# isinstance & union
testUnion1
testUnion2
testUnion3
testUnionAnyIsInstance
testNestedUnionsProcessedCorrectly
testGenericTypeAliasesUnion
testOverloadsIgnorePromotions

# weird narrowing
testInferredTypeIsSimpleNestedList
testInferredTypeIsSimpleNestedIterable
testInferredTypeIsSimpleNestedListLoop
testInferredTypeIsSimpleNestedIterableLoop

# check after flow analysis
testAssignAnyToUnionWithAny

# All conditional function variants must have identical signatures (flow analysis)
testUnionOrderEquivalence

# Visibility of imports in pyi
testNewSemanticAnalyzerModulePrivateRefInMiddleOfQualified

# typing extensions
testInvalidUnpackTypes
testTypeVarTuple
testRuntimeProtoTwoBases

# mypy extensions
testFlexibleAlias*

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext

# stdlib imports
testOverloadSpecialCase
testSubclassingGenericABCWithImplicitAny
testSubclassingGenericABCWithImplicitAnyAndDeepHierarchy
testImplementingGenericABCWithImplicitAnyAndDeepHierarchy2
testInvariance
testSubtypingAndABCExtension
testAccessingGenericABCMembers
testAccessingInheritedGenericABCMembers
testPrecedenceOfFirstBaseAsInferenceResult
type_var_with_co_and_contra_real_life

# Module __all__
testNewAnalyzerExportedValuesInImportAll
testExportedValuesInImportAll
testAllMustBeSequenceStr*
testUnderscoreExportedValuesInImportAll
testReExportAllInStub

# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions

# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testKeywordMisspelling
testMultipleKeywordsForMisspelling
testKeywordMisspelling*

# Import submodules
testNewAnalyzerImportStarSpecialCase

# Submodule was not imported
testSubmoduleImportFromDoesNotAddParents
testSubmoduleMixingImportFromAndImport

# import a.b.c issues
testMissingSubmoduleImportedWithIgnoreMissingImports*
testMissingSubmoduleOfInstalledStubPackage
testGenericAliasCollectionsABCReveal

# Complex Star import
testImportWithinMethod

# Module __getattr__
testNewAnalyzerModuleGetattrSerialize_incremental
testModuleLevelGetattr*
testModuleGetattr*
testModuleGetAttr*

# Module type does not contain module info
testMultiModuleAlias
testModuleAliasWithExplicitAnnotation

# namespace packages
testClassicNotPackage
testNamespacePackage*
testClassicPackageIgnoresEarlierNamespacePackage
testClassicPackageInsideNamespacePackage

# Stub Reexport
testNoReExportFromStubs*
testNoReExportChildStubs
testReExportChildStubs
testNoReExportNestedStub
testNoReExportFromMissingStubs
testMissingGenericImport
testStubFixupIssues

# Import itself / Extremely weird import orders
testNewAnalyzerImportCycleWithIgnoreMissingImports
testNewAnalyzerImportFromTopLevelFunction
testNewAnalyzerImportFromTopLevelAlias
testNewAnalyzerImportAmbiguousWithTopLevelFunction
testReExportChildStubs
testReExportChildStubs2
testImportCycleSpecialCase
testPackagePath

# Multi definition ifs
testNewAnalyzerFirstAliasTargetWins
testNewAnalyzerFirstVarDefinitionWins

# Multiple arguments missing
testMissingPositionalArguments

# Redefinition (Name "X" already defined on line X)
testGlobalVarRedefinition
testLocalVarRedefinition
testClassVarRedefinition
testMultipleClassDefinitions
testMultipleMixedDefinitions
testMultipleMethodDefinition
testMultipleNestedFunctionDef
testRedefineVariableAsTypevar
testRedefineTypevar*
testImportTwoModulesWithSameNameInFunction
testImportTwoModulesWithSameNameInGlobalContext
testTypeRedeclarationNoSpuriousWarnings
testDuplicateDef*
testTypeVarClassDup
testAliasDup
testImportFuncDup
testIgnoredImportDup
testNewAnalyzerRedefinitionAndDeferral*
testNewAnalyzerImportStarForwardRef*
testNewAnalyzerImportOverExistingInCycle*
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionallyDefineFuncOverClass
testNewAnalyzerMissingImportErrors*
testNewAnalyzerDuplicateTypeVar*
testNewAnalyzerRedefineAsClass
testNewAnalyzerOverrideClassWithTypeAlias
testNewAnalyzerIdentityAssignment*
testProhibitReassigning*
testUnknownModuleRedefinition
testStarImportOverlappingMismatch
testStarImportOverridingLocalImports
testRedefineFunctionViaImport
testDifferentImportSameNameTwice
testNewAnalyzerRedefineAsOverload
testImportOnTopOfAlias1
testImportOnTopOfAlias2
testUnconditionalRedefinitionOfConditionalFunction
testUnconditionalRedefinitionOfConditionalMethod
testRedefineFunction2
# redefinition overload
testRedefinedOverloadedFunction
testFakeOverloadCrash
testFakeOverloadCrash2
testOverloadNotImportedNoCrash
testSingleOverload2
# Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation
testAliasesInClassBodyNormalVsSubscripted
# Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2
# Incompatible redefinition (redefinition with type "Callable[[Any], Any]", original type "Callable[[], Any]")
testRedefineFunctionDefinedAsVariableWithInvalidSignature
# Incompatible redefinition
testRedefineFunctionDefinedAsVariableInitializedToEmptyList

# BoundMethod type
testForwardReferenceToListAlias

# Metaclass
*Metaclass*
testNewAnalyzerClassKeywordsError
testNewAnalyzerNotAnAlias
testNewAnalyzerClassPropertiesInAllScopes
testIgnoredAttrReprocessedMeta
testImplementingOverloadedMethod

# Signature of "???" incompatible with supertype "???"
testKeywordOnlyArgumentOrderInsensitivity
testPositionalOverridingArgumentNamesCheckedWhenMismatchingPos
testOverrideGenericMethodInNonGenericClassLists
testOverrideGenericMethodInNonGenericClassGeneralize
testOverloadedMethodSupertype-only_when_cache
testOverloadedMethodSupertype2-only_when_nocache
testOverloadedInitSupertype

# "Access to generic instance variables via class is ambiguous"
testGenericClassAttrUnboundOnClass
testGenericClassAttrUnboundOnSubClass

# super
testSuperExpressionsWhenInheritingFromGenericType
testSuperExpressionsWhenInheritingFromGenericTypeAndDeepHierarchy
testSuperOutsideClass
testSuperField
testSuperBasics
testRefreshGenericSubclass

# class types defined in super class
testInheritanceFromGenericWithImplicitDynamic

# Liskov
*Liskov*
testPositionalOverridingArgumentNameInsensitivity
testOverridingMethodInSimpleTypeInheritingGenericType
testOverridingMethodInGenericTypeInheritingSimpleType
testOverridingMethodInMultilevelHierarchyOfGenericTypes
testOverridingMethodInGenericTypeInheritingGenericType
testSubclassingGenericABC1
testSubclassingGenericABCWithDeepHierarchy
testSubclassingGenericABCWithDeepHierarchy2

# Signatures of "__ior__" and "__or__" are incompatible
testGenericOperatorMethodOverlapping
testGenericOperatorMethodOverlapping2

# class attributes
testInferAttributeTypeAndAssignInInit

# class issues
testAddBaseClassAttributeCausingErrorInSubclass
testConstructorSignatureChanged2
testConstructorSignatureChanged3
testFineGrainedCallable
testRefreshSubclassNestedInFunction2
testAliasFineNormalClassBases
testSkippedClass*

# Intersection types
testIsInstanceAdHocIntersectionFineGrainedIncremental*

# Function subtyping different names
testSubtypingFunctionsArgsKwargs

# Incompatible default for argument
testEllipsisDefaultArgValueInNonStubsOverload
testDefaultArgumentsWithSubtypes
testMultipleDefaultArgumentExpressions
testMultipleDefaultArgumentExpressions2
testDefaultArgumentsAndSignatureAsComment
testMethodDefaultArgumentsAndSignatureAsComment
# Incompatible default for argument "x"  (default has type "B", argument has type "A")
testDefaultArgumentExpressions2
testDefaultArgumentExpressionsGeneric


# data attributes Callable as a bound method
testMethodAsDataAttribute*
testMethodWithInvalidMethodAsDataAttribute
testMethodWithDynamicallyTypedMethodAsDataAttribute
testOverloadedMethodAsDataAttribute
testInvalidMethodAsDataAttributeInGenericClass
testPartiallyTypedSelfInMethodDataAttribute
testCallableDataAttribute

# Reporting of Callable issues formatting (for now just changed in tests)
# testSubtypingFunctionsDoubleCorrespondence
# testSubtypingFunctionsRequiredLeftArgNotPresent
# testRedefineFunction
# testSubtypingWithGenericFunctionUsingTypevarWithValues

# flow graph
testAssignAndConditional*
testRedefineImportedFunctionViaImport
testImportedVariableViaImport

# syntax errors
testPreferPackageOverFile
testPreferPackageOverFile2

# async/await
*Await*
*Async*
test__aiter__and__anext__

# Yield
*Yield*

# "Cannot determine type of"
testThreePassesRequired
testAccessGlobalVarBeforeItsTypeIsAvailable
testAccessDataAttributeBeforeItsTypeIsAvailable
testMultipassAndTopLevelVariable
testMultipassAndCircularDependency

# __new__
*DunderNew*

# *args input
testCallVarargsFunctionWithIterable
testCallVarargsFunctionWithTwoTupleStarArgs
testCallVarargsFunctionWithIterableAndPositional
testCallVarargsFunctionWithTupleAndPositional
testCallingWithListVarArgs
testCallingWithTupleVarArgs
testInvalidVarArg
testCallingVarArgsFunctionWithListVarArgs
testCallingVarArgsFunctionWithTupleVarArgs
testDynamicVarArg
testListVarArgsAndSubtyping
testCallerVarArgsAndDefaultArgs
testVarArgsAfterKeywordArgInCall*
testVarArgsEmptyList
testVarArgsEmptyTuple
testIntersectionTypesAndVarArgs
testCallerVarArgsListWithTypeInference
testCallerVarArgsTupleWithTypeInference
testCallerVarargsAndComplexTypeInference
testCallerTupleVarArgsAndGenericCalleeVarArg
testInvariantTypeConfusingNames2
testInvalidTypevarValues
testOverloadingVariableInputs
testOverloadWithTupleVarArg
testOverloadWithOverlappingItemsAndAnyArgument6
testOverloadWithOverlappingItemsAndAnyArgument7
testOverloadWithOverlappingItemsAndAnyArgument8
testOverloadVarargInputAndVarargDefinition
testOverloadMultipleVarargDefinition
testOverloadVarargsSelection
testOverloadVarargsSelectionWithTuples
testInvalidKindsOfArgsToCast

# **kwargs input
testKwargsAfterBareArgs
testCallingFunctionWithKeywordVarArgs
testPassingMappingForKeywordVarArg
testPassingMappingSubclassForKeywordVarArg
testInvalidTypeForKeywordVarArg
testPassingKeywordVarArgsToNonVarArgsFunction
testBothKindsOfVarArgs
testPassingMultipleKeywordVarArgs
testPassingKeywordVarArgsToVarArgsOnlyFunction
testCallsWithStars
testCallStar2WithStar
testStarArgsAndKwArgsSpecialCase
testPassingEmptyDictWithStars
testKeywordUnpackWithDifferentTypes
testOverloadWithOverlappingItemsAndAnyArgument11
testOverloadKwargsSelectionWithDict
testOverloadVarargsAndKwargsSelection
testStar2Context

# {**kwargs}
testSubtypingMappingUnpacking1
testSubtypingMappingUnpacking2
testSubtypingMappingUnpacking3
testNotDirectIterableAndMappingSubtyping
testUnpackInExpression3-only_when_nocache

# "???" does not return a value / Function does not return a value
testCallingVarArgsFunction
testFunctionTypeCompatibilityWithOtherTypes
testLvarInitializedToVoid
testForStatementInferenceWithVoid

# Implicit Param Option X = None -> Optional[X] inference
testCallingVarArgsFunctionWithDefaultArgs
testOneOfSeveralOptionalKeywordArguments
testKeywordArgAfterVarArgs
testKeywordArgAfterVarArgsWithBothCallerAndCalleeVarArgs
testCallingFunctionsWithDefaultArgumentValues
testPartiallyInitializedVariableDoesNotEscapeScope2

# None late binding, because it's None (x = None; x = 3)
testAssigningAnyStrToNone
testLocalVariablePartiallyInitializedToNone
testLocalVariablePartiallyTwiceInitializedToNone
testGvarPartiallyInitializedToNone
testPartiallyInitializedToNone*
testAttributePartiallyInitializedToNoneWithMissingAnnotation
testGlobalInitializedToNoneSetFromFunction
testGlobalInitializedToNoneSetFromMethod
testNoCrashOnPartialVariable
testNoCrashOnPartialVariable3

# Cannot call function of unknown type
testUnknownFunctionNotCallable

# Implicit any param
testKwargsArgumentInFunctionBodyWithImplicitAny

# Decorators
*Deco*
testVarArgsCallableSelf
testOverloadDeferredNode
testGenericClassPropertyBound

# Function Not checked, missing return annotations (untyped)
testPositionalAndKeywordForSameArg
testTypeCheckOverloadWithImplementationError

# function type mismatch when untyped
testSubtypingFunctionsImplicitNames

# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred

# Protocol
testProtocolUpdateType*
testProtocolAddAttrInFunction
testProtocolRemoveAttrInClass
testProtocolConcrete*
testProtocolUpdateBaseGeneric
testProtocolChangeGeneric
testNonProtocolToProtocol
testInvalidateProtocolViaSuperClass
testProtocolInvalidateConcreteViaSuperClass*
testTwoProtocolsTwoFilesCrossedUpdateType-only_when_nocache
testTwoProtocolsTwoFilesCrossedDeleteAttr-only_when_cache
testProtocolsInvalidateByRemovingBase
testProtocolVsProtocol*
testProtocolMultipleUpdates
testWeAreCarefulWithBuiltinProtocols
testWeAreCarefullWithBuiltinProtocolsBase
# Duck typing
testOverloadingAndDucktypeCompatibility

# parser recovery in type comments / types in string literals
testInvalidStrLiteralSpaces
testInvalidStrLiteralStrayBrace
testInvalidMultilineLiteralType

# Global
testAssignToFuncDefViaGlobalDecl2

# Nonlocal
*NonlocalDecl*
testNonlocalAndGlobalDecl
testNewAnalyzerRedefinedNonlocal

# __init__ None needed
testInitReturnTypeError

# Need type annotation for "X"
testNewAnalyzerLessErrorsNeedAnnotation*
testErrorInTypeCheckSecondPassThroughPropagation
testGenericFunctionOnReturnTypeOnly
testUnderspecifiedInferenceResult
testNoCrashOnPartialMember
testDontMarkUnreachableAfterInferenceUninhabited*
testNeedAnnotationForCallable
testPartialDefaultDict*
testInferenceOfFor*
testInferLocalVariableTypeWithUnderspecifiedGenericType
testLocalVariableInferenceFromEmptyList

# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames

# Invariant note
testAssignmentInvariantNoteForList
testAssignmentInvariantNoteForDict
testInvariantListArgNote
testInvariantDictArgNote
testCallGenericFunctionWithTypeVarValueRestrictionUsingContext
testInferredTypeSubTypeOfReturnType
testListWithDucktypeCompatibility
testListWithDucktypeCompatibilityAndTransitivity
testWideOuterContextEmptyError
testWideOuterContextNoArgsError

# List unpacking
testMultipleAssignmentWithLists
testMultipleAssignmentWithListsInInitialization
testMultipleAssignmentWithListAndIndexing
testMultipleAssignmentAndGenericSubtyping
testInferringLvarTypesInNestedListAssignment
testInferringMultipleLvarDefinitionWithListRvalue
testInferMultipleLocalVariableTypesWithArrayRvalueAndNesting
testUnpackInExpression1-only_when_nocache

# List different types weirdness
testListLiteralWithFunctionsErasesNames
testListLiteralWithSimilarFunctionsErasesName
testListLiteralWithNameOnlyArgsDoesNotEraseNames
testGenericJoin*

# List/Set/Dict Inferring type of variable when initialized to an empty collection
testInferListInitialized*
testInferSetInitialized*
testInferDictInitialized*
testSpecialCaseEmptyListInitialization*
testInferListInitializedToEmptyAndAssigned
testInferOrderedDictInitializedToEmpty
testEmptyCollectionAssignedToVariableTwiceIncremental
testEmptyCollectionAssignedToVariableTwiceNoReadIncremental
testInferAttributeInitializedToEmpty*
testInferAttributeInitializedToNone*
testInferFromEmptyDictWhen*
testInferListTypeFromInplaceAdd
testInferSetTypeFromInplaceOr
testConditionalExpressionWithEmptyListAndUnionWithAny
testConditionalExpressionWithEmptyIteableAndUnionWithAny

# Too many values to unpack (2 expected, 3 provided)
testInferringLvarTypesInMultiDefWithInvalidTuple

# Type execution
testNoneAlias
testNoneAliasStrict

# Special case for assignment to '_'
testUnusedTargetLocal
testUnusedTargetNotClass
testUnusedTargetNotClass2
testUnusedTargetTupleUnpacking
testUnusedTargetMultipleTargets
testUnusedTargetNotImport
testUnderscoreClass
testUnusedTargetForLoop
testUnusedTargetWithClause
testUnusedTargetNotExceptClause

# Wtfs
testEmptyTupleTypeAlias
testOverrideByIdemAliasCorrectType
testOverrideByIdemAliasCorrectTypeReversed
testConditionalExceptionAlias

# weird files
testScriptsAreNotModules

# Formatting qualified name
testSubmoduleMixingImportFromAndImport
testSubmoduleMixingImportFromAndImport2
testErrorFromGoogleCloud
testStubPackageSubModule
testReExportChildStubs3
testImportFromReExportInCycleUsingRelativeImport1
testImportReExportInCycleUsingRelativeImport2

# Formatting class in reveal_type (stashed in 860494e, see also https://github.com/python/mypy/issues/13062)
testNewAnalyzerShadowOuterDefinitionBasedOnOrderTwoPasses
testNewAnalyzerPlaceholderFromOuterScope
testAliasInImportCycle3
testNewAnalyzerTypeVarForwardReferenceErrors

# Aliases in Mypy define generics as X = Foo as Foo[Any, Any]
testAliasToTupleAndCallable
testNewAnalyzerAliasesFixedFew
testNewAnalyzerAliasesFixedMany

# Formatting Module as types ("ModuleType" instead of Module)
testInvalidOperationsOnModules
testConditionalImportAndAssignInvalidToModule
testModuleAliasRepeatedWithAnnotation

# Tuple iter
testNewAnalyzerFallbackUpperBoundCheckAndFallbacks

# tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5

# Syntax error in type annotation
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2
# Suggestion: Use tuple[()] instead of () for an empty tuple, or None for a function without a return value
testReturnEmptyTuple

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same # error twice
testOperatorAssignmentWithIndexLvalue1

# Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4

# Weird ellipsis assignment
testEllipsisInitializerInStubFileWithType
testEllipsisDefaultArgValueInStub2
testEllipsisDefaultArgValueInNonStub
testEllipsisDefaultArgValueInNonStubsMethods

# The type "Type[type]" is not generic and not indexable
testTypeApplicationCrash

# "bool" is not a valid base class
testTestExtendPrimitives

# strict optional
*StrictOptional*
testAssignToFuncDefViaImport
testUnionWithNoneItem
testBoundHigherOrderWithVoid
testRegression11705_Strict
testGenericMethodCalledInGenericContext
# non strict call on Optional[T]
testCastConfusion

# type: ignore leads to Any type?
testDunderCallAddition

# Very weird annotation resolution order
testNewAnalyzerAnnotationConflictsWithAttributeSinglePass
testNewAnalyzerAnnotationConflictsWithAttributeTwoPasses
testNewAnalyzerNameConflictsAndMultiLineDefinition

# pyproject.toml
testMultipleModulesInOverridePyProjectTOML
testIgnoreErrorFromMissingStubs1
testIgnoreErrorFromMissingStubs2

# mypy.ini
testRefreshIgnoreErrors1
testRefreshIgnoreErrors2
testRefreshOptions

# --allow-untyped-globals
testPermissiveAttributeOverride1

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testUnlimitedStubErrorVolume

# --disallow-any-generics
testErrorReportingNewAnalyzer

# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --pretty
testReprocessMethodShowSource

# syntax not yet supported
testBreakOutsideLoop
testContinueOutsideLoop
testInvalidGlobalDecl
testAssignToTypeDef

# parser shit
testInvalidLvalues*
testTwoStarExpressions*
testStarExpressionRhs
testStarExpressionInExp
testInvalidDel*
testInvalidTypeDeclaration
testIndexedAssignmentWithTypeDeclaration
testInvalidLvalueWithExplicitType
testInvalidLvalueWithExplicitType3
testInvalidWithTarget
testInvalidTypeAnnotation2

# param with leading __
testLackOfNames
testLackOfNamesFastparse
testPositionalOnlyArg
testMagicMethodPositionalOnlyArg
testMagicMethodPositionalOnlyArgFastparse
testAnonymousArgumentError
testGenericFunctionTypeDecl

# for type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2

# Won't support for now: "t" is a type variable and only valid in type context
testExpressionRefersToTypeVariable

# Probably won't support Type Var formatting
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName

# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments
testNestedFunctionInMethodWithTooFewArgumentsInTypeComment
testDeepNestedFunctionWithTooFewArgumentsInTypeComment
testDeepNestedMethodInTypeComment
testEllipsisWithArbitraryArgsOnBareFunctionWithKwargs
testEllipsisWithArbitraryArgsOnBareFunctionWithVarargs
testEllipsisWithSomethingAfterItFails
testEllipsisWithSomethingBeforeItFails

# --scripts-are-modules
testScriptsAreModules

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testInlineConfigFineGrained*

# Won't support: reveal_locals
testRevealLocalsFunction

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support ever: python 2
*python2
testMypyPathAndPython2Dir

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testNoSubscriptionOfBuiltinAliases

# Skips
testTrailingCommaParsing-skip
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testFunctionInGenericInnerClassTypeVariable-skip
testOverloadInferringArgumentsUsingContext2-skip
testUnionTwoPassInference-skip
