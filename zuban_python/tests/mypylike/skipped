testOverloadAgainstEmptyCollections
testOverloadAgainstEmptyCovariantCollections


# Overloading
testOverloadBadArgumentsInferredToAny1
testOverloadBadArgumentsInferredToAny2
testOverloadedCallWithVariableTypes
testOverloadOverlapWithTypeVarsWithValues
testOverloadMultipleVarargDefinitionComplex

testOverloadsUsingAny
testOverloadWithOverlappingItemsAndAnyArgument2
testOverloadWithOverlappingItemsAndAnyArgument3
testOverloadWithOverlappingItemsAndAnyArgument4
testOverloadWithOverlappingItemsAndAnyArgument9
testOverloadWithOverlappingItemsAndAnyArgument12
testOverloadWithOverlappingItemsAndAnyArgument13
testOverloadWithOverlappingItemsAndAnyArgument14
testOverloadWithOverlappingItemsAndAnyArgument15
testOverloadWithOverlappingItemsAndAnyArgument16

testOverloadWithDerivedFromAny
# - No overload variant of "f" matches argument types "A", "A"
#     -> f(*(1,))() # E: No overload variant of "f" matches argument type "Tuple[int]"
# - No overload variant of "__add__" of "A" matches argument type "str"
# - wtf List item 0 has incompatible type "List[str]"; expected "int"
testPreferExactSignatureMatchInOverload
testBadOverloadProbableMatch
# - wtf Value of type variable "AnyStr" of "g" cannot be "Sequence[object]
testOverloadsGenericTypevarUpdated
# - wtf Argument 2 to "f" has incompatible type "Tuple[int, str]"; expected "Tuple[str, ...]"
# - wtf Argument 1 to "single_plausible" has incompatible type "Type[Other]"; expected "Type[int]"
# - wtf Argument 1 to "f1" has incompatible type "Union[A, B]"; expected "A"
#       Argument 1 to "foo" has incompatible type "Union[WrapperCo[A], WrapperContra[C]]"; expected "WrapperCo[B]"
testOverloadInferUnionReturnBasic
testOverloadInferUnionReturnMultipleArguments
testOverloadInferUnionRespectsVariance
testUnionMathTrickyOverload1
testUnionMathTrickyOverload2
testManyUnionsInOverload
# - 3352-3500 Union/Type vars/overloads weird combinations
testOverloadInferUnionIfParameterNamesAreDifferent
testOverloadInferUnionReturnFunctionsWithKwargs
testOverloadInferUnionWithDifferingLengths
testOverloadInferUnionWithMixOfPositionalAndOptionalArgs
testOverloadingInferUnionReturn*
testOverloadInferUnionReturnWithInconsistentTypevarNames
# - Condition cannot be inferred, unable to merge overloads
testOverloadIf*
# - Not all union combinations were tried because there are too many unions
testTooManyUnionsException
# - An overloaded function outside a stub file must have an implementation
# - Signature of "f" incompatible with supertype "Parent"
#     Overload variants must be defined in the same order as they are in "Parent"
testOverrideOverloadSwapped
testOverrideOverloadSwappedWithExtraVariants
testOverrideOverloadSwappedWithAdjustedVariants
testOverrideOverloadedMethodWithMoreSpecificArgumentTypes
testOverloadWithIncompatibleMethodOverrideAndImplementation
testOverloadFaultyClassMethodInheritance
testOverloadClassMethodMixingInheritance
testOverloadFaultyStaticMethodInheritance
testOverloadStaticMethodMixingInheritance
testOverloadStaticMethodImplementation
testUnsafeDunderOverlapInSubclass
# - Single overload definition, multiple required
# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2
# - Overloaded function signatures 2 and 3 overlap with incompatible return types
testTypeCheckOverloadWithUntypedImplAndMultipleVariants
testTypeCheckOverloadImplementationTypeVarDifferingUsage2
testOverlappingOverloadSignatures
testPartiallyCovariantOverlappingOverloadSignatures
testOverlappingOverloadCounting
testOverloadWithOverlappingItemsAndAnyArgument5
testOverloadWithOverlappingItemsAndAnyArgument10
testOverloadTupleEllipsisVariance
testOverloadWithMethodOverrideAndImplementation
testOverloadAnyIsConsideredValidReturnSubtype
testOverloadWithVariableArgsAreOverlapping
testOverloadDetectsPossibleMatchesWithGenerics
testOverloadPossibleOverlapWithArgsAndKwargs
testOverloadPossibleOverlapWithVarargs2
testOverloadPossibleOverlapWithVarargs4
testOverloadPossibleOverlapMixingOptionalArgsWithVarargs
testOverloadPossibleOverlapMixingOptionalArgsWithVarargs2
testOverloadPossibleOverlapMixingNamedArgsWithKwargs2
testOverloadPossibleOverlapMixingNamedArgsWithKwargs3
testOverloadWithPartiallyOverlappingUnions
testOverloadWithPartiallyOverlappingUnionsNested
testOverloadPartialOverlapWithUnrestrictedTypeVar
testOverloadPartialOverlapWithUnrestrictedTypeVarNested
testOverloadPartialOverlapWithUnrestrictedTypeVarInClass
testOverloadPartialOverlapWithUnrestrictedTypeVarInClassNested
testOverloadedPartiallyOverlappingInheritedTypes1
testOverloadedPartiallyOverlappingInheritedTypes2
testOverloadedPartiallyOverlappingInheritedTypes3
testOverloadedPartiallyOverlappingTypeVarsAndUnion
testOverloadPartiallyOverlappingTypeVarsIdentical
testOverloadedPartiallyOverlappingCallables
testNestedOverloadsTypeVarOverlap
testOverloadsIgnorePromotions
testOverloadsTypesAndUnions
testOverloadTwoTypeArgs
testOverloadTupleInstance
testOverloadTupleEllipsisNumargs
# - Overloaded function implementation does not accept all possible arguments of signature 2
testTypeCheckOverloadWithImplTooSpecificArg
# - Overloaded function implementation cannot produce return type of signature 2
testTypeCheckOverloadWithImplTooSpecificRetType
testPreviousErrorInOverloadedFunction
testOverloadsUpdatedTypeRechekConsistency
testOverloadClassMethodImplementation
testOverloadItemHasMoreGeneralReturnType
# - Overloaded function implementation cannot satisfy signature 2 due to inconsistencies in how they use type variables
testTypeCheckOverloadWithImplTypeVarProblems
# - Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
testOverloadRefresh
testContravariantOverlappingOverloadSignatures
testPartiallyContravariantOverloadSignatures
testContravariantOverlappingOverloadSignaturesWithAnyType
testOverloadOverlapWithTypeVars
testOverloadOverlapWithTypeVarsWithValuesOrdering
testOverloadWithNonPositionalArgsIgnoresOrder
testOverloadFlagsPossibleMatches
testOverloadPossibleOverlapWithVarargs
testOverloadPossibleOverlapWithKwargs
testOverloadPossibleOverlapMixingNamedArgsWithKwargs
# - Overload does not consistently use the "@classmethod" decorator on all function signatures
# - Overload does not consistently use the "@staticmethod" decorator on all function signatures
testOverloadWithInconsistentStaticMethods

# OverloadFunction class
testTypevarValuesWithOverloadedFunctionSpecialCase
testIntersectionTypeCompatibility
testVeryBrokenOverload
testVeryBrokenOverload2
# overload self type
testOverloadAndSelfTypes
# overload operator
testOverloadedLtAndGtMethods
testOverloadedForwardMethodAndCallingReverseMethod
testTypeInferenceSpecialCaseWithOverloading
# overload rename in import
testOverloadByAnyOtherName
# overload none matching in non strict
testOptionalIsNotAUnionIfNoStrictOverload
testOptionalIsNotAUnionIfNoStrictOverloadStr

# Overload -> None formatting
testCallToOverloadedFunction
testCallToOverloadedMethod
testOverloadsRemovedOverload
testOverloadsGenericToNonGeneric
testCallableSpecificOverload
testOverloadErrorMessageManyMatches
# overloading for loop
testOverloadedInIter

# Overloading generated messages that were not necessary
testSubtypingIterableUnpacking1
testSubtypingIterableUnpacking2

# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload

# Not matching type vars
testJoinUnionWithUnionAndAny

# Type mismatches for x[Any] | int and x[int] | int
testAssignUnionWithTenaryExprWithEmptyCollection

# Duplicate in Union
testUnionMethodCalls

# Duplicate base class
testIncludingBaseClassTwice

# Cycles
testCyclicUndefinedImportWithName
testCyclicUndefinedImportWithStar1
testCyclicUndefinedImportWithStar2
testNewAnalyzerTypeAnnotationCycle4
testNewAnalyzerAliasToNotReadyMixed
testNewAnalyzerVarTypeVarNoCrashImportCycle
testNewAnalyzerFuncTypeVarNoCrashImportCycle
testRecursiveForwardReferenceInUnion
# Class generics cycles / + type alias cycles
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerAliasToNotReadyDirectBaseFunction
testNewAnalyzerForwardTypeAliasInBase
testRecursiveAliasesErrors*
testJSONAliasApproximation
testChangeBaseClassAttributeType
testGenericTypeBody1

# Module Values
testModuleImplicitAttributes

# generics special cases
testGenericFunctionsWithUnalignedIds
testTypeVariableWithContainerAndTuple
testGenericOperatorMethodOverlapping*
testCallTypeTWithGenericBound
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName
testGenericClassClsNonGeneric
testGenericClassUnrelatedVars
testGenericClassInGenericFunction*
testGenericClassDirectCall
testGenericClassAlternativeConstructorPrecise*
testNoGenericAccessOnImplicitAttributes
testGenericClassAttrUnboundOn*
testGenericClassPropertyBound
testGenericClassInsideOtherGenericClass
testGenericFunctionMemberExpand
testGenericJoin*

# Type Var Value in func
testCheckGenericFunctionBodyWithTypeVarValues
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testTypeVarValuesAndNestedCalls
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testTypevarValuesSpecialCase1
testGenericTypeAliasesTypeVarConstraints

testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2

# Bound with Union: Item "{}" of the upper bound "{}" of type variable "{}" has no attribute "{}"
testTypeVarBoundToOldUnionAttributeAccess
testTypeVarBoundToNewUnionAttributeAccess

# Nested type vars
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues

# Type Var overrides
testTypeInferenceWithCalleeVarArgs
testTypeInferenceWithCalleeVarArgsAndDefaultArgs

# Type variable "C.T" cannot be used as an expression
testClassMemberTypeVarInFunctionBody

# Type[T] TypeVars -> Indirect class access
testTypeVarWithAnyTypeBound

# Type Var Inference bottom up
testBoundOnGenericClass
testGenericTypeWithTypevarValuesAndSubtypePromotion
# Inference bottom up?
testGenericArgumentInOverload
testGenericFunctionAsOverloadItem
testGenericTypeAliasesBasic2

# Type var self and access
testInheritanceFromGenericWithImplicitDynamic
testInheritanceFromGenericWithImplicitDynamicAndExternalAccess

# Type var formatting as nothing
testInheritedConstructor
testImportedTypeAliasInRuntimeContext

# Special Type Var Binding
testGenericTypeAliasesRuntimeExpressionsInstance
testGenericTypeAliasesTypeVarBinding

# Type var: Cannot infer type argument
testGenericTypeAliasesPEPBasedExample
testGenericTypeAliasesImporting

# Cannot declare the type of a TypeVar or similar construct
testTypevarWithType

# Literal
testNewAnalyzerBool
testNoneHasBool
testNoneHasBoolShowNoneErrorsFalse
testLiteral*

# int -> float promotion
testNewAnalyzerPromotion
testProhibitUsingVariablesAsTypesAndAllowAliasesAsTypes
testSimplifyingUnionAndTypePromotions
testFlattenTypeAliasWhenAliasedAsUnion
testOverloadingAndIntFloatSubtyping

# Class in Class
testNewAnalyzerNestedClass*
testNewAnalyzerAliasToNotReadyNestedClass*
testNestedClassOnAliasAsType
testInvalidTypeWithinNestedGenericClass

# Class in function
testNewAnalyzerClassInFunction
testNewAnalyzerNestedClassInMethod
testNewAnalyzerDeeplyNestedFunctions
testNewAnalyzerUnsupportedBaseClassInsideFunction
testInfiniteLoop

# Class: generic access from outside
testAliasRefOnClass
# Class alias with class type var prohibited
testProhibitBoundTypeVariableReuseForAliases
# General Scoping
testGenericInnerClass
testGenericClassInnerFunctionTypeVariable
testListComprehensionSpecialScoping

# Property
testNonMethodProperty
testInvalidArgCountForProperty
testNewAnalyzerProperty
testNewAnalyzerNoCrashOnCustomProperty
testOverloadNotConfusedForProperty
# Decorated property not supported
testOverloadedProperty
testOverloadedProperty2

# descriptors
testOverloadWithNonGenericDescriptor
testOverloadWithNonGenericDescriptorLookalike
testOverloadWithGenericDescriptor
testOverloadWithGenericDescriptorLookalike

# classmethod
testAliasToClassMethod
testGenericClassMethod*
testClassmethodAndNonMethod
testAddBaseClassMethodCausingInvalidOverride
testModifyBaseClassMethodCausingInvalidOverride
testClassImportAccessedInMethod
testSelfTypeVarIndexExpr
testNewAnalyzerTypeVarBoundInCycle
testOverloadClassmethodDisappears
testOverloadWithClassMethods
testOverloadWithInconsistentClassMethods
testOverloadAndClassTypes

# staticmethod
testStaticmethodAndNonMethod
testBoundStaticMethod

# NamedTuple
*NamedTuple*
testNewAnalyzerTupleIteration
testDistinctTypes
testInfiniteLoop2
testNewAnalyzerTypeArgBoundCheckDifferentNodes


# Typing stuff
testInvalidAssertType
testInvalidAnyCall
testInvalidTypeInTypeApplication
testParamSpec
testOverloadingWithParamSpec
testBaseClassAnnotatedWithoutArgs
*Pep613
*Abstract*
*Final*

# TYPE_CHECKING
testIfTypeCheckingUnreachableClass

# stdlib
testDataclass*
testAttrs*
*PartialType*
*NewType*
*Enum*
*TypedDict*

# Cast
testInvalidCast*
testInvalidNumberOfArgsToCast
testInvalidKindsOfArgsToCast
testNewAnalyzerCastForward*
testCastConfusion
# NoReturn
testNoReturnTypeAlias
testUnionWithNoReturn
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2

# Type application vs. type declaration
testNewAnalyzerAliasToNotReadyClassDoubleGeneric

# Incomplete Unions: `int | int`
testNewAnalyzerForwardAliasFromUnion
# Union simplification
testUnionSimplification*
testSimplifyingUnionWithTypeTypes2
testNewAnalyzerBuiltinAliasesFixed
testSimplifyUnionWithCallable

# Union attribute error: Item "D" of "C | D" has no attribute "y"
testUnionAttributeAccess

# Union iter()
testUnionMultiassignSingle
testUnionMultiassignDouble
testUnionMultiassignGeneric
testUnionMultiassignAny
testUnionMultiassignNotJoin
testUnionMultiassignRebind
testUnionMultiassignAlreadyDeclared
testUnionMultiassignIndexed
testUnionMultiassignIndexedWithError
testUnionMultiassignPacked
testUnpackingUnionOfListsInFunction
testUnionOfVariableLengthTupleUnpacking
testUnionOfNonIterableUnpacking
testUnionAlwaysTooMany
testUnionAlwaysTooFew
testUnionUnpacking*
testNestedUnionUnpackingFromNestedTuples
testNestedUnionUnpackingFromNestedTuplesBinder
testUnpackUnionNoCrashOnPartialNone*

# Unpacking a string is disallowed
testStringDisallowedUnpacking

# BoundMethod class
testKwargsAllowedInDunderCall
testKwargsAllowedInDunderCallKwOnly

# Dynamic functions are not type checked?!
testNoInvalidTypeInDynamicFunctions
testCallGenericFunctionWithTypeVarValueRestrictionInDynamicFunc

# Comprehensions
testNewAnalyzerListComprehension
testNewAnalyzerDictionaryComprehension

# if sys.version
testNewAnalyzerVersionCheck*

# lambda
testNewAnalyzerVarTypeVarNoCrash
testOverloadLambdaUnpackingInference
testOverloadedToGeneric

# Conditional definitions
testNewAnalyzerConditionalFunc*
testNewAnalyzerConditionallyDefineFuncOverVar

# isinstance flow analysis
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues*
testTypeCheckOverloadImplementationTypeVarWithValueRestriction
testTypeCheckOverloadImplementationTypeVarDifferingUsage1
# isinstance & union
testUnion1
testUnion2
testUnion3
testUnionAnyIsInstance
testNestedUnionsProcessedCorrectly
testGenericTypeAliasesUnion

# check after flow analysis
testAssignAnyToUnionWithAny

# All conditional function variants must have identical signatures (flow analysis)
testUnionOrderEquivalence

# Visibility of imports in pyi
testNewSemanticAnalyzerModulePrivateRefInMiddleOfQualified

# typing extensions
testInvalidUnpackTypes
testTypeVarTuple
testRuntimeProtoTwoBases

# mypy extensions
testFlexibleAlias*

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext

# stdlib imports
testOverloadSpecialCase
testSubclassingGenericABCWithImplicitAny
testSubclassingGenericABCWithImplicitAnyAndDeepHierarchy
testImplementingGenericABCWithImplicitAnyAndDeepHierarchy2
testInvariance
testSubtypingAndABCExtension
testAccessingGenericABCMembers
testAccessingInheritedGenericABCMembers

# Module __all__
testNewAnalyzerExportedValuesInImportAll
testExportedValuesInImportAll
testAllMustBeSequenceStr*
testUnderscoreExportedValuesInImportAll
testReExportAllInStub

# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions

# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testKeywordMisspelling
testMultipleKeywordsForMisspelling
testKeywordMisspelling*

# Import submodules
testNewAnalyzerImportStarSpecialCase

# Submodule was not imported
testSubmoduleImportFromDoesNotAddParents
testSubmoduleMixingImportFromAndImport

# import a.b.c issues
testMissingSubmoduleImportedWithIgnoreMissingImports*
testMissingSubmoduleOfInstalledStubPackage
testGenericAliasCollectionsABCReveal

# Complex Star import
testImportWithinMethod

# Module __getattr__
testNewAnalyzerModuleGetattrSerialize_incremental
testModuleLevelGetattr*
testModuleGetattr*
testModuleGetAttr*

# Module type does not contain module info
testMultiModuleAlias
testModuleAliasWithExplicitAnnotation

# namespace packages
testClassicNotPackage
testNamespacePackage*
testClassicPackageIgnoresEarlierNamespacePackage
testClassicPackageInsideNamespacePackage

# Stub Reexport
testNoReExportFromStubs*
testNoReExportChildStubs
testReExportChildStubs
testNoReExportNestedStub
testNoReExportFromMissingStubs
testMissingGenericImport
testStubFixupIssues

# Import itself / Extremely weird import orders
testNewAnalyzerImportCycleWithIgnoreMissingImports
testNewAnalyzerImportFromTopLevelFunction
testNewAnalyzerImportFromTopLevelAlias
testNewAnalyzerImportAmbiguousWithTopLevelFunction
testReExportChildStubs
testReExportChildStubs2
testImportCycleSpecialCase
testPackagePath

# Multi definition ifs
testNewAnalyzerFirstAliasTargetWins
testNewAnalyzerFirstVarDefinitionWins

# Multiple arguments missing
testMissingPositionalArguments

# Redefinition (Name "X" already defined on line X)
testGlobalVarRedefinition
testLocalVarRedefinition
testClassVarRedefinition
testMultipleClassDefinitions
testMultipleMixedDefinitions
testMultipleMethodDefinition
testMultipleNestedFunctionDef
testRedefineVariableAsTypevar
testRedefineTypevar*
testImportTwoModulesWithSameNameInFunction
testImportTwoModulesWithSameNameInGlobalContext
testTypeRedeclarationNoSpuriousWarnings
testDuplicateDef*
testTypeVarClassDup
testAliasDup
testImportFuncDup
testIgnoredImportDup
testNewAnalyzerRedefinitionAndDeferral*
testNewAnalyzerImportStarForwardRef*
testNewAnalyzerImportOverExistingInCycle*
testNewAnalyzerConditionalFunc
testNewAnalyzerConditionallyDefineFuncOverClass
testNewAnalyzerMissingImportErrors*
testNewAnalyzerDuplicateTypeVar*
testNewAnalyzerRedefineAsClass
testNewAnalyzerOverrideClassWithTypeAlias
testNewAnalyzerIdentityAssignment*
testProhibitReassigning*
testUnknownModuleRedefinition
testStarImportOverlappingMismatch
testStarImportOverridingLocalImports
testRedefineFunctionViaImport
testDifferentImportSameNameTwice
testNewAnalyzerRedefineAsOverload
testImportOnTopOfAlias1
testImportOnTopOfAlias2
# redefinition overload
testRedefinedOverloadedFunction
testFakeOverloadCrash
testFakeOverloadCrash2
testOverloadNotImportedNoCrash
testSingleOverload2
# Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation
testAliasesInClassBodyNormalVsSubscripted
# Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2

# BoundMethod type
testForwardReferenceToListAlias

# Metaclass
*Metaclass*
testNewAnalyzerClassKeywordsError
testNewAnalyzerNotAnAlias
testNewAnalyzerClassPropertiesInAllScopes
testIgnoredAttrReprocessedMeta
testImplementingOverloadedMethod

# Signature of "???" incompatible with supertype "???"
testKeywordOnlyArgumentOrderInsensitivity
testPositionalOverridingArgumentNamesCheckedWhenMismatchingPos
testOverrideGenericMethodInNonGenericClassLists
testOverrideGenericMethodInNonGenericClassGeneralize
testOverloadedMethodSupertype-only_when_cache
testOverloadedMethodSupertype2-only_when_nocache
testOverloadedInitSupertype

# super
testSuperExpressionsWhenInheritingFromGenericType
testSuperExpressionsWhenInheritingFromGenericTypeAndDeepHierarchy
testSuperOutsideClass
testSuperField
testSuperBasics
testRefreshGenericSubclass

# Liskov
*Liskov*
testPositionalOverridingArgumentNameInsensitivity
testOverridingMethodInSimpleTypeInheritingGenericType
testOverridingMethodInGenericTypeInheritingSimpleType
testOverridingMethodInMultilevelHierarchyOfGenericTypes
testOverridingMethodInGenericTypeInheritingGenericType
testSubclassingGenericABC1
testSubclassingGenericABCWithDeepHierarchy
testSubclassingGenericABCWithDeepHierarchy2

# class issues
testAddBaseClassAttributeCausingErrorInSubclass
testConstructorSignatureChanged2
testConstructorSignatureChanged3
testFineGrainedCallable
testRefreshSubclassNestedInFunction2
testAliasFineNormalClassBases
testSkippedClass*

# Intersection types
testIsInstanceAdHocIntersectionFineGrainedIncremental*

# Function Subtyping
testSubtypingFunction*
testLackOfNames
testLackOfNamesFastparse
testFunctionTypeCompatibilityWithOtherTypes
testVarArgsFunctionSubtyping

testGenericFunctionSubtypingWithTypevarValues
testSubtypingWithGenericFunctions
testSubtypingWithGenericInnerFunctions
testSubtypingWithGenericFunctionUsingTypevarWithValues

# Incompatible default for argument
testEllipsisDefaultArgValueInNonStubsOverload

# flow graph
testAssignAndConditional*
testRedefineImportedFunctionViaImport
testImportedVariableViaImport

# syntax errors
testPreferPackageOverFile
testPreferPackageOverFile2

# async/await
*Await*
*Async*
test__aiter__and__anext__

# Yield
*Yield*

# "Cannot determine type of"
testThreePassesRequired

# __new__
*DunderNew*

# *args input
testCallVarargsFunctionWithIterable
testCallVarargsFunctionWithTwoTupleStarArgs
testCallVarargsFunctionWithIterableAndPositional
testCallVarargsFunctionWithTupleAndPositional
testCallingWithListVarArgs
testCallingWithTupleVarArgs
testInvalidVarArg
testCallingVarArgsFunctionWithListVarArgs
testCallingVarArgsFunctionWithTupleVarArgs
testDynamicVarArg
testListVarArgsAndSubtyping
testCallerVarArgsAndDefaultArgs
testVarArgsAfterKeywordArgInCall*
testVarArgsEmptyList
testVarArgsEmptyTuple
testIntersectionTypesAndVarArgs
testCallerVarArgsListWithTypeInference
testCallerVarArgsTupleWithTypeInference
testCallerVarargsAndComplexTypeInference
testCallerTupleVarArgsAndGenericCalleeVarArg
testInvariantTypeConfusingNames2
testInvalidTypevarValues
testOverloadingVariableInputs
testOverloadWithTupleVarArg
testOverloadWithOverlappingItemsAndAnyArgument6
testOverloadWithOverlappingItemsAndAnyArgument7
testOverloadWithOverlappingItemsAndAnyArgument8
testOverloadVarargInputAndVarargDefinition
testOverloadMultipleVarargDefinition
testOverloadVarargsSelection
testOverloadVarargsSelectionWithTuples

# **kwargs input
testKwargsAfterBareArgs
testCallingFunctionWithKeywordVarArgs
testPassingMappingForKeywordVarArg
testPassingMappingSubclassForKeywordVarArg
testInvalidTypeForKeywordVarArg
testPassingKeywordVarArgsToNonVarArgsFunction
testBothKindsOfVarArgs
testPassingMultipleKeywordVarArgs
testPassingKeywordVarArgsToVarArgsOnlyFunction
testCallsWithStars
testCallStar2WithStar
testStarArgsAndKwArgsSpecialCase
testPassingEmptyDictWithStars
testKeywordUnpackWithDifferentTypes
testOverloadWithOverlappingItemsAndAnyArgument11
testOverloadKwargsSelectionWithDict
testOverloadVarargsAndKwargsSelection

# {**kwargs}
testSubtypingMappingUnpacking1
testSubtypingMappingUnpacking2
testSubtypingMappingUnpacking3
testNotDirectIterableAndMappingSubtyping
testUnpackInExpression3-only_when_nocache

# "???" does not return a value
testCallingVarArgsFunction

# Implicit Param Option X = None -> Optional[X] inference
testCallingVarArgsFunctionWithDefaultArgs
testOneOfSeveralOptionalKeywordArguments
testKeywordArgAfterVarArgs
testKeywordArgAfterVarArgsWithBothCallerAndCalleeVarArgs

# Option[X] <-> Union[X, None] mixups
testOptional

# Implicit any param
testKwargsArgumentInFunctionBodyWithImplicitAny

# Decorators
*Deco*
testVarArgsCallableSelf
testOverloadDeferredNode

# Function Not checked, missing return annotations (untyped)
testPositionalAndKeywordForSameArg
testTypeCheckOverloadWithImplementationError

# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred

# Protocol
testProtocolUpdateType*
testProtocolAddAttrInFunction
testProtocolRemoveAttrInClass
testProtocolConcrete*
testProtocolUpdateBaseGeneric
testProtocolChangeGeneric
testNonProtocolToProtocol
testInvalidateProtocolViaSuperClass
testProtocolInvalidateConcreteViaSuperClass*
testTwoProtocolsTwoFilesCrossedUpdateType-only_when_nocache
testTwoProtocolsTwoFilesCrossedDeleteAttr-only_when_cache
testProtocolsInvalidateByRemovingBase
testProtocolVsProtocol*
testProtocolMultipleUpdates
testWeAreCarefulWithBuiltinProtocols
testWeAreCarefullWithBuiltinProtocolsBase
# Duck typing
testOverloadingAndDucktypeCompatibility

# callable
testIdentityHigherOrderFunction*
testGenericFineCallableInBound
testReprocessCallableArg
testGenericTypeAliasesCallable
testGenericTypeAliasesImportingWithoutTypeVar

# parser recovery in type comments / types in string literals
testInvalidStrLiteralSpaces
testInvalidStrLiteralStrayBrace
testInvalidMultilineLiteralType

# Global
testAssignToFuncDefViaGlobalDecl2

# Nonlocal
*NonlocalDecl*
testNonlocalAndGlobalDecl
testNewAnalyzerRedefinedNonlocal

# __init__ None needed
testInitReturnTypeError

# Need type annotation for "X"
testNewAnalyzerLessErrorsNeedAnnotation*
testErrorInTypeCheckSecondPassThroughPropagation

# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames

# Invariant note
testAssignmentInvariantNoteForList
testAssignmentInvariantNoteForDict
testInvariantListArgNote
testInvariantDictArgNote
testCallGenericFunctionWithTypeVarValueRestrictionUsingContext

# List unpacking
testMultipleAssignmentWithLists
testMultipleAssignmentWithListsInInitialization
testMultipleAssignmentWithListAndIndexing
testMultipleAssignmentAndGenericSubtyping

# Type execution
testNoneAlias
testNoneAliasStrict

# Wtfs
testEmptyTupleTypeAlias
testOverrideByIdemAliasCorrectType
testOverrideByIdemAliasCorrectTypeReversed
testConditionalExceptionAlias

# weird files
testScriptsAreNotModules

# Formatting qualified name
testSubmoduleMixingImportFromAndImport
testSubmoduleMixingImportFromAndImport2
testErrorFromGoogleCloud
testStubPackageSubModule
testReExportChildStubs3
testImportFromReExportInCycleUsingRelativeImport1
testImportReExportInCycleUsingRelativeImport2

# Formatting class in reveal_type (stashed in 860494e, see also https://github.com/python/mypy/issues/13062)
testNewAnalyzerShadowOuterDefinitionBasedOnOrderTwoPasses
testNewAnalyzerPlaceholderFromOuterScope
testAliasInImportCycle3
testNewAnalyzerTypeVarForwardReferenceErrors

# Aliases in Mypy define generics as X = Foo as Foo[Any, Any]
testAliasToTupleAndCallable

# Formatting Module as types ("ModuleType" instead of Module)
testInvalidOperationsOnModules
testConditionalImportAndAssignInvalidToModule
testModuleAliasRepeatedWithAnnotation

# Tuple iter
testNewAnalyzerFallbackUpperBoundCheckAndFallbacks

# tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5

# Syntax error in type annotation
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same # error twice
testOperatorAssignmentWithIndexLvalue1

# Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4

# Weird ellipsis assignment
testEllipsisInitializerInStubFileWithType
testEllipsisDefaultArgValueInStub2
testEllipsisDefaultArgValueInNonStub
testEllipsisDefaultArgValueInNonStubsMethods

# The type "Type[type]" is not generic and not indexable
testTypeApplicationCrash

# "bool" is not a valid base class
testTestExtendPrimitives

# strict optional
*StrictOptional*
testAssignToFuncDefViaImport
testUnionWithNoneItem
testBoundHigherOrderWithVoid

# type: ignore leads to Any type?
testDunderCallAddition

# Very weird annotation resolution order
testNewAnalyzerAnnotationConflictsWithAttributeSinglePass
testNewAnalyzerAnnotationConflictsWithAttributeTwoPasses
testNewAnalyzerNameConflictsAndMultiLineDefinition

# pyproject.toml
testMultipleModulesInOverridePyProjectTOML
testIgnoreErrorFromMissingStubs1
testIgnoreErrorFromMissingStubs2

# mypy.ini
testRefreshIgnoreErrors1
testRefreshIgnoreErrors2
testRefreshOptions

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testUnlimitedStubErrorVolume

# --disallow-any-generics
testErrorReportingNewAnalyzer

# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --pretty
testReprocessMethodShowSource

# syntax not yet supported
testBreakOutsideLoop
testContinueOutsideLoop
testInvalidGlobalDecl
testAssignToTypeDef

# parser shit
testInvalidLvalues*
testTwoStarExpressions*
testStarExpressionRhs
testStarExpressionInExp
testInvalidDel*
testInvalidTypeDeclaration
testIndexedAssignmentWithTypeDeclaration
testInvalidLvalueWithExplicitType
testInvalidLvalueWithExplicitType3
testInvalidWithTarget
testInvalidTypeAnnotation2

# for type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2

# Won't support for now:
testExpressionRefersToTypeVariable

# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments

# --scripts-are-modules
testScriptsAreModules

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testInlineConfigFineGrained*

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support ever: python 2
*python2
testMypyPathAndPython2Dir

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testNoSubscriptionOfBuiltinAliases

# Skips
testTrailingCommaParsing-skip
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testFunctionInGenericInnerClassTypeVariable-skip
testOverloadInferringArgumentsUsingContext2-skip
