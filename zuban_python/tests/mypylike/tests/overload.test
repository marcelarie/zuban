[case overload_not_overlapping_none]
@overload
def f(x: None) -> object: ...
@overload
def f(x: str) -> str: ...
@overload
def f(x: Any) -> str: ...
def f(x): pass

[case overload_unmatchable_none]
@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_not_overlapping_optional]
from typing import overload, List, Dict, Optional, Sequence, Union, Tuple

@overload
def f(a: List[Dict]) -> List[int]: # E: overloaded function signatures 1 and 2 overlap with incompatible return types
    ...

@overload
def f(a: List[Optional[Dict]]) -> List[Optional[int]]:
    ...

def f(
    a: Union[List[Dict], List[Optional[Dict]]]
) -> Union[List[int], List[Optional[int]]]:
    return [1]

[case overload_overlapping_any]
from typing import overload, TypeVar

T = TypeVar("T")

@overload
def f(x: T) -> T: pass
@overload
def f(x: Any) -> Any: pass
@overload
def f(x: Any) -> Any: pass  # TODO should complain here
def f(x: Any) -> Any: pass

[case overload_merging_nested]
from typing import overload, Any
@overload
def g(x: str) -> list[list[str]]: ...
@overload
def g(x: int) -> list[list[int]]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[list[Any]]"

[case overload_merging_triple1]
from typing import overload, Any
@overload
def g(x: str) -> list[str]: ...
@overload
def g(x: int) -> list[int]: ...
@overload
def g(x: bytes) -> list[bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[Any]"

[case overload_merging_triple2]
from typing import overload, Any
@overload
def g(x: str) -> str: ...
@overload
def g(x: int) -> int: ...
@overload
def g(x: float) -> bytes: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "Any"

[case overload_merging_tuple1]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple2]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any]"

[case overload_merging_tuple3]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, bytes]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple4]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, ...]"

[case overload_merging_tuple5]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, str]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, str]"

[case overload_merging_tuple6]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, Any]"

[case overload_with_callable_type_var_mypy_issue_13436]
from typing import Any, Callable, overload, TypeVar
C = TypeVar("C", bound=Callable[..., object])

@overload
def wrapper(arg: C) -> C: ...
@overload
def wrapper(arg: object) -> object: ...
def wrapper(arg: object) -> object: ...

def case_a(x: int) -> None: pass

reveal_type(case_a)           # N: Revealed type is "def (x: builtins.int)"
reveal_type(wrapper(case_a))  # N: Revealed type is "def (x: builtins.int)"

def case_b(x: Any) -> None: pass

reveal_type(case_b)           # N: Revealed type is "def (x: Any)"
reveal_type(wrapper(case_b))  # N: Revealed type is "def (x: Any)"
