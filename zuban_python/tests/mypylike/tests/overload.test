[case overload_not_overlapping_none]
from typing import overload, Any

@overload
def f(x: None) -> object: ...
@overload
def f(x: str) -> str: ...
@overload
def f(x: Any) -> str: ...
def f(x): pass

[case overload_unmatchable_none_strict_optional]
from typing import overload, Any

@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_unmatchable_none]
# flags: --no-strict-optional
from typing import overload, Any

@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_not_overlapping_optional]
from typing import overload, List, Dict, Optional, Sequence, Union, Tuple

@overload
def f(a: List[Dict]) -> List[int]: # E: overloaded function signatures 1 and 2 overlap with incompatible return types
    ...

@overload
def f(a: List[Optional[Dict]]) -> List[Optional[int]]:
    ...

def f(
    a: Union[List[Dict], List[Optional[Dict]]]
) -> Union[List[int], List[Optional[int]]]:
    return [1]

[case overload_overlapping_any]
from typing import overload, TypeVar, Any

T = TypeVar("T")

@overload
def f(x: T) -> T: pass
@overload
def f(x: Any) -> Any: pass
@overload
def f(x: Any) -> Any: pass  # E: Overloaded function signature 3 will never be matched: signature 2's parameter type(s) are the same or broader
def f(x: Any) -> Any: pass

[case overload_merging_nested]
from typing import overload, Any
@overload
def g(x: str) -> list[list[str]]: ...
@overload
def g(x: int) -> list[list[int]]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[list[Any]]"

[case overload_merging_triple1]
from typing import overload, Any
@overload
def g(x: str) -> list[str]: ...
@overload
def g(x: int) -> list[int]: ...
@overload
def g(x: bytes) -> list[bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[Any]"

[case overload_merging_triple2]
from typing import overload, Any
@overload
def g(x: str) -> str: ...
@overload
def g(x: int) -> int: ...
@overload
def g(x: float) -> bytes: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "Any"

[case overload_merging_tuple1]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple2]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any]"

[case overload_merging_tuple3]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, bytes]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple4]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, ...]"

[case overload_merging_tuple5]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, str]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, str]"

[case overload_merging_tuple6]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, Any]"

[case overload_with_callable_type_var_mypy_issue_13436]
from typing import Any, Callable, overload, TypeVar
C = TypeVar("C", bound=Callable[..., object])

@overload
def wrapper(arg: C) -> C: ...
@overload
def wrapper(arg: object) -> object: ...
def wrapper(arg: object) -> object: ...

def case_a(x: int) -> None: pass

reveal_type(case_a)           # N: Revealed type is "def (x: builtins.int)"
reveal_type(wrapper(case_a))  # N: Revealed type is "def (x: builtins.int)"

def case_b(x: Any) -> None: pass

reveal_type(case_b)           # N: Revealed type is "def (x: Any)"
reveal_type(wrapper(case_b))  # N: Revealed type is "def (x: Any)"

[case overload_union_math_on_class_init_constrained]
from typing import Callable, Union, overload, Generic, TypeVar
T = TypeVar("T", str, int)

class Foo(Generic[T]):
    @overload
    def __init__(self, x: int, y: T): ...
    @overload
    def __init__(self, x: T, y: str): ...
    def __init__(self, x, y): ...

u1: int | str
reveal_type(Foo(1, "")) # N: Revealed type is "__main__.Foo[builtins.str]"
reveal_type(Foo(1, u1)) # N: Revealed type is "__main__.Foo[builtins.int] | __main__.Foo[builtins.str]"

[case overload_union_math_on_class_init_unconstrained]
from typing import Callable, Union, overload, Generic, TypeVar
T = TypeVar("T")

class Foo(Generic[T]):
    @overload
    def __init__(self, x: int, y: T): ...
    @overload
    def __init__(self, x: T, y: str): ...
    def __init__(self, x, y): ...

u1: int | str
reveal_type(Foo(1, "")) # N: Revealed type is "__main__.Foo[builtins.str]"
reveal_type(Foo(1, u1)) # N: Revealed type is "__main__.Foo[int | str]"

[case multi_dimension_union_math_issue_13595]
# Taken from mypy #13595
from typing import Union, overload

@overload
def f(x: int, y: int) -> None: ...
@overload
def f(x: str, y: int) -> None: ...
@overload
def f(x: int, y: str) -> None: ...
@overload
def f(x: str, y: str) -> None: ...
def f(x, y) -> None: ...

a: Union[int, str]
b: Union[int, str]
f(a, b) # This is valid

[case overload_class_type_var_implementation_match_and_mismatch]
from typing import TypeVar, Callable, Union, overload, Generic, Optional
T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T]):
    @overload
    def foo(self, x: int) -> T: ...
    @overload
    def foo(self, x: str) -> Optional[T]: ...
    @overload
    def foo(self, x: U, y: int) -> Optional[U]: ...
    def foo(self, x, y=None) -> Optional[T]: ... # E: Overloaded function implementation cannot produce return type of signature 3

[case overload_michi_valid_implementation]
# Originally raise by Michi. This should theoretically not lead to errors, but
# Mypy and Zuban both just compare the named parameters, which leads to this
# error.
from typing import overload

@overload
def oof(fn: int) -> int: ...

@overload
def oof(fn2: bytes) -> bytes: ...

def oof(fn: int | bytes | None = None, fn2: bytes | None = None) -> bytes | int: raise NotImplementedError # E: Overloaded function implementation does not accept all possible arguments of signature 2

[case overload_check_defaults_for_implementation_only]
from typing import overload

@overload
def foo(x: int) -> int: ...
@overload
def foo(x: str = ...) -> str: ...
def foo(x: int | str = b"") -> str | int: ... # E: Incompatible default for argument "x" (default has type "bytes", argument has type "int | str")

[case overload_with_self_types_fallback]
# Inspired by testOverloadAndSelfTypesGenericNoOverlap
from typing import overload, Self, Any

class C:
    @overload
    def get(self, obj: None) -> Self: ...
    @overload
    def get(self, obj: int) -> Self: ...
    def get(self, obj) -> Self:
        return self

any: Any
class D(C): ...
d: D
reveal_type(d.get(None))  # N: Revealed type is "__main__.D"
reveal_type(d.get(""))  # E: No overload variant of "get" of "C" matches argument type "str" \
                        # N: Possible overload variants: \
                        # N:     def get(self, obj: None) -> Self \
                        # N:     def get(self, obj: int) -> Self \
                        # N: Revealed type is "Any"

[case overload_with_self_types_union_math]
# Inspired by testOverloadAndSelfTypesGenericNoOverlap
from typing import overload, Self, Any

class C:
    @overload
    def get(self, obj: None) -> Self: ...
    @overload
    def get(self, obj: int) -> int: ...
    def get(self, obj) -> Self | int:
        return self

u: int | None
class D(C): ...
d: D
reveal_type(d.get(u))  # N: Revealed type is "int | __main__.D"

[case overload_classmethod_without_self_type]
# Like testSelfTypeClassMethodOverloadedOnInstance, but without first annotations.
from typing import Optional, Type, TypeVar, overload, Union

Id = int

class AClass:
    @overload
    @classmethod
    def delete(cls, id: Id, id2: Id) -> Optional[int]: ...

    @overload
    @classmethod
    def delete(cls, id: AClass, id2: None = None) -> Optional[int]: ...

    @classmethod
    def delete(cls, id: Union[AClass, Id], id2: Optional[Id] = None) -> Optional[int]:
        ...

def foo(x: Type[AClass]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: builtins.int, id2: builtins.int) -> Union[builtins.int, None], def (id: __main__.AClass, id2: None =) -> Union[builtins.int, None])"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: builtins.int, id2: builtins.int) -> Union[builtins.int, None], def (id: __main__.AClass, id2: None =) -> Union[builtins.int, None])"
    y.delete(10, 20)
    y.delete(y)

def bar(x: AClass) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: builtins.int, id2: builtins.int) -> Union[builtins.int, None], def (id: __main__.AClass, id2: None =) -> Union[builtins.int, None])"
    x.delete(10, 20)

[case self_type_filtering_of_classmethod_overload]
from typing import Optional, Type, TypeVar, overload, Union, Generic

T = TypeVar("T")

class A(Generic[T]):
    @overload
    @classmethod
    def delete(cls: Type[A[int]], id: int) -> int: ...

    @overload
    @classmethod
    def delete(cls: Type[A[str]], id: str) -> str: ...

    @overload
    @classmethod
    def delete(cls: Type[A[str]], id: bytes) -> bytes: ...

    @classmethod
    def delete(cls, id):
        ...

def foo_no_generics(x: Type[A]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: int) -> int, def (id: str) -> str, def (id: bytes) -> bytes)"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: int) -> int, def (id: str) -> str, def (id: bytes) -> bytes)"
    reveal_type(y.delete(10))  # N: Revealed type is "int"

def bar_no_generics(x: A) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: int) -> int, def (id: str) -> str, def (id: bytes) -> bytes)"
    reveal_type(x.delete(""))  # N: Revealed type is "str"

def foo_str(x: Type[A[str]]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: str) -> str, def (id: bytes) -> bytes)"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: str) -> str, def (id: bytes) -> bytes)"
    reveal_type(y.delete(10))  # E: No overload variant of "delete" of "A" matches argument type "int" \
                               # N: Possible overload variants: \
                               # N:     def delete(cls, id: str) -> str \
                               # N:     def delete(cls, id: bytes) -> bytes \
                               # N: Revealed type is "Any"
    reveal_type(y.delete(b''))  # N: Revealed type is "bytes"

def foo_int(x: Type[A[int]]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "def (id: int) -> int"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "def (id: int) -> int"
    reveal_type(y.delete(10))  # N: Revealed type is "int"

def foo_something_else(x: Type[A[list[int]]]) -> None:
    reveal_type(x.delete)  # E: Invalid self argument "Type[A[list[int]]]" to attribute function "delete" with type "overloaded function" \
                           # N: Revealed type is "Any"
    y = x()
    reveal_type(y.delete)  # E: Invalid self argument "Type[A[list[int]]]" to class attribute function "delete" with type "Callable[[Type[A[int]], int], int]" \
                           # N: Revealed type is "Any"

[case overload_star_args_as_self_works]
from typing import Any, overload
class C:
    @overload
    def bar(self, x: C, /) -> None: ...
    @overload
    def bar(self) -> None: ...
    def bar(*args: C) -> None: ...

[case overload_class_type_vars_properly_applied_in_implementation_check]
from typing import Generic, overload, TypeVar

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
class MyClass(Generic[T1, T2]):
    @overload
    def __init__(self: MyClass[None, None], t: None, u: None) -> None: ...

    @overload
    def __init__(self: MyClass[T1, None], t: T1, u: None) -> None: ...

    @overload
    def __init__(self: MyClass[T1, T3], t: T1, u: T2) -> None: ...

    # These errors are wrong, but Mypy also works like that
    def __init__(self, t: T1, u: T2) -> None:  # E: Overloaded function implementation does not accept all possible arguments of signature 1 \
                                               # E: Overloaded function implementation does not accept all possible arguments of signature 2
        pass

[case function_overlapping_kwonly_vs_normal]
[file foo.pyi]
from typing import overload

@overload
def g(*, x: int) -> str: pass
@overload
def g(x: int) -> int: pass

@overload
def h(x: int) -> int: pass
@overload
def h(*, x: int) -> str: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
