[case recursive_alias_union_simplifying_with_generics]
# flags: --mypy-compatible
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

def unite(s: S, t: T) -> S | T: ...

Rec1 = Sequence[Union[Rec1[T], int]]
Rec2 = Sequence[Union[Rec2[T], int, str]]
Rec3 = Sequence[Union[Rec3[T], float]]

i1: Rec1[int]
i2: Rec2[int]
i3: Rec3[int]

s1: Rec1[str]

reveal_type(unite(i1, i1))  # N: Revealed type is "typing.Sequence[... | int]"
reveal_type(unite(i1, i2))  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int | str]"
reveal_type(unite(i2, i1))  # N: Revealed type is "typing.Sequence[... | int | str] | typing.Sequence[... | int]"
reveal_type(unite(i1, i3))  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | float]"
reveal_type(unite(i3, i1))  # N: Revealed type is "typing.Sequence[... | float] | typing.Sequence[... | int]"

u1 = unite(i1, s1)
u2 = unite(s1, i1)
x: str = u1  # E: Incompatible types in assignment (expression has type "Rec1[int] | Rec1[str]", variable has type "str") 
y: str = u2  # E: Incompatible types in assignment (expression has type "Rec1[str] | Rec1[int]", variable has type "str") 
reveal_type(u1)  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int]"
reveal_type(u2)  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int]"

[case recursive_alias_incorrect_generics_no_restrictions]
# flags: --mypy-compatible
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

Rec = list[Union[Rec[T, S], T, S]]

x1: Rec[int, float]
x2: Rec[str, int]
reveal_type(x1)  # N: Revealed type is "list[... | int | float]"
reveal_type(x1[0])  # N: Revealed type is "list[... | int | float] | int | float"
reveal_type(x2)  # N: Revealed type is "list[... | str | int]"
reveal_type(x2[0])  # N: Revealed type is "list[... | str | int] | str | int"

x3: Rec[str]  # E: Bad number of arguments for type alias, expected: 2, given: 1
x4: Rec[str, int, float]  # E: Bad number of arguments for type alias, expected: 2, given: 3
reveal_type(x3)  # N: Revealed type is "list[... | Any]"
reveal_type(x3[0])  # N: Revealed type is "list[... | Any] | Any"
reveal_type(x4)  # N: Revealed type is "list[... | Any]"
reveal_type(x4[0])  # N: Revealed type is "list[... | Any] | Any"

[case recursive_alias_incorrect_generics_inside_no_restrictions]
# flags: --mypy-compatible
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

Rec1 = list[Union[Rec1[T, S], T, S]]
Rec2 = list[Union[Rec2[T, S, int], T, S]]  # E: Bad number of arguments for type alias, expected: 2, given: 3 # E: Bad number of arguments for type alias, expected: 2, given: 3
Rec3 = list[Union[Rec3[int], T, S]]  # E: Bad number of arguments for type alias, expected: 2, given: 1 # E: Bad number of arguments for type alias, expected: 2, given: 1

x1: Rec1[int, str]
x2: Rec2[int, str]
x3: Rec3[int, str]
reveal_type(x1)  # N: Revealed type is "list[... | int | str]"
reveal_type(x1[0])  # N: Revealed type is "list[... | int | str] | int | str"
reveal_type(x2)  # N: Revealed type is "list[list[... | Any] | int | str]"
reveal_type(x2[0])  # N: Revealed type is "list[... | Any] | int | str"
reveal_type(x3)  # N: Revealed type is "list[list[... | Any] | int | str]"
reveal_type(x3[0])  # N: Revealed type is "list[... | Any] | int | str"
