[case invalid-type-var-types]

from typing import TypeVarTuple, ParamSpec
a: list[TypeVarTuple]  # E: Variable "typing.TypeVarTuple" is not valid as a type \
                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
b: list[ParamSpec]  # E: Variable "typing.ParamSpec" is not valid as a type \
                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case invalid_base_class_in_param]
# Checked mypy for this.

def x(a: int):
    class Foo(a): pass  # E: Invalid base class "a"

def y(a: type):  
    class Foo(a): pass

def z(a: type[int]) -> None:
    class Foo(a): pass  # E: Invalid base class "a"

[case keyword_only_params_with_kwargs]

def foo(*, x: int, y: int) -> None: ...

dct: dict[str, int]
foo(**dct)

[case positional_only_params_with_kwargs]

def foo(x, /) -> None: ...

dct: dict[str, int]
foo(**dct) # E: Too few arguments for "foo"

[case strict_optional_none_return]
def foo() -> str:
    return None  # E: Incompatible return value type (got "None", expected "str")

[case no_strict_optional_none_return]
# flags: --no-strict-optional
def foo() -> str:
    return None

[case except_nested_tuple]
try:
    1
except (AttributeError, (NotImplementedError, NameError)) as e:  # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
    reveal_type(e)  # N: Revealed type is "AttributeError | NotImplementedError | NameError"

[case tuple_generic_class_type_comment]
from typing import Generic, TypeVar, Any

T = TypeVar("T")

any: Any

class Foo(Generic[T]):
    x, y = any  # type: (T, int)
    u, v = any  # type: T, int

foo: Foo[str]
reveal_type(foo.x)  # N: Revealed type is "str"
reveal_type(foo.y)  # N: Revealed type is "int"
reveal_type(foo.u)  # N: Revealed type is "str"
reveal_type(foo.v)  # N: Revealed type is "int"

[case inplace_operator_on_undefined_target]
undefined += 1  # E: Name "undefined" is not defined
undefined *= 1

[case alias_of_classes]
class A: ...
class B: ...
X = A | B
x: X
reveal_type(X)  # N: Revealed type is "types.UnionType"
reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case yield_without_expr]
from typing import Generator

def yield_receive1() -> Generator[None, str, None]:
    reveal_type((yield))  # N: Revealed type is "str"

def yield_receive2() -> Generator[str | None, str, None]:
    reveal_type((yield))  # N: Revealed type is "str"
    reveal_type((yield ""))  # N: Revealed type is "str"

def yield_receive3() -> Generator[bytes | int, str, None]:
    reveal_type((yield))  # E: Yield value expected \
                          # N: Revealed type is "str"
    reveal_type((yield b""))  # N: Revealed type is "str"

[case yield_without_expr_with_any]
from typing import Generator

def yield_receive4() -> object:
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

def yield_receive5() -> None:  # E: The return type of a generator function should be "Generator" or one of its supertypes
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

[case yield_without_expr_with_generator_sub_type]
from typing import Generator

class SubGenerator(Generator[int, str, bytes]): ...

def yield_receive() -> SubGenerator:  # E: The return type of a generator function should be "Generator" or one of its supertypes
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

[case yield_with_generator]
from typing import Generator

def yield_send() -> Generator[bytes, str, float]:  # E: Missing return statement
    reveal_type((yield b""))  # N: Revealed type is "str"
    if int():
        return 1.0

[case yield_from_with_generator_subtype]
from typing import Generator, Any, Self

a: Any

class SubGenerator1(Generator[int, str, bytes]):
    send = a
    throw = a

class SubGenerator2(Generator[int, str, bytes]):
    send = a
    throw = a
    def __iter__(self) -> Self:
        raise NotImplementedError

def g() -> Generator[int, None, None]:
    x = yield from ()  # E: Function does not return a value (it only ever returns None)
    y = yield from SubGenerator1()
    reveal_type(y)  # N: Revealed type is "bytes"
    z = yield from SubGenerator2()
    # TODO This Any is wrong, but that's also how Mypy does it.
    reveal_type(z)  # N: Revealed type is "Any"

[case invalid_forward_reference]
a: 'int; str'  # E: Syntax error in type annotation
b: 'int str'  # E: invalid syntax

[case typing_extensions_assert_type]
from typing_extensions import assert_type, Literal

assert_type(1, Literal[1])
assert_type(1, Literal[2])  # E: Expression is of type "Literal[1]", not "Literal[2]"

[case yield_from_in_typed_and_untyped]
# testNoYieldFromInAsyncDef tests this as well, but not with untyped.
from typing import Any

async def f1():
    yield from []  # E: "yield from" in async function
async def g1():
    x = yield from []  # E: "yield from" in async function
async def f2() -> Any:
    yield from []  # E: "yield from" in async function
async def g2() -> Any:
    x = yield from []  # E: "yield from" in async function

[case __slots___implicit_tuple]
class Foo:
    __slots__ = 'a', 'b'

    def __init__(self) -> None:
        self.a = 3
        self.b = 4
        self.c = 5 # E: Trying to assign name "c" that is not in "__slots__" of type "__main__.Foo"

[case __slots___string_only]
class Foo:
    __slots__ = 'foo'

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3 # E: Trying to assign name "bar" that is not in "__slots__" of type "__main__.Foo"

[case __slots___star_ignored]
class Foo:
    __slots__ = *'foo', "bar"

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3
        self.f = 3
        self.other = 3

class Bar:
    __slots__ = (*('foo',),)

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3
        self.f = 3
        self.other = 3

[case type_type_annotation]
# No such test exists in Mypy (only for recursive aliases)
foo: type[type[int]]  # E: Type[...] can't contain another Type[...]

[case type_type_alias_circular]
A = type["B"]  # E: Type[...] can't contain another Type[...]
B = list[type[A]]

[case assign_bool_to_false_true_literal]
from typing import Literal
blo: bool
bla: Literal[False, True] = blo

if int():
    blo = bla

[case walrus_context]
foo: list[int]
(foo := reveal_type([]))  # N: Revealed type is "list[int]"
reveal_type(foo)  # N: Revealed type is "list[int]"

[case imports_dunder_all_imports_modified1]
from m1 import *
C()
D  # E: Name "D" is not defined
E  # E: Name "E" is not defined
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.remove("D")
[file m2.pyi]
__all__ = ['C', 'D']
class C: pass
class D: pass
class E: pass

[case imports_dunder_all_imports_modified2]
from m1 import C
from m1 import D
from m1 import E  # E: Module "m1" has no attribute "E"
C()
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.append("D")
class D: pass
[file m2.pyi]
__all__ = ['C']
class C: pass
class E: pass

[case import_no_reexport_if_importing_submodule]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "builtins.str"

[file mod/__init__.pyi]
from mod import submod

[file mod/submod.pyi]
class C:
    a: str

[case import_no_reexport_if_importing_submodule_with_import_as]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "builtins.str"

[file mod/__init__.pyi]
import mod.submod as submod

[file mod/submod.pyi]
class C:
    a: str

[case use_context_of_star_import]
from foo import *

x = [""]
y = []
z = [""]  # E: List item 0 has incompatible type "str"; expected "int"
[file foo.py]
x: list[object]
y: list[int]
z: list[int]

[case import_recursion_usage1]
# A bit like testCyclicUndefinedImportWithName, but with a usage
import a
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
reveal_type(no_such_export)  # N: Revealed type is "Any"
[file b.py]
from a import no_such_export

[case import_recursion_usage2]
import a
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
[file b.py]
from a import no_such_export
reveal_type(no_such_export)  # N: Revealed type is "Any"

[case import_recursion_usage3]
import a
reveal_type(a.no_such_export)  # N: Revealed type is "Any"
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
[file b.py]
from a import no_such_export

[case class_var_without_type_qualifier]
from typing import ClassVar

class Foo:
    x: ClassVar = 1

reveal_type(Foo.x)  # N: Revealed type is "int"
reveal_type(Foo().x)  # N: Revealed type is "int"
Foo().x = 3  # E: Cannot assign to class variable "x" via instance
Foo.x = 4

[case invalid_classvar_attribute]
from typing import ClassVar
class Foo:
    x: ClassVar[str].upper  # E: Invalid type comment or annotation

[case double_classvar_getitem]
from typing import ClassVar
class Foo:
    x: ClassVar[str][str]  # E: Invalid type comment or annotation

[case any_getitem]
from typing import Any
x: Any[int]  # E: Invalid type comment or annotation

[case avoid_type_cycle]
class Foo:
    foo: foo
    bar: list[bar]
    baz += baz  # E: Name "baz" is not defined   # E: Name "baz" is not defined
    bla: baz  # E: Invalid type comment or annotation

    x = x  # E: Name "x" is not defined
    y: x  # E: Variable "__main__.x" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    a = list[a]  # E: Name "a" is not defined
    b: a

[case avoid_type_cycle_in_assignment_expr]
class Foo:
    l = (x := x)  # E: Name "x" is not defined
    y: x  # E: Variable "__main__.x" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    l = (a := list[a])  # E: Name "a" is not defined
    b: a  # E: Variable "__main__.a" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
