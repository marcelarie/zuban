[case invalid-type-var-types]

from typing import TypeVarTuple, ParamSpec
a: list[TypeVarTuple]  # E: Variable "typing.TypeVarTuple" is not valid as a type \
                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
b: list[ParamSpec]  # E: Variable "typing.ParamSpec" is not valid as a type \
                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case invalid_base_class_in_param]
# Checked mypy for this.

def x(a: int):
    class Foo(a): pass  # E: Invalid base class "a"

def y(a: type):  
    class Foo(a): pass

def z(a: type[int]) -> None:
    class Foo(a): pass  # E: Invalid base class "a"

[case keyword_only_params_with_kwargs]

def foo(*, x: int, y: int) -> None: ...

dct: dict[str, int]
foo(**dct)

[case positional_only_params_with_kwargs]

def foo(x, /) -> None: ...

dct: dict[str, int]
foo(**dct) # E: Missing positional argument "x" in call to "foo"

[case strict_optional_none_return]
def foo() -> str:
    return None  # E: Incompatible return value type (got "None", expected "str")

[case no_strict_optional_none_return]
# flags: --no-strict-optional
def foo() -> str:
    return None

[case except_nested_tuple]
try:
    1
except (AttributeError, (NotImplementedError, NameError)) as e:  # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
    reveal_type(e)  # N: Revealed type is "Exception"

[case tuple_generic_class_type_comment]
from typing import Generic, TypeVar, Any

T = TypeVar("T")

any: Any

class Foo(Generic[T]):
    x, y = any  # type: (T, int)
    u, v = any  # type: T, int

foo: Foo[str]
reveal_type(foo.x)  # N: Revealed type is "str"
reveal_type(foo.y)  # N: Revealed type is "int"
reveal_type(foo.u)  # N: Revealed type is "str"
reveal_type(foo.v)  # N: Revealed type is "int"

[case inplace_operator_on_undefined_target]
undefined += 1  # E: Name "undefined" is not defined
undefined *= 1

[case alias_of_classes]
class A: ...
class B: ...
X = A | B
x: X
reveal_type(X)  # N: Revealed type is "types.UnionType"
reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
