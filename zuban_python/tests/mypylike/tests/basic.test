[case invalid-type-var-types]

from typing import TypeVarTuple, ParamSpec
a: list[TypeVarTuple]  # E: Variable "typing.TypeVarTuple" is not valid as a type \
                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
b: list[ParamSpec]  # E: Variable "typing.ParamSpec" is not valid as a type \
                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case invalid_base_class_in_param]
# Checked mypy for this.

def x(a: int):
    class Foo(a): pass  # E: Invalid base class "a"

def y(a: type):  
    class Foo(a): pass

def z(a: type[int]) -> None:
    class Foo(a): pass  # E: Invalid base class "a"

[case keyword_only_params_with_kwargs]

def foo(*, x: int, y: int) -> None: ...

dct: dict[str, int]
foo(**dct)

[case positional_only_params_with_kwargs]

def foo(x, /) -> None: ...

dct: dict[str, int]
foo(**dct) # E: Too few arguments for "foo"

[case strict_optional_none_return]
def foo() -> str:
    return None  # E: Incompatible return value type (got "None", expected "str")

[case no_strict_optional_none_return]
# flags: --no-strict-optional
def foo() -> str:
    return None

[case except_nested_tuple]
try:
    1
except (AttributeError, (NotImplementedError, NameError)) as e:  # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
    reveal_type(e)  # N: Revealed type is "AttributeError | NotImplementedError | NameError"

[case tuple_generic_class_type_comment]
from typing import Generic, TypeVar, Any

T = TypeVar("T")

any: Any

class Foo(Generic[T]):
    x, y = any  # type: (T, int)
    u, v = any  # type: T, int

foo: Foo[str]
reveal_type(foo.x)  # N: Revealed type is "str"
reveal_type(foo.y)  # N: Revealed type is "int"
reveal_type(foo.u)  # N: Revealed type is "str"
reveal_type(foo.v)  # N: Revealed type is "int"

[case inplace_operator_on_undefined_target]
undefined += 1  # E: Name "undefined" is not defined
undefined *= 1

[case operator_return_in_failure_case]
a: A
b: B
x = a & a  # E: Unsupported operand types for & ("A" and "A")
reveal_type(x)  # N: Revealed type is "__main__.B"
class A:
    def __and__(self, x: 'B') -> 'B': pass
class B: pass

[case alias_of_classes]
class A: ...
class B: ...
X = A | B
x: X
reveal_type(X)  # N: Revealed type is "types.UnionType"
reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case yield_without_expr]
from typing import Generator

def yield_receive1() -> Generator[None, str, None]:
    reveal_type((yield))  # N: Revealed type is "str"

def yield_receive2() -> Generator[str | None, str, None]:
    reveal_type((yield))  # N: Revealed type is "str"
    reveal_type((yield ""))  # N: Revealed type is "str"

def yield_receive3() -> Generator[bytes | int, str, None]:
    reveal_type((yield))  # E: Yield value expected \
                          # N: Revealed type is "str"
    reveal_type((yield b""))  # N: Revealed type is "str"

[case yield_without_expr_with_any]
from typing import Generator

def yield_receive4() -> object:
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

def yield_receive5() -> None:  # E: The return type of a generator function should be "Generator" or one of its supertypes
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

[case yield_without_expr_with_generator_sub_type]
from typing import Generator

class SubGenerator(Generator[int, str, bytes]): ...

def yield_receive() -> SubGenerator:  # E: The return type of a generator function should be "Generator" or one of its supertypes
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

[case yield_with_generator]
from typing import Generator

def yield_send() -> Generator[bytes, str, float]:  # E: Missing return statement
    reveal_type((yield b""))  # N: Revealed type is "str"
    if int():
        return 1.0

[case yield_from_with_generator_subtype]
from typing import Generator, Any, Self

a: Any

class SubGenerator1(Generator[int, str, bytes]):
    send = a
    throw = a

class SubGenerator2(Generator[int, str, bytes]):
    send = a
    throw = a
    def __iter__(self) -> Self:
        raise NotImplementedError

def g() -> Generator[int, None, None]:
    x = yield from ()  # E: Function does not return a value (it only ever returns None)
    y = yield from SubGenerator1()
    reveal_type(y)  # N: Revealed type is "bytes"
    z = yield from SubGenerator2()
    # TODO This Any is wrong, but that's also how Mypy does it.
    reveal_type(z)  # N: Revealed type is "Any"

[case invalid_forward_reference]
a: 'int; str'  # E: Syntax error in type annotation
b: 'int str'  # E: invalid syntax

[case typing_extensions_assert_type]
from typing_extensions import assert_type, Literal

assert_type(1, Literal[1])
assert_type(1, Literal[2])  # E: Expression is of type "Literal[1]", not "Literal[2]"

[case yield_from_in_typed_and_untyped]
# testNoYieldFromInAsyncDef tests this as well, but not with untyped.
from typing import Any

async def f1():
    yield from []  # E: "yield from" in async function
async def g1():
    x = yield from []  # E: "yield from" in async function
async def f2() -> Any:
    yield from []  # E: "yield from" in async function
async def g2() -> Any:
    x = yield from []  # E: "yield from" in async function

[case __slots___implicit_tuple]
class Foo:
    __slots__ = 'a', 'b'

    def __init__(self) -> None:
        self.a = 3
        self.b = 4
        self.c = 5 # E: Trying to assign name "c" that is not in "__slots__" of type "__main__.Foo"

[case __slots___string_only]
class Foo:
    __slots__ = 'foo'

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3 # E: Trying to assign name "bar" that is not in "__slots__" of type "__main__.Foo"

[case __slots___star_ignored]
class Foo:
    __slots__ = *'foo', "bar"

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3
        self.f = 3
        self.other = 3

class Bar:
    __slots__ = (*('foo',),)

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3
        self.f = 3
        self.other = 3

[case __slots___inherited]
class Foo:
    __slots__ = 'a', 'b'
    a: int

    def __init__(self) -> None:
        self.a = 3
        self.b = 3

Foo().a = 3
Foo().b = 3
if bool():
    Foo.a = 3
else:
    x = Foo.a  # E: "a" in __slots__ conflicts with class variable access
    reveal_type(x) # N: Revealed type is "int"
Foo.b = 3  # E: "Type[Foo]" has no attribute "b"

[case type_type_annotation]
# No such test exists in Mypy (only for recursive aliases)
foo: type[type[int]]  # E: Type[...] can't contain another Type[...]

[case type_type_alias_circular]
A = type["B"]  # E: Type[...] can't contain another Type[...]
B = list[type[A]]

[case assign_bool_to_false_true_literal]
from typing import Literal
blo: bool
bla: Literal[False, True] = blo

if int():
    blo = bla

[case walrus_context]
foo: list[int]
(foo := reveal_type([]))  # N: Revealed type is "list[int]"
reveal_type(foo)  # N: Revealed type is "list[int]"

[case imports_dunder_all_imports_modified1]
from m1 import *
C()
D  # E: Name "D" is not defined
E  # E: Name "E" is not defined
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.remove("D")
[file m2.pyi]
__all__ = ['C', 'D']
class C: pass
class D: pass
class E: pass

[case imports_dunder_all_imports_modified2]
from m1 import C
from m1 import D
from m1 import E  # E: Module "m1" has no attribute "E"
C()
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.append("D")
class D: pass
[file m2.pyi]
__all__ = ['C']
class C: pass
class E: pass

[case import_no_reexport_if_importing_submodule]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "builtins.str"

[file mod/__init__.pyi]
from mod import submod

[file mod/submod.pyi]
class C:
    a: str

[case import_no_reexport_if_importing_submodule_with_import_as]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "builtins.str"

[file mod/__init__.pyi]
import mod.submod as submod

[file mod/submod.pyi]
class C:
    a: str

[case use_context_of_star_import]
from foo import *

x = [""]
y = []
z = [""]  # E: List item 0 has incompatible type "str"; expected "int"
[file foo.py]
x: list[object]
y: list[int]
z: list[int]

[case import_recursion_usage1]
# A bit like testCyclicUndefinedImportWithName, but with a usage
import a
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
reveal_type(no_such_export)  # N: Revealed type is "Any"
[file b.py]
from a import no_such_export

[case import_recursion_usage2]
import a
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
[file b.py]
from a import no_such_export
reveal_type(no_such_export)  # N: Revealed type is "Any"

[case import_recursion_usage3]
import a
reveal_type(a.no_such_export)  # N: Revealed type is "Any"
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
[file b.py]
from a import no_such_export

[case none_getitem]
None[1]  # E: Value of type "None" is not indexable

[case dict_implicit_literals_no_context]
a = {1: 2 for x in [1]}
reveal_type(a)  # N: Revealed type is "dict[int, int]"

[case dict_implicit_literals_with_context]
a: dict[int, int] = {1: 2 for x in [1]}

[case weird_del_usages]
a = 3
del [], ()
a
del [], (a)
a # E: Trying to read deleted variable "a"
a = 3
del [], (a,)
a # E: Trying to read deleted variable "a"

a = 3
del [a], (a,)  # E: Trying to read deleted variable "a"
a # E: Trying to read deleted variable "a"

[case del_name_as_a_source]
del a  # E: Name "a" is not defined
a + 1  # E: Trying to read deleted variable "a"

[case operator_any_add_result]
# Tests parts of testBinaryOperationsWithDynamicAsRightOperand for both sides
from typing import Any

def foo(x: int, y: Any):
    reveal_type(x + y)  # N: Revealed type is "Any"
    reveal_type(y + x)  # N: Revealed type is "Any"

class A:
    def __radd__(self, a: int) -> str: ...

def bar(x: Any, y: A):
    reveal_type(x + y)  # N: Revealed type is "Any"
    reveal_type(y + x)  # N: Revealed type is "Any"

[case explicit_never_list_tuple_unpacking]
from typing import Never
xx: list[Never] = []

for (y, z) in xx:  # E: "Never" object is not iterable
    reveal_type(y)  # N: Revealed type is "Any"

[case set_literal_item_mismatch]
from typing import Set
x: Set[int] = {1, ""}  # E: Set item 1 has incompatible type "str"; expected "int"

[case inference_context_with_star_import]
import module3
from module1 import *
class X:
    def foo(self) -> None:
        from module2 import *
        m1
        m2
    from module3 import *  # E: Unsupported class scoped import
    m3

[file module1.py]
from typing import Self
def m1() -> Self: ...  # E: Self type is only allowed in annotations within class definition
[file module2.py]
from typing import Self
def m2() -> Self: ...  # E: Self type is only allowed in annotations within class definition
[file module3.py]
from typing import Self
def m3() -> Self: ...  # E: Self type is only allowed in annotations within class definition

[case string_backslash_newline_escape]
from typing import Final, Literal
x: Final = "\
"
def check_empty(literal: Literal[""]): ...
check_empty(x)

[case string_backslash_special_characters_escape]
from typing import Final, Literal
a: Final = "\a"
def check_bell(literal: Literal["\x07"]): ...
check_bell(a)

b: Final = "\b"
def check_backspace(literal: Literal["\x08"]): ...
check_backspace(b)
check_bell(b)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\x08']"; expected "Literal['\x07']"
check_backspace(a) # E: Argument 1 to "check_backspace" has incompatible type "Literal['\x07']"; expected "Literal['\x08']"

f: Final = "\f"
def check_form_feed(literal: Literal["\x0c"]): ...
check_form_feed(f)
check_bell(f)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\x0c']"; expected "Literal['\x07']"

r: Final = "\r"
def check_carriage_return(literal: Literal["\x0d"]): ...
check_carriage_return(r)
check_bell(r)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\r']"; expected "Literal['\x07']"

t: Final = "\t"
def check_tab(literal: Literal["\x09"]): ...
check_tab(t)
check_bell(t)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\t']"; expected "Literal['\x07']"

v: Final = "\v"
def check_vertical_tab(literal: Literal["\x0b"]): ...
check_vertical_tab(v)
check_bell(v)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\x0b']"; expected "Literal['\x07']"

[case string_backslash_octal_escape]
from typing import Literal

def check_octal0(literal: Literal["\x00"]): ...
def check_octal1(literal: Literal["\x01"]): ...
def check_octal7(literal: Literal["\x07"]): ...
def check_octal8(literal: Literal["\x08"]): ...
def check_octalI(literal: Literal["iIi"]): ...
def check_octalI1(literal: Literal["iI1"]): ...
def check_octal18(literal: Literal["\x018"]): ...

check_octal0("\0")
check_octal1("\1")
check_octal7("\7")
check_octal8("\8")  # E: Argument 1 to "check_octal8" has incompatible type "Literal['\\8']"; expected "Literal['\x08']"
check_octalI("i\111i")
check_octalI1("i\1111")
check_octal18("\18")
check_octal18("\018")
check_octal18("\0018")
check_octal18("\00018")  # E: Argument 1 to "check_octal18" has incompatible type "Literal['\x0018']"; expected "Literal['\x018']"

[case string_invalid_escapes]
from typing import Literal
def check(literal: Literal["a"]): ...
def ok(literal: Literal["\\l"]): ...

ok("\l")
check("\l")  # E: Argument 1 to "check" has incompatible type "Literal['\\l']"; expected "Literal['a']"
check("\i")  # E: Argument 1 to "check" has incompatible type "Literal['\\i']"; expected "Literal['a']"
check("\z")  # E: Argument 1 to "check" has incompatible type "Literal['\\z']"; expected "Literal['a']"
check("\ä ")  # E: Argument 1 to "check" has incompatible type "Literal['\\ä ']"; expected "Literal['a']"

[case string_literal_multiline]
from typing import Literal

def foo(y: Literal["abc"]): ...
def bar(y: Literal["ab\nc"]): ...
def baz(y: Literal["""ab
c"""]): ...

# Errors
foo(r'''ab\
c''')
foo(r'''abc
''')
foo("""ab""" '''c''')

foo("""abc""")
foo("""ab\
c""")

foo(u"""abc""")
foo(r"""abc""")
foo(R"""abc""")
foo(U"""abc""")

bar("""ab
c""")
bar('''ab
c''')
bar("""ab\n\
c""")

baz("""ab
c""")
baz(r'''ab
c''')
baz("""ab\nc""")

[out]
main:9: error: Argument 1 to "foo" has incompatible type "Literal['ab\\\nc']"; expected "Literal['abc']"
main:11: error: Argument 1 to "foo" has incompatible type "Literal['abc\n']"; expected "Literal['abc']"
main:13: error: Argument 1 to "foo" has incompatible type "str"; expected "Literal['abc']"

[case fstring_unions]
abc = int

def ok(literal: "a" "bc"): ...
ok(1)
ok("")  # E: Argument 1 to "ok" has incompatible type "str"; expected "int"

def not_ok1(literal: f"a" "bc"): ...  # E: Invalid type comment or annotation
def not_ok2(literal: "a" f"bc"): ...  # E: Invalid type comment or annotation
def not_ok3(literal: f"a" f"bc"): ...  # E: Invalid type comment or annotation

def not_ok4(literal: "\x01" f"bc"): ...  # E: Invalid type comment or annotation
def not_ok5(literal: f"a" "\x01"): ...  # E: Invalid type comment or annotation

[case invalid_hex]
# Theoretically these should raise SyntaxErrors, but for now they don't and that's fine.
from typing import Literal
x: Literal["\xz"]

y: Literal["\UFFFFFFFF"]

[case check_bytes_merging]
from typing import Literal

def foo(y: Literal[b"abc"]): ...
foo(b'a' b'bc')  # E: Argument 1 to "foo" has incompatible type "bytes"; expected "Literal[b'abc']"
foo(b'abc')
foo(b'a' f'bc')  # E: invalid syntax
foo('a' b'bc')  # E: invalid syntax

def simple(y: bytes): ...
simple(b'a' b'bc')

def not_supported(y: Literal[b"abc" b"d"]): ...  # E: Literals with chained bytes are not supported

[case check_bytes_raw]
from typing import Literal

def foo(y: Literal[rb"a\nb"]): ...
foo(b'a\nb')  # E: Argument 1 to "foo" has incompatible type "Literal[b'a\nb']"; expected "Literal[b'a\\nb']"
foo(br'a\nb')
foo(RB"""a\nb""")
foo(br'''''')  # E: Argument 1 to "foo" has incompatible type "Literal[b'']"; expected "Literal[b'a\\nb']"

[case bytes_backslash_special_characters_escape]
from typing import Final, Literal
a: Final = b"\a"
def check_bell(literal: Literal[b"\x07"]): ...
check_bell(a)

b: Final = b"\b"
def check_backspace(literal: Literal[b"\x08"]): ...
check_backspace(b)
check_bell(b)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\x08']"; expected "Literal[b'\x07']"
check_backspace(a) # E: Argument 1 to "check_backspace" has incompatible type "Literal[b'\x07']"; expected "Literal[b'\x08']"

f: Final = b"\f"
def check_form_feed(literal: Literal[b"\x0c"]): ...
check_form_feed(f)
check_bell(f)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\x0c']"; expected "Literal[b'\x07']"

r: Final = b"\r"
def check_carriage_return(literal: Literal[b"\x0d"]): ...
check_carriage_return(r)
check_bell(r)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\r']"; expected "Literal[b'\x07']"
check_bell(b"\n")  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\n']"; expected "Literal[b'\x07']"

t: Final = b"\t"
def check_tab(literal: Literal[b"\x09"]): ...
check_tab(t)
check_bell(t)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\t']"; expected "Literal[b'\x07']"

v: Final = b"\v"
def check_vertical_tab(literal: Literal[b"\x0b"]): ...
check_vertical_tab(v)
check_bell(v)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\x0b']"; expected "Literal[b'\x07']"

[case bytes_invalid_escapes]
from typing import Literal
def check(literal: Literal[b"a"]): ...
def ok(literal: Literal[b"\\l"]): ...

ok(b"\l")
check(b"\l")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\l']"; expected "Literal[b'a']"
check(b"\i")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\i']"; expected "Literal[b'a']"
check(b"\z")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\z']"; expected "Literal[b'a']"
check(b"\ä ")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\\xc3\xa4 ']"; expected "Literal[b'a']"

[case bare_self_aug_assignment]
class Foo:
    def f(self) -> None:
        self.foo += 1  # E: "Self" has no attribute "foo"
        self.bla[1] += 1  # E: "Self" has no attribute "bla"
        self.lst = []  # E: Need type annotation for "lst" (hint: "lst: List[<type>] = ...")

        reveal_type(self.foo)  # N: Revealed type is "Any"
        reveal_type(self.bla)  # E: "Self" has no attribute "bla" # N: Revealed type is "Any"

        self.lst[0] += 1


reveal_type(Foo().foo)  # N: Revealed type is "Any"
reveal_type(Foo().bla)  # E: "Foo" has no attribute "bla" # N: Revealed type is "Any"

Foo().undefined += 1  # E: "Foo" has no attribute "undefined"  # E: "Foo" has no attribute "undefined"

[case aug_assign_tuple_syntax_issue]
class Foo:
    def f(self) -> None:
        self.a = 3
        (self.bar, self.baz) += 1  # E: invalid syntax
        self.b = 3

reveal_type(Foo().a)  # N: Revealed type is "int"
reveal_type(Foo().b)  # N: Revealed type is "int"

[case aug_assign_tuple_syntax_issue2]
a = 1
(a) += 1

[case accessing__file__]
__file__.endswith("")

[case current_module_attrs]
reveal_type(__name__)  # N: Revealed type is "str"
reveal_type(__file__)  # N: Revealed type is "str"
reveal_type(__package__)  # N: Revealed type is "str"
reveal_type(__spec__)  # N: Revealed type is "importlib.machinery.ModuleSpec | None"

# Attributes defined in ModuleType but not actually available in the current module.
__dict__  # E: Name "__dict__" is not defined
__loader__  # E: Name "__loader__" is not defined
__path__  # E: Name "__path__" is not defined
__init__  # E: Name "__init__" is not defined
__getattr__  # E: Name "__getattr__" is not defined

# From object
reveal_type(__doc__)  # N: Revealed type is "str | None"
reveal_type(__annotations__)  # N: Revealed type is "builtins.dict[builtins.str, Any]"
__module__  # E: Name "__module__" is not defined
__hash__  # E: Name "__hash__" is not defined
__eq__  # E: Name "__eq__" is not defined
# From metaclass
mro  # E: Name "mro" is not defined
__base__  # E: Name "__base__" is not defined

def foo() -> None:
    reveal_type(__name__)  # N: Revealed type is "str"
    reveal_type(__file__)  # N: Revealed type is "str"
    reveal_type(__package__)  # N: Revealed type is "str"
    reveal_type(__spec__)  # N: Revealed type is "importlib.machinery.ModuleSpec | None"

    __dict__  # E: Name "__dict__" is not defined
    __loader__  # E: Name "__loader__" is not defined
    __path__  # E: Name "__path__" is not defined
    __init__  # E: Name "__init__" is not defined
    __getattr__  # E: Name "__getattr__" is not defined

    reveal_type(__doc__)  # N: Revealed type is "str | None"
    reveal_type(__annotations__)  # N: Revealed type is "builtins.dict[builtins.str, Any]"
    __module__  # E: Name "__module__" is not defined
    __hash__  # E: Name "__hash__" is not defined
    __eq__  # E: Name "__eq__" is not defined
    mro  # E: Name "mro" is not defined

class Foo:
    reveal_type(__name__)  # N: Revealed type is "str"
    reveal_type(__file__)  # N: Revealed type is "str"
    reveal_type(__package__)  # N: Revealed type is "str"
    reveal_type(__spec__)  # N: Revealed type is "importlib.machinery.ModuleSpec | None"

    __dict__  # E: Name "__dict__" is not defined
    __loader__  # E: Name "__loader__" is not defined
    __path__  # E: Name "__path__" is not defined
    __init__  # E: Name "__init__" is not defined
    __getattr__  # E: Name "__getattr__" is not defined

    reveal_type(__doc__)  # N: Revealed type is "str | None"
    reveal_type(__annotations__)  # N: Revealed type is "builtins.dict[builtins.str, Any]"
    reveal_type(__module__)  # N: Revealed type is "str"
    __hash__  # E: Name "__hash__" is not defined
    __eq__  # E: Name "__eq__" is not defined
    mro  # E: Name "mro" is not defined

[case had_fstring_syntax_error]
a = 'x'
f"{a * 3:1}"
f"{a + ':':24}"
f'{a + ":":24}'
f"{a / 3:9}"  # E: Unsupported operand types for / ("str" and "int")
f"""{'' + ":":24}"""

[case special_builtins_access]
reveal_type(isinstance)  # N: Revealed type is "def (object, Type[Any] | types.UnionType | tuple[..., ...]) -> bool"
reveal_type(issubclass)  # N: Revealed type is "def (Type[Any], Type[Any] | types.UnionType | tuple[..., ...]) -> bool"
reveal_type(super)  # N: Revealed type is "super"

[case special_typing_access]
import typing
reveal_type(typing.TypeVar)  # N: Revealed type is "Type[typing.TypeVar]"
reveal_type(typing.TypeVarTuple)  # N: Revealed type is "Type[typing.TypeVarTuple]"
reveal_type(typing.ParamSpec)  # N: Revealed type is "Type[typing.ParamSpec]"
-- TODO reveal_type(typing.cast)  # N: Revealed type is ""
reveal_type(typing.ClassVar)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.reveal_type)  # N: Revealed type is "def [_T] (_T) -> _T"
reveal_type(typing.NewType)  # N: Revealed type is "Type[typing.NewType]"

[case type_var_likes_access]
import typing
T = typing.TypeVar("T")
Ts = typing.TypeVarTuple("Ts")
P = typing.ParamSpec("P")

reveal_type(T.__name__) # N: Revealed type is "str"
reveal_type(Ts.__name__) # N: Revealed type is "str"
reveal_type(P.__name__) # N: Revealed type is "str"

[case flexible_alias_basics]
from mypy_extensions import FlexibleAlias

X = FlexibleAlias[int]  # E: FlexibleAlias must have exactly two type arguments
Y = FlexibleAlias[int, str, bytes]  # E: FlexibleAlias must have exactly two type arguments
Z = FlexibleAlias[int, str]

reveal_type(FlexibleAlias.undefined)  # N: Revealed type is "Any"
x: X
reveal_type(x)  # N: Revealed type is "Any"
y: Y
reveal_type(y)  # N: Revealed type is "str"
z: Y
reveal_type(z)  # N: Revealed type is "str"

[case import_from_module_with_empty_all]
import foo
foo.X

[file foo.pyi]
__all__ = ()
class X: ...

[case type_differences]
# flags: --strict
from typing import Type, Any
x: Type  # E: Missing type parameters for generic type "Type"
y: type

class Foo(Type): ...  # E: Invalid base class "Type"
class Bar(type): ...

a: Any = ...
if isinstance(a, type):
    reveal_type(a) # N: Revealed type is "Type[Any]"
if issubclass(a, type):
    reveal_type(a) # N: Revealed type is "Type[type]"

isinstance(x, Type)  # E: Argument 2 to "isinstance" has incompatible type "_SpecialForm"; expected "Type[Any] | UnionType | tuple[_ClassInfo, ...]"
issubclass(x, Type)  # E: Argument 2 to "issubclass" has incompatible type "_SpecialForm"; expected "Type[Any] | UnionType | tuple[_ClassInfo, ...]"

type.mro
Type.mro  # E: "_SpecialForm" has no attribute "mro"

[case dict_getitem_context]
def foo(y: dict[int, set[int]]) -> None:
    y[1] = set()

[case import_code]
# flags: --show-error-codes
import lxml  # E: Library stubs not installed for "lxml"  [import-untyped] \
             # N: Hint: "python3 -m pip install lxml-stubs" \
             # N: (or run "mypy --install-types" to install all missing stub packages)
import undefined   # E: Cannot find implementation or library stub for module named "undefined"  [import-not-found]

[case assign_self_to_variable]
from typing import Self

class X:
    def __init__(self) -> None:
        y = self
        y = X()

        z: Self = self
        a = z
        reveal_type(a)  # N: Revealed type is "Self"

    def foo(self: Self) -> None:
        y = self
        y = X()  # E: Incompatible types in assignment (expression has type "X", variable has type "Self")

[case bool_matching_false_and_true_literals]
from typing import Literal
def foo(x: bool, y: Literal[False, True], z: Literal[False, True, ""]) -> None:
    if bool():
        x = y
    if bool():
        y = x
    if bool():
        z = x
    x = z  # E: Incompatible types in assignment (expression has type "Literal[False, True, '']", variable has type "bool")

def bar(x: list[bool], y: list[Literal[False, True]], z: list[Literal[False, True, ""]]) -> None:
    if bool():
        x = y
    if bool():
        y = x

    if bool():
        z = x  # E: Incompatible types in assignment (expression has type "list[bool]", variable has type "list[Literal[False, True, '']]") \
               # N: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance \
               # N: Consider using "Sequence" instead, which is covariant
    x = z  # E: Incompatible types in assignment (expression has type "list[Literal[False, True, '']]", variable has type "list[bool]")

[case dict_comprehension_context]

class A: ...
class B(A): ...

x: dict[A, A] = {B(): B() for _ in [1]}

[case for_loop_avoids_implicit_literals]
for x in ('a', 'b'):
    reveal_type(x)  # N: Revealed type is "str"

[case del_stmt_inference]
from foo import x
[file foo.py]
del x  # E: Name "x" is not defined

[case del_stmt_inference_with_star_import]
from bar import Alias

reveal_type(Alias)  # N: Revealed type is "Any"

[file bar.py]
from foo import *
_Alias = Alias
del Alias

x: _Alias
reveal_type(x)  # N: Revealed type is "int"

[file foo.py]
Alias = int

[case inference_with_star_import_in_def]
def f() -> None:
    from foo import *
    y = x
    reveal_type(y)  # N: Revealed type is "int"
    def x() -> int: ...


[file foo.py]
x = 1

[case star_union]
def f(x: list[bytes] | list[str]):
    y = 1, *x
    reveal_type(y)  # N: Revealed type is "tuple[int | bytes | str, ...]"

[case invalid_star_star_context]
x: dict[int, str] = {**{}}
y: dict[int, bytes] = {**x}  # E: Unpacked dict entry 0 has incompatible type "dict[int, str]"; expected "SupportsKeysAndGetItem[int, bytes]"

e1: dict[int, str] = {**1}  # E: Unpacked dict entry 0 has incompatible type "int"; expected "SupportsKeysAndGetItem[int, str]"

a: dict[str, int] = dict(**{})
b: dict[str, int] = dict(**x)  # E: Keywords must be strings
e2: dict[str, int] = dict(**1)  # E: Argument after ** must be a mapping, not "int"

e3 = {**1}  # E: Unpacked dict entry 0 has incompatible type "int"; expected "SupportsKeysAndGetItem[Never, Never]"
e4 = {"": 1, **1}  # E: Unpacked dict entry 1 has incompatible type "int"; expected "SupportsKeysAndGetItem[str, int]"
reveal_type(e3)  # N: Revealed type is "dict[Any, Any]"
reveal_type(e4)  # N: Revealed type is "dict[str, int]"

[case fstring_tuple]
f"{1,2}"

[case reveal_type_bad_params]
reveal_type()  # E: Too few arguments for "reveal_type"
reveal_type(1, 1)  # E: Too many arguments for "reveal_type"
reveal_type(a=1)  # E: "reveal_type" only accepts one positional argument
