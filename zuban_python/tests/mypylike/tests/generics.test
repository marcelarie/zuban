-- Generally cases that were forgotten in Mypy

-- Generics base classes
-- ---------------------

[case single_generic]
from typing import TypeVar, Generic, Protocol
T = TypeVar('T')
S = TypeVar('S')
U = TypeVar('U')

class P1(Generic[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P2(Generic[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P4(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P5(Generic[T], Generic[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P6(Generic[T], Protocol[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

[builtins fixtures/list.pyi]
[out]

[case type_type_application]
from typing import Type
reveal_type(Type[int]) # N: Revealed type is "Type[int]"

[case subtyping_only_result_generics]
-- It feels like this test is a bit weird, because a generic as a result in
-- Python doesn't really make sense.
from typing import TypeVar
class A: pass
T = TypeVar('T', int, str)
U = TypeVar('U', str, A, int)
def f(x: int) -> T: pass
def g(x: int) -> U: pass
a = f
if int():
    a = f
if int():
    a = g
b = g
if int():
    b = g
if int():
    b = f # E: Incompatible types in assignment (expression has type "Callable[[T], T]", variable has type "Callable[[U], U]")

[case subtyping_complex_generics]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
def f(x: T, y: int, /) -> T: pass
def g(x: T, y: U, /) -> U: pass
def h(x: U, y: U, /) -> U: pass
if int():
    f = f
if int():
    f = g # E: Incompatible types in assignment (expression has type "Callable[[T, U], U]", variable has type "Callable[[T, int], T]")
if int():
    f = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, int], T]")

if int():
    g = f # E: Incompatible types in assignment (expression has type "Callable[[T], T]", variable has type "Callable[[U], U]")
if int():
    g = g
if int():
    g = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, U], U]")

if int():
    h = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[U, U], U]")
if int():
    h = g
if int():
    h = h

[case unite_type_vars_mypy_issue_5874]
from typing import TypeVar, List, Union
T = TypeVar('T')
S = TypeVar('S')

def add(x: List[T], y: List[S]) -> List[Union[T, S]]: ...

a: List[int]
b: List[str]

e: List[Union[int, str]] = add(a, b)

[case nested_generic_mismatch_function]
from typing import TypeVar
T = TypeVar('T')

def add(x: list[T]) -> list[T]: ...

a: list[int] = add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = add([1])

[case nested_generic_mismatch_class]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: list[T]) -> list[T]: ...

a: list[int] = Foo[int]().add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = Foo[int]().add([1])

[case nested_generic_mismatch_function_and_tuple]
from typing import TypeVar
T = TypeVar('T')

def add(x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = add(("",)) # E: Argument 1 to "add" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_class_and_tuple]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = Foo[int]().add(("",)) # E: Argument 1 to "add" of "Foo" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_function_and_callable]
from typing import TypeVar, Callable
T = TypeVar('T')

def add(c: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[str], int | list[str]]
a: int = add(c) # E: Argument 1 to "add" has incompatible type "Callable[[str], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case nested_generic_mismatch_class_and_callable]
from typing import TypeVar, Generic, Callable
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[int], int | list[str]]
a: int = Foo[int]().add(c) # E: Argument 1 to "add" has incompatible type "Callable[[int], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case union_context_class_matching]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

a: Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
b: Foo[str] = Foo("")

c: Foo[int] | int = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | str = Foo("")

c: int | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: str | Foo[str] = Foo("")

[case union_context_class_matching_with_any]
from typing import TypeVar, Generic, Any
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

c: Foo[int] | Any = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | Any = Foo("")

c: Any | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Any | Foo[str] = Foo("")

[case union_context_class_matching_with_overload]
from typing import TypeVar, Generic, overload
T = TypeVar('T')

class Foo(Generic[T]):
    @overload
    def __init__(self, t: T): ...
    @overload
    def __init__(self, t: list[T]): ...
    def __init__(self, t): ...

x: Foo[int] | int = Foo("")
y: Foo[str] | str = Foo("")

lst: list[str]
x = Foo(lst)
y = Foo(lst)

[out]
main:11: error: No overload variant of "Foo" matches argument type "str"
main:11: note: Possible overload variants:
main:11: note:     def __init__(self, t: T) -> Any
main:11: note:     def __init__(self, t: list[T]) -> Any
main:15: error: No overload variant of "Foo" matches argument type "list[str]"
main:15: note: Possible overload variants:
main:15: note:     def __init__(self, t: T) -> Any
main:15: note:     def __init__(self, t: list[T]) -> Any
