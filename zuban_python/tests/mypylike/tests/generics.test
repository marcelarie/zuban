-- Generally cases that were forgotten in Mypy

-- Generics base classes
-- ---------------------

[case single_generic]
from typing import TypeVar, Generic, Protocol
T = TypeVar('T')
S = TypeVar('S')
U = TypeVar('U')

class P1(Generic[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P2(Generic[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T

class P4(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T

class P5(Generic[T], Generic[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T
    z: U

class P6(Generic[T], Protocol[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T
    z: U

[builtins fixtures/list.pyi]
[out]

[case type_type_application]
from typing import Type
reveal_type(Type[int]) # N: Revealed type is "typing._SpecialForm"

[case subtyping_only_result_generics]
-- It feels like this test is a bit weird, because a generic as a result in
-- Python doesn't really make sense.
from typing import TypeVar
class A: pass
T = TypeVar('T', int, str)
U = TypeVar('U', str, A, int)
def f(x: int) -> T: pass # E: A function returning TypeVar should receive at least one argument containing the same Typevar
def g(x: int) -> U: pass # E: A function returning TypeVar should receive at least one argument containing the same Typevar
a = f
if int():
    a = f
if int():
    a = g
b = g
if int():
    b = g
if int():
    b = f # E: Incompatible types in assignment (expression has type "Callable[[int], T]", variable has type "Callable[[int], U]")

[case subtyping_complex_generics]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
def f(x: T, y: int, /) -> T: pass
def g(x: T, y: U, /) -> U: pass
def h(x: U, y: U, /) -> U: pass
if int():
    f = f
if int():
    f = g # E: Incompatible types in assignment (expression has type "Callable[[T, U], U]", variable has type "Callable[[T, int], T]")
if int():
    f = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, int], T]")

if int():
    g = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[T, U], U]")
if int():
    g = g
if int():
    g = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, U], U]")

if int():
    h = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[U, U], U]")
if int():
    h = g
if int():
    h = h

[case unite_type_vars_mypy_issue_5874]
from typing import TypeVar, List, Union
T = TypeVar('T')
S = TypeVar('S')

def add(x: List[T], y: List[S]) -> List[Union[T, S]]: ...

a: List[int]
b: List[str]

e: List[Union[int, str]] = add(a, b)

[case init_type_var_on_self_issue_6520]
from typing import TypeVar, Generic

T = TypeVar('T')
class A:
    def __init__(self, x: T) -> None:
        self.x = x
    def get(self) -> T:  # E: A function returning TypeVar should receive at least one argument containing the same Typevar
        return self.x  # E: Incompatible return value type (got "T", expected "T")

x: int = A('lol').get()

[case nested_generic_mismatch_function]
from typing import TypeVar
T = TypeVar('T')

def add(x: list[T]) -> list[T]: ...

a: list[int] = add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = add([1])

[case nested_generic_mismatch_class]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: list[T]) -> list[T]: ...

a: list[int] = Foo[int]().add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = Foo[int]().add([1])

[case nested_generic_mismatch_function_and_tuple]
from typing import TypeVar
T = TypeVar('T')

def add(x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = add(("",)) # E: Argument 1 to "add" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_class_and_tuple]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = Foo[int]().add(("",)) # E: Argument 1 to "add" of "Foo" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_function_and_callable]
from typing import TypeVar, Callable
T = TypeVar('T')

def add(c: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[str], int | list[str]]
a: int = add(c) # E: Argument 1 to "add" has incompatible type "Callable[[str], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case nested_generic_mismatch_class_and_callable]
from typing import TypeVar, Generic, Callable
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[int], int | list[str]]
a: int = Foo[int]().add(c) # E: Argument 1 to "add" of "Foo" has incompatible type "Callable[[int], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case union_context_class_matching]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

a: Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
b: Foo[str] = Foo("")

c: Foo[int] | int = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | str = Foo("")

c: int | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: str | Foo[str] = Foo("")

[case union_context_class_matching_with_any]
from typing import TypeVar, Generic, Any
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

c: Foo[int] | Any = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | Any = Foo("")

c: Any | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Any | Foo[str] = Foo("")

[case union_context_class_matching_with_overload]
# flags: --mypy-compatible
from typing import TypeVar, Generic, overload
T = TypeVar('T')

class Foo(Generic[T]):
    @overload
    def __init__(self, t: list[T]): ...
    @overload
    def __init__(self, t: T): ...
    def __init__(self, t): ...

x: Foo[int] | int = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
y: Foo[str] | str = Foo("")

lst: list[str]
x = Foo(lst) # E: Argument 1 to "Foo" has incompatible type "list[str]"; expected "list[int]"
y = Foo(lst)

[case contravariant_type_var]
from typing import Generic, TypeVar

T = TypeVar('T')
T_contra = TypeVar('T_contra', contravariant=True)

class A(Generic[T_contra]): pass
class B(A[T]): pass

class C: ...
class D(C): ...

def f(x: A[T], y: A[T]) -> B[T]: ...
def g(x: A[T], y: A[T]) -> A[T]: ...

c: B[C]
d: B[D]
reveal_type(f(c, d)) # N: Revealed type is "__main__.B[__main__.D]"
reveal_type(f(d, c)) # N: Revealed type is "__main__.B[__main__.D]"
x1: A[C] = f(d, c) # E: Argument 1 to "f" has incompatible type "B[D]"; expected "A[C]"
x2: A[C] = f(c, d) # E: Argument 2 to "f" has incompatible type "B[D]"; expected "A[C]"
x3: A[D] = f(d, c)
x4: A[D] = f(c, d)

y1: A[C] = g(d, c) # E: Argument 1 to "g" has incompatible type "B[D]"; expected "A[C]"
y2: A[C] = g(c, d) # E: Argument 2 to "g" has incompatible type "B[D]"; expected "A[C]"
y3: A[D] = g(d, c)
y4: A[D] = g(c, d)

[case type_var_with_co_and_contra_abstract]
from typing import Generic, TypeVar

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): ...
class Contra(Generic[T_contra]): ...

class A: ...
class B(A): ...

def f(x: Co[T], y: Contra[T]) -> T: ...

a_co: Co[A]
b_co: Co[B]
a_contra: Contra[A]
b_contra: Contra[B]

f(a_co, a_contra)
f(b_co, b_contra)
f(a_co, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Contra[A]"
f(b_co, a_contra)

[case type_var_with_co_and_contra_real_life]
from typing import Generic, TypeVar, Iterable
from _typeshed import SupportsWrite

T = TypeVar('T')

class A: ...
class B(A): ...

def f(iterable: Iterable[T], writer: SupportsWrite[T]) -> None:
    for x in iterable:
        writer.write(x)

a_iterable: Iterable[A]
b_iterable: Iterable[B]
a_writer: SupportsWrite[A]
b_writer: SupportsWrite[B]

f(a_iterable, a_writer)
f(b_iterable, b_writer)
f(a_iterable, b_writer) # E: Argument 2 to "f" has incompatible type "SupportsWrite[B]"; expected "SupportsWrite[A]"
f(b_iterable, a_writer)

[case type_var_with_co_and_contra_matrix_reveal_type]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

reveal_type(f(a_co, a_co)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_co, b_co)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(b_co, a_co)) # N: Revealed type is "builtins.list[__main__.A]"

reveal_type(f(a_contra, a_contra)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_contra, b_contra)) # N: Revealed type is "builtins.list[__main__.B]"
reveal_type(f(b_contra, a_contra)) # N: Revealed type is "builtins.list[__main__.B]"

reveal_type(f(a_co, a_contra)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_co, b_contra)) # N: Revealed type is "builtins.list[__main__.A]" \
                               # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
reveal_type(f(b_co, a_contra)) # N: Revealed type is "builtins.list[__main__.B]"
reveal_type(f(a_contra, b_co)) # N: Revealed type is "builtins.list[__main__.B]"
reveal_type(f(b_contra, a_co)) # N: Revealed type is "builtins.list[__main__.B]" \
                               # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
reveal_type(f(a_co, b_contra)) # N: Revealed type is "builtins.list[__main__.A]" \
                               # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"

[case type_var_with_co_and_contra_matrix_no_context]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

f(b_co, a_inv)
f(a_inv, b_co)
f(b_contra, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
f(a_inv, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
f(a_contra, a_inv)
f(a_co, a_inv)
f(b_inv, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
f(b_inv, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"


[case type_var_with_co_and_contra_matrix_invariant_context_simple]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

a1: list[A] = f(a_co, a_co)
a2: list[A] = f(b_co, b_co)
a3: list[A] = f(c_co, c_co)
a4: list[B] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Union[Co[B], Contra[B], Invariant[B]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Union[Co[B], Contra[B], Invariant[B]]"
a5: list[B] = f(b_co, b_co)
a6: list[B] = f(c_co, c_co)
a7: list[C] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Union[Co[C], Contra[C], Invariant[C]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Union[Co[C], Contra[C], Invariant[C]]"
a8: list[C] = f(b_co, b_co) # E: Argument 1 to "f" has incompatible type "Co[B]"; expected "Union[Co[C], Contra[C], Invariant[C]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Union[Co[C], Contra[C], Invariant[C]]"
a9: list[C] = f(c_co, c_co)

[case type_var_with_co_and_contra_matrix_invariant_context_complex]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: list[A] = f(a_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b2: list[A] = f(c_contra, a_co) # E: Argument 1 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b3: list[A] = f(a_contra, c_co)
b4: list[A] = f(c_co, a_contra)

b5: list[B] = f(b_contra, c_co)
b6: list[B] = f(c_co, b_contra)
b7: list[B] = f(a_co, b_contra) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b8: list[B] = f(c_co, a_contra)

[case type_var_with_co_and_contra_matrix_covariant_context_simple]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: Iterable[A] = f(a_co, a_co)
b2: Iterable[A] = f(b_co, b_co)
b2: Iterable[A] = f(c_co, c_co)
b4: Iterable[B] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]" \
                                # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b5: Iterable[B] = f(b_co, b_co)
b6: Iterable[B] = f(c_co, c_co)
b7: Iterable[C] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]" \
                                # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]"
b8: Iterable[C] = f(b_co, b_co) # E: Argument 1 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]" \
                                # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]"
b9: Iterable[C] = f(c_co, c_co)

[case type_var_with_co_and_contra_matrix_covariant_context_complex]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: Iterable[A] = f(a_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b2: Iterable[A] = f(c_contra, a_co) # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]"
b3: Iterable[A] = f(a_contra, c_co)
b4: Iterable[A] = f(c_co, a_contra)

b5: Iterable[B] = f(b_contra, c_co)
b6: Iterable[B] = f(c_co, b_contra)
b7: Iterable[B] = f(a_co, b_contra) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b8: Iterable[B] = f(c_co, a_contra)

c1: Iterable[A] = f(b_contra, c_contra)
c2: Iterable[A] = f(c_contra, b_contra)
c3: Iterable[A] = f(b_contra, a_co) # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
c4: Iterable[A] = f(a_co, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
c5: Iterable[A] = f(b_contra, b_co)
c6: Iterable[A] = f(b_co, b_contra)

d1: Iterable[A] = f(c_co, b_contra)
d2: Iterable[A] = f(b_contra, c_co)
d1: Iterable[A] = f(c_contra, b_co) # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]"
d2: Iterable[A] = f(b_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"

[case class_generics_recursion]
from typing import TypeVar
T = TypeVar("T")

class X(list[X[T] | T]): ...

foo: X[int] = X([X([1])])
reveal_type(foo) # N: Revealed type is "__main__.X[int]"
reveal_type(foo[0]) # N: Revealed type is "__main__.X[int] | int"

[case nested_tuple_context_inference1]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    return x

def g(x: TupList[T, T]) -> TupList[T, T]:
    return x

f(g([(1, 1)]))
f(g([(1, "")]))
x = [(1, "")]
g(x) # E: Argument 1 to "g" has incompatible type "list[tuple[int, str]]"; expected "list[tuple[int, int]]"

x1: TupList[object, object] = f(g([(1, 1)]))
x2: TupList[int, int] = f(g([(1, 1)]))
x3: TupList[int, int] = f(g([(1, "")])) # E: List item 0 has incompatible type "tuple[int, str]"; expected "tuple[int, int]"
x4: TupList[str, str] = f(g([(1, 1)])) # E: List item 0 has incompatible type "tuple[int, int]"; expected "tuple[str, str]"

[case nested_tuple_context_inference2]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError
def g(x: TupList[tuple[T, T], tuple[T, T]]) -> TupList[T, T]:
    raise NotImplementedError

f(g([((1, 1), (1, 1))]))
f(g([((1, 1), (1, ""))]))
x = [((1, 1), (1, ""))]
g(x) # E: Argument 1 to "g" has incompatible type "list[tuple[tuple[int, int], tuple[int, str]]]"; expected "list[tuple[tuple[int, int], tuple[int, int]]]"


x1: TupList[object, object] = f(g([((1, 1), (1, 1))]))
x2: TupList[int, int] = f(g([((1, 1), (1, 1))]))
x3: TupList[int, int] = f(g([((1, 1), (1, ""))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, str]]"; expected "tuple[tuple[int, int], tuple[int, int]]"
x4: TupList[str, str] = f(g([((1, 1), (1, 1))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, int]]"; expected "tuple[tuple[str, str], tuple[str, str]]"

[case nested_tuple_context_inference3]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError
def g(x: TupList[T, T]) -> TupList[tuple[T, T], tuple[T, T]]:
    raise NotImplementedError

f(g([(1, 1)]))
f(g([(1, "")]))
x = [(1, "")]
g(x) # E: Argument 1 to "g" has incompatible type "list[tuple[int, str]]"; expected "list[tuple[int, int]]"

x1: TupList[tuple[object, object], tuple[object, object]] = f(g([(1, 1)]))
x2: TupList[tuple[int, int], tuple[int, int]] = f(g([(1, 1)]))
x3: TupList[tuple[int, int], tuple[int, int]] = f(g([(1, "")])) # E: List item 0 has incompatible type "tuple[int, str]"; expected "tuple[int, int]"
x4: TupList[tuple[str, str], tuple[str, str]] = f(g([(1, 1)])) # E: List item 0 has incompatible type "tuple[int, int]"; expected "tuple[str, str]"

[case nested_tuple_context_inference4]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[tuple[T, T], tuple[T, T]]) -> TupList[T, T]:
    raise NotImplementedError
def g(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError

f(g([((1, 1), (1, 1))]))
f(g([((1, 1), (1, ""))])) # E: Argument 1 to "f" has incompatible type "list[tuple[tuple[int, int], tuple[int, str]]]"; expected "list[tuple[tuple[int, int], tuple[int, int]]]"
x = [((1, 1), (1, ""))]
f(g(x)) # E: Argument 1 to "f" has incompatible type "list[tuple[tuple[int, int], tuple[int, str]]]"; expected "list[tuple[tuple[int, int], tuple[int, int]]]"

x1: TupList[object, object] = f(g([((1, 1), (1, 1))]))
x2: TupList[int, int] = f(g([((1, 1), (1, 1))]))
x3: TupList[int, int] = f(g([((1, 1), (1, ""))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, str]]"; expected "tuple[tuple[int, int], tuple[int, int]]"
x4: TupList[str, str] = f(g([((1, 1), (1, 1))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, int]]"; expected "tuple[tuple[str, str], tuple[str, str]]"

[case context_inference_with_any]
from typing import TypeVar, Generic
class Foo(Generic[U]): ...
U = TypeVar('U')
T = TypeVar('T', Foo[int], Foo[str])

def f(x: T, y: T) -> list[T]:
    return [x, y]

fi: Foo[int]
fs: Foo[str]
x: list[Foo[int]] = f(fi, fi)
x: list[Foo[int]] = f(fi, fs) # E: Argument 2 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
x: list[Foo[int]] = f(fs, fi) # E: Argument 1 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
y: list[Foo[Any]] = f(fi, fi)
y: list[Foo[Any]] = f(fs, fs)
f(fi, fs) # E: Argument 2 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
y: list[Foo[Any]] = f(fi, fs) # E: Argument 2 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
f(fs, fi) # E: Argument 2 to "f" has incompatible type "Foo[int]"; expected "Foo[str]"
y: list[Foo[Any]] = f(fs, fi) # E: Argument 2 to "f" has incompatible type "Foo[int]"; expected "Foo[str]"

[case generic_covariant_match]
from typing import TypeVar, Sequence

T = TypeVar("T")

def foo(x: T, y: T) -> T: ...

x: list[Sequence[int]]
y: list[Sequence[object]]

reveal_type(foo(x, y)) # N: Revealed type is "typing.Sequence[typing.Sequence[object]]"
reveal_type(foo(y, x)) # N: Revealed type is "typing.Sequence[typing.Sequence[object]]"

[case class_attribute_inheritance_access]
from typing import TypeVar, Generic

T = TypeVar("T")
U = TypeVar("U")

class A(Generic[T, U]):
    x: tuple[U, T]
class B(A[list[U], tuple[T]]): ...
class C(B[str, float]): ...

reveal_type(A[int, str]().x)  # N: Revealed type is "tuple[str, int]"
reveal_type(B[int, str]().x)  # N: Revealed type is "tuple[tuple[str], list[int]]"
reveal_type(C().x)  # N: Revealed type is "tuple[tuple[float], list[str]]"

[case self_attribute_inheritance_access]
from typing import TypeVar, Generic

T = TypeVar("T")
U = TypeVar("U")

class A(Generic[T, U]):
    def foo(self) -> None:
        self.x: tuple[U, T]
class B(A[list[U], tuple[T]]): ...
class C(B[str, float]): ...

reveal_type(A[int, str]().x)  # N: Revealed type is "tuple[str, int]"
reveal_type(B[int, str]().x)  # N: Revealed type is "tuple[tuple[str], list[int]]"
reveal_type(C().x)  # N: Revealed type is "tuple[tuple[float], list[str]]"

[case different_variances]
from typing import Generic, TypeVar, Callable, List, Sequence

T = TypeVar('T')
T_contra = TypeVar('T_contra', contravariant=True)

class A(Generic[T_contra]): pass
class B(Generic[T]): pass

class C: ...
class D(C): ...

def g(x: Sequence[T], y: Sequence[T]) -> T: ...
def h(x: A[T], y: A[T]) -> T: ...
def i(x: Callable[[Sequence[T]], None], y: Callable[[Sequence[T]], None]) -> T: ...
def j(x: Callable[[A[T]], None], y: Callable[[A[T]], None]) -> T: ...
def k(x: Callable[[Callable[[Sequence[T]], None]], None], y: Callable[[Callable[[Sequence[T]], None]], None]) -> T: ...
def l(x: Callable[[Callable[[A[T]], None]], None], y: Callable[[Callable[[A[T]], None]], None]) -> T: ...

c: Sequence[C]
d: Sequence[D]
ac: A[C]
ad: A[D]
c_c: Callable[[Sequence[C]], None]
c_d: Callable[[Sequence[D]], None]
c_ac: Callable[[A[C]], None]
c_ad: Callable[[A[D]], None]
c_c_c: Callable[[Callable[[Sequence[C]], None]], None]
c_c_d: Callable[[Callable[[Sequence[D]], None]], None]
c_c_ac: Callable[[Callable[[A[C]], None]], None]
c_c_ad: Callable[[Callable[[A[D]], None]], None]

reveal_type(g(c, d))  # N: Revealed type is "__main__.C"
reveal_type(h(ac, ad))  # N: Revealed type is "__main__.D"
reveal_type(i(c_c, c_d))  # N: Revealed type is "__main__.D"
reveal_type(i(c_d, c_c))  # N: Revealed type is "__main__.D"
reveal_type(j(c_ac, c_ad))  # N: Revealed type is "__main__.C"
reveal_type(j(c_ad, c_ac))  # N: Revealed type is "__main__.C"
reveal_type(k(c_c_c, c_c_d))  # N: Revealed type is "__main__.C"
reveal_type(k(c_c_d, c_c_c))  # N: Revealed type is "__main__.C"
reveal_type(l(c_c_ac, c_c_ad))  # N: Revealed type is "__main__.D"
reveal_type(l(c_c_ad, c_c_ac))  # N: Revealed type is "__main__.D"

[case nested_invariance]
from typing import Generic, TypeVar, Sequence

T = TypeVar('T')

class X(Generic[T]): ...
class C: ...
class D(C): ...

def x(x: X[Sequence[T]], y: X[Sequence[T]]) -> T: ...
x_s_c: X[Sequence[C]]
x_s_d: X[Sequence[D]]
x(x_s_c, x_s_d)  # E: Argument 2 to "x" has incompatible type "X[Sequence[D]]"; expected "X[Sequence[C]]"

[case self_generic_filter]
from typing import Generic, TypeVar, overload, Any

T = TypeVar('T')

class X(Generic[T]):
    @overload
    def foo(self: X[int]) -> T: ...
    @overload
    def foo(self: X[int], second: int) -> T: ...
    @overload
    def foo(self: X[float]) -> T: ...
    @overload
    def foo(self: X[str]) -> T: ...
    def foo(self: X[Any], second: int = 1) -> T: ...

x_int: X[int]
x_str: X[str]
x_float: X[float]
x_bytes: X[bytes]
x_any: X[Any]

reveal_type(x_int.foo())  # N: Revealed type is "int"
reveal_type(x_str.foo())  # N: Revealed type is "str"
reveal_type(x_float.foo())  # N: Revealed type is "float"
reveal_type(x_any.foo())  # N: Revealed type is "Any"

reveal_type(x_int.foo(1))  # N: Revealed type is "int"
x_str.foo(1)  # E: Too many arguments for "foo" of "X"

x_bytes.foo()  # E: Invalid self argument "Type[X[bytes]]" to class attribute function "foo" with type "Callable[[X[int]], T]"

[case type_var_restriction_subtyping]
from typing import TypeVar, Generic
X = TypeVar('X', int, str)
class S(str): pass
class C(Generic[X]):
    def __init__(self, x: X) -> None: pass
x = C("")
y = C(S())
if int():
    x = y
    y = x
c_int = C(1) # type: C[int]
if int():
    y = c_int # E: Incompatible types in assignment (expression has type "C[int]", variable has type "C[str]")

[case self_type_property_with_generics]
T = TypeVar("T")
class Foo(Generic[T]):
    @property
    def f(self: Foo[int]) -> T: raise NotImplementedError

foo: Foo[int]
bar: Foo[str]
reveal_type(foo.f)  # N: Revealed type is "builtins.int"
reveal_type(bar.f)  # E: Invalid self argument "Foo[str]" to attribute function "f" with type "Callable[[Foo[int]], T]" \
                    # N: Revealed type is "Any"

[case generic_method_on_class_access_no_overload]
from typing import TypeVar, Generic, Self, Tuple

T = TypeVar('T')
U = TypeVar('U', bound=int)

class Foo(Generic[T]):
    def foo(self: Self, t: T, u: U) -> Tuple[Self, T, U]: ...

reveal_type(Foo.foo)  # N: Revealed type is "def [T, Self <: __main__.Foo[T], U <: builtins.int] (self: Self, t: T, u: U) -> Tuple[Self, T, U]"

fooi: Foo[int]
reveal_type(Foo.foo(fooi, "", 1))  # N: Revealed type is "tuple[__main__.Foo[int], str, int]"
reveal_type(Foo.foo(fooi, b"", 1))  # N: Revealed type is "tuple[__main__.Foo[int], object, int]"

[case generic_method_on_class_access_overload]
from typing import TypeVar, Generic, Self, overload, Tuple

T = TypeVar('T')
U = TypeVar('U', bound=int)

class Foo(Generic[T]):
    @overload
    def bar(self: Self, t: T, u: U) -> Tuple[Self, T, U]: ...
    @overload
    def bar(self: Self, t: T, u: U, q: int) -> Tuple[Self, T, U]: ...
    def bar(self: Self, t: T, u: U, q: int | None = None) -> Tuple[Self, T, U]: ...

reveal_type(Foo.bar)  # N: Revealed type is "Overload(def [T, Self <: __main__.Foo[T], U <: builtins.int] (self: Self, t: T, u: U) -> Tuple[Self, T, U], def [T, Self <: __main__.Foo[T], U <: builtins.int] (self: Self, t: T, u: U, q: builtins.int) -> Tuple[Self, T, U])"

fooi: Foo[int]
reveal_type(Foo.bar(fooi, "", 1))  # N: Revealed type is "tuple[__main__.Foo[int], str, int]"
reveal_type(Foo.bar(fooi, b"", 1))  # N: Revealed type is "tuple[__main__.Foo[int], object, int]"

[case nested_late_bound_type_vars]
from typing import TypeVar, Callable
B = TypeVar("B", bound=int)
B2 = TypeVar("B2", bound=int)
T = TypeVar("T")
def foo(x: T, c: Callable[[B, B], None]) -> None: ...

def same(x: int, y: int) -> None: ...
def same_wrong(x: str, y: str) -> None: ...
def other(x: int, y: str) -> None: ...
foo(1.0, same)
foo(1.0, same_wrong)  # E: Argument 2 to "foo" has incompatible type "Callable[[str, str], None]"; expected "Callable[[B, B], None]"
foo(1.0, other)  # E: Argument 2 to "foo" has incompatible type "Callable[[int, str], None]"; expected "Callable[[B, B], None]"

def tv1(x: B, y: B2) -> None: ...
def tv2(x: B2, y: B2) -> None: ...
foo(1.0, tv1)
foo(1.0, tv2)

[case nested_late_bound_type_vars2]
from typing import TypeVar, Callable
B = TypeVar("B", bound=int)
B2 = TypeVar("B2", bound=int)
T = TypeVar("T")
def foo(x: T, c: Callable[[B, B], B]) -> None: ...

def same(x: int, y: int) -> int: ...
def same_wrong(x: str, y: str) -> str: ...
def other(x: int, y: str) -> object: ...
foo(1.0, same)  # E: Argument 2 to "foo" has incompatible type "Callable[[int, int], int]"; expected "Callable[[B, B], B]"
foo(1.0, same_wrong)  # E: Argument 2 to "foo" has incompatible type "Callable[[str, str], str]"; expected "Callable[[B, B], B]"
foo(1.0, other)  # E: Argument 2 to "foo" has incompatible type "Callable[[int, str], object]"; expected "Callable[[B, B], B]"

def tv1(x: B, y: B2) -> B2: ...
def tv2(x: B2, y: B2) -> B2: ...
foo(1.0, tv1)
foo(1.0, tv2)

[case transitive_constraints_pick_correct_bound]
# A bit like testInferenceAgainstGenericBoundsAndValues, but another case as
# well.
from typing import TypeVar, Callable, List

class A: ...
class B(A): ...
class C(B): ...

UA = TypeVar('UA', bound=A)
UB = TypeVar('UB', bound=B)
UC = TypeVar('UC', bound=C)
T = TypeVar("T")

def dec1(f: Callable[[UA], T]) -> Callable[[UA], List[T]]: ...
def dec2(f: Callable[[UC], T]) -> Callable[[UC], List[T]]: ...
def id1(x: UB) -> UB: ...

reveal_type(dec1(id1))  # N: Revealed type is "def [UB <: __main__.B] (UB) -> list[UB]"
reveal_type(dec2(id1))  # N: Revealed type is "def [UC <: __main__.C] (UC) -> list[UC]"

[case transitive_constraints_avoid_same_function_tv_confusion]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")

def combine(f: Callable[[T1], T1], g: Callable[[T2], int]) -> Callable[[T1, T2], Tuple[T1, T2]]: ...
def id1(x: T3) -> T3: ...
def id2(x: T4) -> T4: ...

reveal_type(combine(id1, id2))  # N: Revealed type is "def [T1] (T1, int) -> tuple[T1, int]"
reveal_type(combine(id1, id1))  # N: Revealed type is "def [T1] (T1, int) -> tuple[T1, int]"

[case transitive_constraints_type_var_tuple_propagation1]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec(f: Callable[[Tuple[Unpack[Us]], Unpack[Ts]], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Ts]], Tuple[Unpack[Us]]]: ...

def connect1(x: Tuple[Unpack[Vs]], *args: Unpack[Vs]) -> Tuple[int, str]: ...
def connect2(x: Tuple[Unpack[Vs]], y: str, z: int) -> Tuple[Unpack[Vs]]: ...
def connect3(x: Tuple[bytes, str], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...

reveal_type(dec(connect1))  # N: Revealed type is "def (int, str) -> tuple[int, str]"
reveal_type(dec(connect2))  # N: Revealed type is "def (str, int) -> tuple[str, int]"
reveal_type(dec(connect3))  # N: Revealed type is "def [Ts] (*Unpack[Ts]) -> tuple[bytes, str]"

[case transitive_constraints_type_var_tuple_propagation2]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec(f: Callable[[Tuple[Unpack[Us]], Unpack[Us]], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Us]], Tuple[Unpack[Ts]]]: ...

def connect1(x: Tuple[Unpack[Vs]], y: int, z: str) -> Tuple[Unpack[Vs]]: ...
def connect2(x: Tuple[str, int], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...
def connect3(x: Tuple[Unpack[Vs]], *args: Unpack[Vs]) -> Tuple[bytes, str]: ...

reveal_type(dec(connect1))  # N: Revealed type is "def (int, str) -> tuple[int, str]"
reveal_type(dec(connect2))  # N: Revealed type is "def (str, int) -> tuple[str, int]"
reveal_type(dec(connect3))  # N: Revealed type is "def [Us] (*Unpack[Us]) -> tuple[bytes, str]"

[case transitive_constraints_type_var_tuple_propagation_reverse1]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec1(f: Callable[[Tuple[int, str], Unpack[Ts]], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Ts]], None]: ...
def dec2(f: Callable[[Tuple[Unpack[Ts]], Unpack[Ts]], Tuple[str, int]]) -> Callable[[Unpack[Ts]], None]: ...

def connect1(x: Tuple[Unpack[Vs]], *args: Unpack[Us]) -> Tuple[Unpack[Vs]]: ...
def connect2(x: Tuple[Unpack[Us]], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...

reveal_type(dec1(connect1))  # N: Revealed type is "def (int, str)"
reveal_type(dec2(connect1))  # N: Revealed type is "def (str, int)"

reveal_type(dec1(connect2))  # N: Revealed type is "def [Ts] (*Unpack[Ts])"
reveal_type(dec2(connect2))  # N: Revealed type is "def (str, int)"

[case transitive_constraints_type_var_tuple_propagation_reverse2]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec(f: Callable[[Tuple[Unpack[Ts]], str, bytes], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Ts]], None]: ...

def connect1(x: Tuple[Unpack[Vs]], *args: Unpack[Us]) -> Tuple[Unpack[Vs]]: ...
def connect2(x: Tuple[Unpack[Us]], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...

reveal_type(dec(connect1))  # N: Revealed type is "def [Ts] (*Unpack[Ts])"
reveal_type(dec(connect2))  # N: Revealed type is "def (str, bytes)"

[case transitive_free_type_vars_without_callable]
from typing import TypeVar, Callable, List

T1 = TypeVar("T1")
T2 = TypeVar("T2")

def foo(f: Callable[[T1], T1]) -> T1: ...
def id(x: T2) -> T2: ...

reveal_type(foo(id))  # N: Revealed type is "Never"

[case transitive_constraints_mismatch1]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")

def combine(f: Callable[[T1, T2], T3], g: T2, h: T3) -> Callable[[T1], T3]: ...
def id(x: T4, y: T4) -> T4: ...

reveal_type(combine(id, 1, ""))  # N: Revealed type is "def (object) -> object"

[case transitive_constraints_mismatch2]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")

def combine(f: Callable[[T1, T1], T2], h: T2) -> Callable[[T1], T2]: ...
def id(x: T3, y: int) -> T3: ...

x = combine(id, "")  # E: Incompatible callable argument with type vars
reveal_type(x)  # N: Revealed type is "def (Any) -> Any"
