-- Generally cases that were forgotten in Mypy

-- Generics base classes
-- ---------------------

[case single_generic]
from typing import TypeVar, Generic, Protocol
T = TypeVar('T')
S = TypeVar('S')
U = TypeVar('U')

class P1(Generic[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P2(Generic[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P4(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P5(Generic[T], Generic[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P6(Generic[T], Protocol[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

[builtins fixtures/list.pyi]
[out]

[case type_type_application]
from typing import Type
reveal_type(Type[int]) # N: Revealed type is "Type[int]"

[case subtyping_only_result_generics]
-- It feels like this test is a bit weird, because a generic as a result in
-- Python doesn't really make sense.
from typing import TypeVar
class A: pass
T = TypeVar('T', int, str)
U = TypeVar('U', str, A, int)
def f(x: int) -> T: pass
def g(x: int) -> U: pass
a = f
if int():
    a = f
if int():
    a = g
b = g
if int():
    b = g
if int():
    b = f # E: Incompatible types in assignment (expression has type "Callable[[T], T]", variable has type "Callable[[U], U]")

[case subtyping_complex_generics]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
def f(x: T, y: int, /) -> T: pass
def g(x: T, y: U, /) -> U: pass
def h(x: U, y: U, /) -> U: pass
if int():
    f = f
if int():
    f = g # E: Incompatible types in assignment (expression has type "Callable[[T, U], U]", variable has type "Callable[[T, int], T]")
if int():
    f = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, int], T]")

if int():
    g = f # E: Incompatible types in assignment (expression has type "Callable[[T], T]", variable has type "Callable[[U], U]")
if int():
    g = g
if int():
    g = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, U], U]")

if int():
    h = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[U, U], U]")
if int():
    h = g
if int():
    h = h

[case unite_type_vars_mypy_issue_5874]
from typing import TypeVar, List, Union
T = TypeVar('T')
S = TypeVar('S')

def add(x: List[T], y: List[S]) -> List[Union[T, S]]: ...

a: List[int]
b: List[str]

e: List[Union[int, str]] = add(a, b)
