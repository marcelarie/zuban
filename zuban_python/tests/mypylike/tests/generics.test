-- Generally cases that were forgotten in Mypy

-- Generics base classes
-- ---------------------

[case single_generic]
from typing import TypeVar, Generic, Protocol
T = TypeVar('T')
S = TypeVar('S')
U = TypeVar('U')

class P1(Generic[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P2(Generic[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P4(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P5(Generic[T], Generic[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P6(Generic[T], Protocol[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

[builtins fixtures/list.pyi]
[out]

[case type_type_application]
from typing import Type
reveal_type(Type[int]) # N: Revealed type is "Type[Type[int]]"

[case subtyping_only_result_generics]
-- It feels like this test is a bit weird, because a generic as a result in
-- Python doesn't really make sense.
from typing import TypeVar
class A: pass
T = TypeVar('T', int, str)
U = TypeVar('U', str, A, int)
def f(x: int) -> T: pass # E: A function returning TypeVar should receive at least one argument containing the same Typevar
def g(x: int) -> U: pass # E: A function returning TypeVar should receive at least one argument containing the same Typevar
a = f
if int():
    a = f
if int():
    a = g
b = g
if int():
    b = g
if int():
    b = f # E: Incompatible types in assignment (expression has type "Callable[[int], T]", variable has type "Callable[[int], U]")

[case subtyping_complex_generics]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
def f(x: T, y: int, /) -> T: pass
def g(x: T, y: U, /) -> U: pass
def h(x: U, y: U, /) -> U: pass
if int():
    f = f
if int():
    f = g # E: Incompatible types in assignment (expression has type "Callable[[T, U], U]", variable has type "Callable[[T, int], T]")
if int():
    f = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, int], T]")

if int():
    g = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[T, U], U]")
if int():
    g = g
if int():
    g = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, U], U]")

if int():
    h = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[U, U], U]")
if int():
    h = g
if int():
    h = h

[case unite_type_vars_mypy_issue_5874]
from typing import TypeVar, List, Union
T = TypeVar('T')
S = TypeVar('S')

def add(x: List[T], y: List[S]) -> List[Union[T, S]]: ...

a: List[int]
b: List[str]

e: List[Union[int, str]] = add(a, b)

[case nested_generic_mismatch_function]
from typing import TypeVar
T = TypeVar('T')

def add(x: list[T]) -> list[T]: ...

a: list[int] = add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = add([1])

[case nested_generic_mismatch_class]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: list[T]) -> list[T]: ...

a: list[int] = Foo[int]().add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = Foo[int]().add([1])

[case nested_generic_mismatch_function_and_tuple]
from typing import TypeVar
T = TypeVar('T')

def add(x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = add(("",)) # E: Argument 1 to "add" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_class_and_tuple]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = Foo[int]().add(("",)) # E: Argument 1 to "add" of "Foo" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_function_and_callable]
from typing import TypeVar, Callable
T = TypeVar('T')

def add(c: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[str], int | list[str]]
a: int = add(c) # E: Argument 1 to "add" has incompatible type "Callable[[str], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case nested_generic_mismatch_class_and_callable]
from typing import TypeVar, Generic, Callable
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[int], int | list[str]]
a: int = Foo[int]().add(c) # E: Argument 1 to "add" of "Foo" has incompatible type "Callable[[int], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case union_context_class_matching]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

a: Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
b: Foo[str] = Foo("")

c: Foo[int] | int = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | str = Foo("")

c: int | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: str | Foo[str] = Foo("")

[case union_context_class_matching_with_any]
from typing import TypeVar, Generic, Any
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

c: Foo[int] | Any = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | Any = Foo("")

c: Any | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Any | Foo[str] = Foo("")

[case union_context_class_matching_with_overload]
from typing import TypeVar, Generic, overload
T = TypeVar('T')

class Foo(Generic[T]):
    @overload
    def __init__(self, t: T): ...
    @overload
    def __init__(self, t: list[T]): ...
    def __init__(self, t): ...

x: Foo[int] | int = Foo("")
y: Foo[str] | str = Foo("")

lst: list[str]
x = Foo(lst)
y = Foo(lst)

[out]
main:11: error: No overload variant of "Foo" matches argument type "str"
main:11: note: Possible overload variants:
main:11: note:     def __init__(self, t: T) -> Any
main:11: note:     def __init__(self, t: list[T]) -> Any
main:15: error: No overload variant of "Foo" matches argument type "list[str]"
main:15: note: Possible overload variants:
main:15: note:     def __init__(self, t: T) -> Any
main:15: note:     def __init__(self, t: list[T]) -> Any

[case contravariant_type_var]
from typing import Generic, TypeVar

T = TypeVar('T')
T_contra = TypeVar('T_contra', contravariant=True)

class A(Generic[T_contra]): pass
class B(A[T]): pass

class C: ...
class D(C): ...

def f(x: A[T], y: A[T]) -> B[T]: ...
def g(x: A[T], y: A[T]) -> A[T]: ...

c: B[C]
d: B[D]
reveal_type(f(c, d)) # N: Revealed type is "__main__.B[__main__.D]"
reveal_type(f(d, c)) # N: Revealed type is "__main__.B[__main__.D]"
x1: A[C] = f(d, c) # E: Argument 1 to "f" has incompatible type "B[D]"; expected "A[C]"
x2: A[C] = f(c, d) # E: Argument 2 to "f" has incompatible type "B[D]"; expected "A[C]"
x3: A[D] = f(d, c)
x4: A[D] = f(c, d)

y1: A[C] = g(d, c) # E: Argument 1 to "g" has incompatible type "B[D]"; expected "A[C]"
y2: A[C] = g(c, d) # E: Argument 2 to "g" has incompatible type "B[D]"; expected "A[C]"
y3: A[D] = g(d, c)
y4: A[D] = g(c, d)

[case type_var_with_co_and_contra_abstract]
from typing import Generic, TypeVar

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): ...
class Contra(Generic[T_contra]): ...

class A: ...
class B(A): ...

def f(x: Co[T], y: Contra[T]) -> T: ...

a_co: Co[A]
b_co: Co[B]
a_contra: Contra[A]
b_contra: Contra[B]

f(a_co, a_contra)
f(b_co, b_contra)
f(a_co, b_contra) # E: Cannot infer type argument 1 of "f"
f(b_co, a_contra)

[case type_var_with_co_and_contra_real_life]
from typing import Generic, TypeVar, Iterable
from _typeshed import SupportsWrite

T = TypeVar('T')

class A: ...
class B(A): ...

def f(iterable: Iterable[T], writer: SupportsWrite[T]) -> None:
    for x in iterable:
        writer.write(x)

a_iterable: Iterable[A]
b_iterable: Iterable[B]
a_writer: SupportsWrite[A]
b_writer: SupportsWrite[B]

f(a_iterable, a_writer)
f(b_iterable, b_writer)
f(a_iterable, b_writer) # E: Cannot infer type argument 1 of "f"
f(b_iterable, a_writer)

[case type_var_with_co_and_contra_matrix_reveal_type]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

reveal_type(f(a_co, a_co)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_co, b_co)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(b_co, a_co)) # N: Revealed type is "builtins.list[__main__.A]"

reveal_type(f(a_contra, a_contra)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_contra, b_contra)) # N: Revealed type is "builtins.list[__main__.B]"
reveal_type(f(b_contra, a_contra)) # N: Revealed type is "builtins.list[__main__.B]"

reveal_type(f(a_co, a_contra)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_co, b_contra)) # N: Revealed type is "builtins.list[__main__.A]" \
                               # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
reveal_type(f(b_co, a_contra)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(a_contra, b_co)) # N: Revealed type is "builtins.list[__main__.A]"
reveal_type(f(b_contra, a_co)) # N: Revealed type is "builtins.list[__main__.B]" \
                               # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
reveal_type(f(a_co, b_contra)) # N: Revealed type is "builtins.list[__main__.A]" \
                               # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"

[case type_var_with_co_and_contra_matrix_no_context]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

f(b_co, a_inv)
f(a_inv, b_co)
f(b_contra, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
f(a_inv, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
f(a_contra, a_inv)
f(a_co, a_inv)
f(b_inv, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
f(b_inv, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"


[case type_var_with_co_and_contra_matrix_invariant_context_simple]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

a1: list[A] = f(a_co, a_co)
a2: list[A] = f(b_co, b_co)
a3: list[A] = f(c_co, c_co)
a4: list[B] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Union[Co[B], Contra[B], Invariant[B]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Union[Co[B], Contra[B], Invariant[B]]"
a5: list[B] = f(b_co, b_co)
a6: list[B] = f(c_co, c_co)
a7: list[C] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Union[Co[C], Contra[C], Invariant[C]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Union[Co[C], Contra[C], Invariant[C]]"
a8: list[C] = f(b_co, b_co) # E: Argument 1 to "f" has incompatible type "Co[B]"; expected "Union[Co[C], Contra[C], Invariant[C]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Union[Co[C], Contra[C], Invariant[C]]"
a9: list[C] = f(c_co, c_co)

[case type_var_with_co_and_contra_matrix_invariant_context_complex]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: list[A] = f(a_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b2: list[A] = f(c_contra, a_co) # E: Argument 1 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b3: list[A] = f(a_contra, c_co)
b4: list[A] = f(c_co, a_contra)

b5: list[B] = f(b_contra, c_co)
b6: list[B] = f(c_co, b_contra)
b7: list[B] = f(a_co, b_contra) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b8: list[B] = f(c_co, a_contra)

[case type_var_with_co_and_contra_matrix_covariant_context_simple]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: Iterable[A] = f(a_co, a_co)
b2: Iterable[A] = f(b_co, b_co)
b2: Iterable[A] = f(c_co, c_co)
b4: Iterable[B] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]" \
                                # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b5: Iterable[B] = f(b_co, b_co)
b6: Iterable[B] = f(c_co, c_co)
b7: Iterable[C] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]" \
                                # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]"
b8: Iterable[C] = f(b_co, b_co) # E: Argument 1 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]" \
                                # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]"
b9: Iterable[C] = f(c_co, c_co)

[case type_var_with_co_and_contra_matrix_covariant_context_complex]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: Iterable[A] = f(a_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b2: Iterable[A] = f(c_contra, a_co) # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]"
b3: Iterable[A] = f(a_contra, c_co)
b4: Iterable[A] = f(c_co, a_contra)

b5: Iterable[B] = f(b_contra, c_co)
b6: Iterable[B] = f(c_co, b_contra)
b7: Iterable[B] = f(a_co, b_contra) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b8: Iterable[B] = f(c_co, a_contra)

c1: Iterable[A] = f(b_contra, c_contra)
c2: Iterable[A] = f(c_contra, b_contra)
c3: Iterable[A] = f(b_contra, a_co) # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
c4: Iterable[A] = f(a_co, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
c5: Iterable[A] = f(b_contra, b_co)
c6: Iterable[A] = f(b_co, b_contra)

d1: Iterable[A] = f(c_co, b_contra)
d2: Iterable[A] = f(b_contra, c_co)
d1: Iterable[A] = f(c_contra, b_co) # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]"
d2: Iterable[A] = f(b_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"

[case class_generics_recursion]
from typing import TypeVar
T = TypeVar("T")

class X(list[X[T] | T]): ...

foo: X[int] = X([X([1])])
reveal_type(foo) # N: Revealed type is "__main__.X[int]"
reveal_type(foo[0]) # N: Revealed type is "__main__.X[int] | int"

[case nested_context_inference1]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    return x

def g(x: TupList[T, T]) -> TupList[T, T]:
    return x

f(g([(1, 1)]))
f(g([(1, "")])) # E: Cannot infer type argument 1 of "fun1"

x1: TupList[object, object] = f(g([(1, 1)]))
x2: TupList[int, int] = f(g([(1, 1)]))
x3: TupList[int, int] = f(g([(1, "")])) # E: List item 0 has incompatible type "tuple[int, str]"; expected "tuple[int, int]"
x4: TupList[str, str] = f(g([(1, 1)])) # E: List item 0 has incompatible type "tuple[int, int]"; expected "tuple[str, str]"

[case nested_context_inference2]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError
def g(x: TupList[tuple[T, T], tuple[T, T]]) -> TupList[T, T]:
    raise NotImplementedError

f(g([((1, 1), (1, 1))]))
f(g([((1, 1), (1, ""))])) # E: Cannot infer type argument 1 of "fun1"

x1: TupList[object, object] = f(g([((1, 1), (1, 1))]))
x2: TupList[int, int] = f(g([((1, 1), (1, 1))]))
x3: TupList[int, int] = f(g([((1, 1), (1, ""))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, str]]"; expected "tuple[tuple[int, int], tuple[int, int]]"
x4: TupList[str, str] = f(g([((1, 1), (1, 1))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, int]]"; expected "tuple[tuple[str, str], tuple[str, str]]"

[case nested_context_inference3]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError
def g(x: TupList[T, T]) -> TupList[tuple[T, T], tuple[T, T]]:
    raise NotImplementedError

f(g([(1, 1)]))
f(g([(1, "")])) # E: Cannot infer type argument 1 of "fun1"

x1: TupList[tuple[object, object], tuple[object, object]] = f(g([(1, 1)]))
x2: TupList[tuple[int, int], tuple[int, int]] = f(g([(1, 1)]))
x3: TupList[tuple[int, int], tuple[int, int]] = f(g([(1, "")])) # E: List item 0 has incompatible type "tuple[int, str]"; expected "tuple[int, int]"
x4: TupList[tuple[str, str], tuple[str, str]] = f(g([(1, 1)])) # E: List item 0 has incompatible type "tuple[int, int]"; expected "tuple[str, str]"

[case nested_context_inference4]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[tuple[T, T], tuple[T, T]]) -> TupList[T, T]:
    raise NotImplementedError
def g(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError

f(g([((1, 1), (1, 1))]))
f(g([((1, 1), (1, ""))])) # E: Cannot infer type argument 1 of "fun1"

x1: TupList[object, object] = f(g([((1, 1), (1, 1))]))
x2: TupList[int, int] = f(g([((1, 1), (1, 1))]))
x3: TupList[int, int] = f(g([((1, 1), (1, ""))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, str]]"; expected "tuple[tuple[int, int], tuple[int, int]]"
x4: TupList[str, str] = f(g([((1, 1), (1, 1))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, int]]"; expected "tuple[tuple[str, str], tuple[str, str]]"
