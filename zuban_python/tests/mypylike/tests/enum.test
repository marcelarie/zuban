[case enum_ignore_deleted]
# Similar to testEnumIgnoreIsDeleted, but additional cases
from enum import Enum
from typing import Literal

class C(Enum):
    _ignore_ = 'X'

    X = 1
    Y = 2

C._ignore_ # E: "Type[C]" has no attribute "_ignore_"
C.Y._ignore_ # E: "C" has no attribute "_ignore_"

c: C
cy: Literal[C.Y]
c._ignore_ # E: "C" has no attribute "_ignore_"
cy._ignore_ # E: "Literal[C.Y]" has no attribute "_ignore_"

[case enum_multi_literal]
from enum import Enum

E = Enum("E", "Fo" "o Bar")

reveal_type(E.Foo)  # N: Revealed type is "Literal[__main__.E.Foo]?"
reveal_type(E.Bar)  # N: Revealed type is "Literal[__main__.E.Bar]?"

[case enum_str_passed]
from enum import Enum
x = "Foo"
E = Enum(x, 'a b') # E: Enum() expects a string literal as the first argument

[case functional_enum_dict_literal_errors]
from enum import Enum
x = "asdf"
E = Enum("E", {x: 1}) # E: Enum() with dict literal requires string literals

[case functional_enum_starred_dict_literal_errors]
from enum import Enum
c = {"x": 1}
E = Enum("E", {**c}) # E: Enum() with dict literal requires string literals

[case functional_enum_with_list_input]
from enum import Enum
def foo() -> list[str]: return []
c: list[str]
E = Enum("E", c) # E: Second argument of Enum() must be string, tuple, list or dict literal for mypy to determine Enum members
E = Enum("E", foo()) # E: Second argument of Enum() must be string, tuple, list or dict literal for mypy to determine Enum members

[case functional_enum_attempt_to_reuse_keys]
# functional cases for testEnumReusedKeys
from enum import Enum
from typing import Literal

E1 = Enum("E1", "A B A")  # E: Attempted to reuse member name "A" in Enum definition "E1"
E2 = Enum("E2", ["A",
                 "A",  # E: Attempted to reuse member name "A" in Enum definition "E2"
                 "B",
                 ])
E3 = Enum("E3", [("A", 1),
                 ("A",  # E: Attempted to reuse member name "A" in Enum definition "E3"
                  2),
                 ("B", 3),
                 ])
E4 = Enum("E4", {"A": 1,
                 "A":  # E: Attempted to reuse member name "A" in Enum definition "E4"
                  2,
                 "B": 3,
                 })
reveal_type(E4.A.value)  # N: Revealed type is "Literal[1]?"
reveal_type(E4.B.value)  # N: Revealed type is "Literal[3]?"

x: Literal["A B A"]
E5 = Enum("E5", x)  # E: Attempted to reuse member name "A" in Enum definition "E5"

[case flag_or_for_member]
from enum import Flag
E = Flag("E", 'x y')
x: E
reveal_type(E.x | E.y)  # N: Revealed type is "__main__.E"
reveal_type(x | E.y)  # N: Revealed type is "__main__.E"
reveal_type(E.x | x)  # N: Revealed type is "__main__.E"
reveal_type(x | x)  # N: Revealed type is "__main__.E"

[case enum_from_final]
# Like testEnumCreatedFromFinalValue, but without Final[str], which makes no sense.
from enum import Enum
from typing_extensions import Final

x: Final = 'ANT BEE CAT DOG'
Animal = Enum('Animal', x)
reveal_type(Animal.ANT)  # N: Revealed type is "Literal[__main__.Animal.ANT]?"
reveal_type(Animal.BEE)  # N: Revealed type is "Literal[__main__.Animal.BEE]?"
reveal_type(Animal.CAT)  # N: Revealed type is "Literal[__main__.Animal.CAT]?"
reveal_type(Animal.DOG)  # N: Revealed type is "Literal[__main__.Animal.DOG]?"

[case enum_formatting_distinct]
import a
import b
x: a.B
y: b.B
x = y  # E: Incompatible types in assignment (expression has type "b.B", variable has type "a.B")
[file a.py]
from enum import Enum
class B(Enum):
    b = 10

[file b.py]
from enum import Enum
class B(Enum):
    b = 10
