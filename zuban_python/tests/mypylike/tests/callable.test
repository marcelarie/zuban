[case callable_cannot_infer_type_var]
from typing import TypeVar
T = TypeVar("T")
x: Callable[[T, T], T]
--zuban-diff x(1, "") # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[U, U], U]")
x(1, "") # E: Cannot infer type argument 1 of -> Callable[[T, T] T]

[case callable_return_from_function_simple]
from typing import Callable, TypeVar, Tuple

T = TypeVar('T')
U = TypeVar('U')

def return_callable1(x: T) -> Callable[[U], Tuple[T, U]]: ...

reveal_type(return_callable1(7)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(return_callable1(7)("")) # N: Revealed type is "tuple[int, str]"

def return_callable2() -> Callable[[U], Tuple[T, U]]: ...

reveal_type(return_callable2())  # N: Revealed type is "def [U, T] (U) -> tuple[T, U]"
reveal_type(return_callable2()(1))  # N: Revealed type is "tuple[<nothing>, int]"

[case callable_return_from_function_simple_with_context]
from typing import Callable, TypeVar, Tuple

T = TypeVar('T')
U = TypeVar('U')

def return_callable1(x: T) -> Callable[[U], Tuple[T, U]]: ...

x: Tuple[int, str] = return_callable1(7)("")
y: Tuple[int, bytes] = return_callable1(7)("") # E: Argument 1 has incompatible type "str"; expected "bytes"
z: Tuple[bytes, str] = return_callable1(7)("") # E: Incompatible types in assignment (expression has type "tuple[int, str]", variable has type "tuple[bytes, str]")
a: Tuple[bytes, bytes] = return_callable1(7)("") # E: Argument 1 has incompatible type "str"; expected "bytes" \
                                                 # E: Incompatible types in assignment (expression has type "tuple[int, bytes]", variable has type "tuple[bytes, bytes]")

def return_callable2() -> Callable[[U], Tuple[T, U]]: ...

[case callable_return_from_method_simple]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable3(self, x: T) -> Callable[[U], Tuple[T, U, V]]: ...

reveal_type(Foo(1.0).return_callable3(7)) # N: Revealed type is "def [U] (U) -> tuple[int, U, float]"
reveal_type(Foo(1.0).return_callable3(7)("")) # N: Revealed type is "tuple[int, str, float]"

[case callable_return_from_method_no_params]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable4(self) -> Callable[[U], Tuple[T, U, V]]: ...

reveal_type(Foo(1.0).return_callable4()) # N: Revealed type is "def [U, T] (U) -> tuple[T, U, float]"
reveal_type(Foo(1.0).return_callable4()("")) # N: Revealed type is "tuple[<nothing>, str, float]"

[case callable_return_from_method_nested_simple]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable5(self, x: T) -> Callable[[U], Callable[[W], Tuple[T, U, V, W]]]: ...

c = Foo(1.0).return_callable5(1)
reveal_type(c) # N: Revealed type is "def [U] (U) -> def [W] (W) -> tuple[int, U, float, W]"
reveal_type(c("")) # N: Revealed type is "def [W] (W) -> tuple[int, str, float, W]"
reveal_type(c("")(b"")) # N: Revealed type is "tuple[int, str, float, bytes]"

[case callable_return_from_method_nested_multiple1]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable6(self, x: T) -> Callable[[U], Tuple[Callable[[W], Tuple[T, U, V, W]],
                                                            Callable[[W], Tuple[T, U, V, W]]
                                                            ]]: ...

c = Foo(1.0).return_callable6(1)
reveal_type(c) # N: Revealed type is "def [U, W] (U) -> tuple[def (W) -> tuple[int, U, float, W], def (W) -> tuple[int, U, float, W]]"
reveal_type(c("")) # N: Revealed type is "tuple[def (<nothing>) -> tuple[int, str, float, <nothing>], def (<nothing>) -> tuple[int, str, float, <nothing>]]"
reveal_type(c("")[0](b"")) # N: Revealed type is "tuple[int, str, float, <nothing>]"
reveal_type(c("")[1](b"")) # N: Revealed type is "tuple[int, str, float, <nothing>]"

[case callable_return_from_method_nested_multiple2]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')
X = TypeVar('X')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable7(self, x: T) -> Callable[[U], Tuple[Callable[[W], Tuple[T, U, V, W]],
                                                            Callable[[X], Tuple[T, U, V, X]]
                                                            ]]: ...
c = Foo(1.0).return_callable7(1)
reveal_type(c) # N: Revealed type is "def [U] (U) -> tuple[def [W] (W) -> tuple[int, U, float, W], def [X] (X) -> tuple[int, U, float, X]]"
reveal_type(c("")) # N: Revealed type is "tuple[def [W] (W) -> tuple[int, str, float, W], def [X] (X) -> tuple[int, str, float, X]]"
reveal_type(c("")[0](b"")) # N: Revealed type is "tuple[int, str, float, bytes]"
reveal_type(c("")[1](b"")) # N: Revealed type is "tuple[int, str, float, bytes]"

[case callable_on_annotation_nested]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_annotation_nested]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_type_comment]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x = None # type: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"
