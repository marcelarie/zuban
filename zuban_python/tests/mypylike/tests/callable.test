[case callable_cannot_infer_type_var]
from typing import TypeVar, Callable
T1 = TypeVar("T1")
x: Callable[[T1, T1], T1]
reveal_type(x(1, "")) # N: Revealed type is "object"

T2 = TypeVar("T2", int, str)
y: Callable[[T2, T2], T2]

y(1, "") # E: Argument 2 has incompatible type "str"; expected "int"

[case callable_return_from_function_simple]
from typing import Callable, TypeVar, Tuple

T = TypeVar('T')
U = TypeVar('U')

def return_callable1(x: T) -> Callable[[U], Tuple[T, U]]: ...

reveal_type(return_callable1(7)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(return_callable1(7)("")) # N: Revealed type is "tuple[int, str]"

def return_callable2() -> Callable[[U], Tuple[T, U]]: ...

reveal_type(return_callable2())  # N: Revealed type is "def [U, T] (U) -> tuple[T, U]"
reveal_type(return_callable2()(1))  # N: Revealed type is "tuple[<nothing>, int]"

[case callable_return_from_function_simple_with_context]
from typing import Callable, TypeVar, Tuple

T = TypeVar('T')
U = TypeVar('U')

def return_callable1(x: T) -> Callable[[U], Tuple[T, U]]: ...

x: Tuple[int, str] = return_callable1(7)("")
y: Tuple[int, bytes] = return_callable1(7)("") # E: Argument 1 has incompatible type "str"; expected "bytes"
z: Tuple[bytes, str] = return_callable1(7)("") # E: Incompatible types in assignment (expression has type "tuple[int, str]", variable has type "tuple[bytes, str]")
a: Tuple[bytes, bytes] = return_callable1(7)("") # E: Argument 1 has incompatible type "str"; expected "bytes" \
                                                 # E: Incompatible types in assignment (expression has type "tuple[int, bytes]", variable has type "tuple[bytes, bytes]")

def return_callable2() -> Callable[[U], Tuple[T, U]]: ...

[case callable_return_from_method_simple]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable3(self, x: T) -> Callable[[U], Tuple[T, U, V]]: ...

reveal_type(Foo(1.0).return_callable3(7)) # N: Revealed type is "def [U] (U) -> tuple[int, U, float]"
reveal_type(Foo(1.0).return_callable3(7)("")) # N: Revealed type is "tuple[int, str, float]"

[case callable_return_from_method_no_params]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable4(self) -> Callable[[U], Tuple[T, U, V]]: ...

reveal_type(Foo(1.0).return_callable4()) # N: Revealed type is "def [U, T] (U) -> tuple[T, U, float]"
reveal_type(Foo(1.0).return_callable4()("")) # N: Revealed type is "tuple[<nothing>, str, float]"

[case callable_return_from_method_nested_simple]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable5(self, x: T) -> Callable[[U], Callable[[W], Tuple[T, U, V, W]]]: ...

c = Foo(1.0).return_callable5(1)
reveal_type(c) # N: Revealed type is "def [U] (U) -> def [W] (W) -> tuple[int, U, float, W]"
reveal_type(c("")) # N: Revealed type is "def [W] (W) -> tuple[int, str, float, W]"
reveal_type(c("")(b"")) # N: Revealed type is "tuple[int, str, float, bytes]"

[case callable_return_from_method_nested_multiple1]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable6(self, x: T) -> Callable[[U], Tuple[Callable[[W], Tuple[T, U, V, W]],
                                                            Callable[[W], Tuple[T, U, V, W]]
                                                            ]]: ...

c = Foo(1.0).return_callable6(1)
reveal_type(c) # N: Revealed type is "def [U, W] (U) -> tuple[def (W) -> tuple[int, U, float, W], def (W) -> tuple[int, U, float, W]]"
reveal_type(c("")) # N: Revealed type is "tuple[def (<nothing>) -> tuple[int, str, float, <nothing>], def (<nothing>) -> tuple[int, str, float, <nothing>]]"
reveal_type(c("")[0](b"")) # N: Revealed type is "tuple[int, str, float, <nothing>]" \
                           # E: Argument 1 has incompatible type "bytes"; expected "<nothing>"
reveal_type(c("")[1](b"")) # N: Revealed type is "tuple[int, str, float, <nothing>]" \
                           # E: Argument 1 has incompatible type "bytes"; expected "<nothing>"

[case callable_return_from_method_nested_multiple2]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')
W = TypeVar('W')
X = TypeVar('X')

class Foo(Generic[V]):
    def __init__(self, foo: V): ...
    def return_callable7(self, x: T) -> Callable[[U], Tuple[Callable[[W], Tuple[T, U, V, W]],
                                                            Callable[[X], Tuple[T, U, V, X]]
                                                            ]]: ...
c = Foo(1.0).return_callable7(1)
reveal_type(c) # N: Revealed type is "def [U] (U) -> tuple[def [W] (W) -> tuple[int, U, float, W], def [X] (X) -> tuple[int, U, float, X]]"
reveal_type(c("")) # N: Revealed type is "tuple[def [W] (W) -> tuple[int, str, float, W], def [X] (X) -> tuple[int, str, float, X]]"
reveal_type(c("")[0](b"")) # N: Revealed type is "tuple[int, str, float, bytes]"
reveal_type(c("")[1](b"")) # N: Revealed type is "tuple[int, str, float, bytes]"

[case callable_on_annotation_nested]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_annotation_nested]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

x: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_type_comment]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x = any # type: Callable[[T], Callable[[U], Tuple[T, U]]]

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"

[case callable_on_type_comment_tuple_without_parentheses]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: Callable[[T], Callable[[U], Tuple[T, U]]], str

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"
reveal_type(y) # N: Revealed type is "str"

[case callable_on_type_comment_tuple_with_parentheses]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: (Callable[[T], Callable[[U], Tuple[T, U]]], str)

reveal_type(x) # N: Revealed type is "def [T] (T) -> def [U] (U) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "def [U] (U) -> tuple[int, U]"
reveal_type(x(1)("")) # N: Revealed type is "tuple[int, str]"
reveal_type(y) # N: Revealed type is "str"

[case callable_on_type_comment_with_unbound]
from typing import Callable, TypeVar, Tuple, Generic, Any

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: Tuple[Callable[[T], Tuple[T, U]], U]

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, <nothing>]"
reveal_type(y) # N: Revealed type is "Any"

[out]
main:7: error: Type variable "__main__.U" is unbound
main:7: note: (Hint: Use "Generic[U]" or "Protocol[U]" base class to bind "U" inside a class)
main:7: note: (Hint: Use "U" in function signature to bind "U" inside a function)

[case callable_on_type_comment_tuple_with_unbound]
from typing import Callable, TypeVar, Tuple, Generic

T = TypeVar('T')
U = TypeVar('U')

any: Any
x, y = any # type: (Callable[[T], Tuple[T, U]], U)

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, <nothing>]"
reveal_type(y) # N: Revealed type is "Any"

[out]
main:7: error: Type variable "__main__.U" is unbound
main:7: note: (Hint: Use "Generic[U]" or "Protocol[U]" base class to bind "U" inside a class)
main:7: note: (Hint: Use "U" in function signature to bind "U" inside a function)

[case callable_on_cast_target]
from typing import Callable, TypeVar, Tuple, cast

T = TypeVar('T')
U = TypeVar('U')

x = cast(Callable[[T], Tuple[T, U]], None)

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, <nothing>]"

[out]

[case callable_on_cast_target_with_unbound]
from typing import Callable, TypeVar, Tuple, cast

T = TypeVar('T')
U = TypeVar('U')

x, y = cast(Tuple[Callable[[T], Tuple[T, U]], U], None)

reveal_type(x) # N: Revealed type is "def [T, U] (T) -> tuple[T, U]"
reveal_type(x(1)) # N: Revealed type is "tuple[int, <nothing>]"
reveal_type(y) # N: Revealed type is "Any"

[out]
main:6: error: Type variable "__main__.U" is unbound
main:6: note: (Hint: Use "Generic[U]" or "Protocol[U]" base class to bind "U" inside a class)
main:6: note: (Hint: Use "U" in function signature to bind "U" inside a function)

[case additional_callable_params_ordering]
from typing import Callable
from mypy_extensions import Arg, DefaultArg, NamedArg
x: Callable[[Arg(int, "blah"), int], int]  # E: Required positional args may not appear after default, named or var args
y: Callable[[DefaultArg(int), int], int]  # E: Required positional args may not appear after default, named or var args
z: Callable[[DefaultArg(int, "foo"), Arg(int, "bar")], int]  # E: Required positional args may not appear after default, named or var args
a: Callable[[NamedArg(int, "foo"), Arg(int, "bar")], int]  # E: Required positional args may not appear after default, named or var args

[case match_args_kwargs_callable]
# flags: --mypy-compatible
def x(*args: int, **kwargs: object): ...
def y(*args: object, **kwargs: int): ...
def z(*args: int, **kwargs: int): ...

def foo(x: int): ...

foo = x # E: Incompatible types in assignment (expression has type "Callable[[VarArg(int), KwArg(object)], Any]", variable has type "Callable[[int], Any]")
foo = y # E: Incompatible types in assignment (expression has type "Callable[[VarArg(object), KwArg(int)], Any]", variable has type "Callable[[int], Any]")
foo = z

[case multiple_lambda_mypy_issue_4226]
from typing import Callable, TypeVar

S = TypeVar('S')
T = TypeVar('T')
U = TypeVar('U')

def comp(g: Callable[[T], U], f: Callable[[S], T]) -> Callable[[S], U]:
    def composed(x: S) -> U:
        return g(f(x))
    return composed

def test(s: str) -> int:
    len_and_inc = comp(lambda i: i + 1, lambda s: len(s))
    x = len_and_inc(s)
    reveal_type(x)
    return x

[case callable_with_keyword_errors]
from mypy_extensions import Arg

def foo(x: int) -> None: ...

bar: Callable[[Arg(int, "x")], None]

foo(1, x=1)  # E: "foo" gets multiple values for keyword argument "x"
foo(1, y=1)  # E: Unexpected keyword argument "y" for "foo"

bar(1, x=1)  # E: function gets multiple values for keyword argument "x"
bar(1, y=1)  # E: Unexpected keyword argument "y"
