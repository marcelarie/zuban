[case reachability_mypy_compatible]
# flags: --mypy-compatible
def foo(x: None) -> None:
    if x is None:
        return
    else:
        1()
        if x:
            reveal_type(x)

[case reachability_no_mypy_compatible]
# flags: --no-mypy-compatible
def foo(x: None, y: int | None) -> None:
    if x is None:
        return
    else:
        1()  # E: "int" not callable
        if y:
            reveal_type(y)  # N: Revealed type is "int"
            reveal_type(x)  # N: Revealed type is "None"

[case narrow_len_yoda_like]
from typing import Any, Union, Tuple

x: Union[Tuple[int, int], Tuple[int, int, int]]
x: Any
if 2 == len(x):
    reveal_type(x) # N: Revealed type is "Tuple[int, int]"
else:
    reveal_type(x) # N: Revealed type is "Tuple[int, int, int]"

[case narrow_unreachable_len1]
# flags: --warn-unreachable --mypy-compatible
from typing import Tuple

x: Tuple[int, ...]
if str():
    if len(x) >= 0:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"
    else:
        reveal_type(x)  # E: Statement is unreachable

if str():
    if len(x) <= 0:
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if 0 >= len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if len(x) <= 1:
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[tuple[int, ...]]]"

if str():
    if 1 >= len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[tuple[int, ...]]]"


[case narrow_unreachable_len2]
# flags: --warn-unreachable --mypy-compatible
from typing import Tuple

x: Tuple[int, ...]

if str():
    if 0 > len(x):
        reveal_type(x)  # E: Statement is unreachable
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"

if str():
    if 1 > len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if 2 > len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[tuple[int, ...]]]"

if str():
    if 0 < len(x):
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[()]"

if str():
    if len(x) < 0:
        reveal_type(x)  # E: Statement is unreachable
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"

[case narrowing_named_tuple_calls1]
# Like testNarrowingLenUnionOfNamedTuples, but with direct calls instead of classes
from typing import NamedTuple, Union

Point2D = NamedTuple("Point2D", [('x', int), ('y', int)])
Point3D = NamedTuple("Point3D", [('x', int), ('y', int), ('z', int)])

x: Union[Point2D, Point3D]
if len(x) == 2:
    reveal_type(x)  # N: Revealed type is "Tuple[builtins.int, builtins.int, fallback=__main__.Point2D]"
else:
    reveal_type(x)  # N: Revealed type is "Tuple[builtins.int, builtins.int, builtins.int, fallback=__main__.Point3D]"

[case narrowing_named_tuple_calls2]
# Like testNarrowingLenUnionOfNamedTuples, but with direct calls instead of classes
from typing import NamedTuple, Union
from collections import namedtuple

Point2D = namedtuple("Point2D", ['x', 'y'])
Point3D = namedtuple("Point3D", ['x', 'y', 'z'])

x: Union[Point2D, Point3D]
if len(x) == 2:
    reveal_type(x)  # N: Revealed type is "Tuple[Any, Any, fallback=__main__.Point2D]"
else:
    reveal_type(x)  # N: Revealed type is "Tuple[Any, Any, Any, fallback=__main__.Point3D]"

[case narrowing_type_of_other_side]
x: Any
if int == type(x):
    reveal_type(x)  # N: Revealed type is "int"
else:
    reveal_type(x)  # N: Revealed type is "Any"

[case avoid_narrowing_of_len_with_big_unpack]
from typing import Tuple
from typing_extensions import Unpack

VarTuple = Tuple[int, Unpack[Tuple[str, ...]]]

x: VarTuple
if len(x) < 30:
    reveal_type(x) # N: Revealed type is "builtins.tuple[builtins.int, Unpack[Tuple[str, ...]]]"
else:
    reveal_type(x) # N: Revealed type is "builtins.tuple[builtins.int, Unpack[Tuple[str, ...]]]"
