[case reachability_mypy_compatible]
# flags: --mypy-compatible
def foo(x: None) -> None:
    if x is None:
        return
    else:
        1()
        if x:
            reveal_type(x)

[case reachability_no_mypy_compatible]
# flags: --no-mypy-compatible
def foo(x: None, y: int | None) -> None:
    if x is None:
        return
    else:
        1()  # E: "int" not callable
        if y:
            reveal_type(y)  # N: Revealed type is "int"
            reveal_type(x)  # N: Revealed type is "None"

[case narrow_len_yoda_like]
from typing import Any, Union, Tuple

x: Union[Tuple[int, int], Tuple[int, int, int]]
if 2 == len(x):
    reveal_type(x) # N: Revealed type is "Tuple[int, int]"
else:
    reveal_type(x) # N: Revealed type is "Tuple[int, int, int]"

[case narrow_unreachable_len1]
# flags: --warn-unreachable --mypy-compatible
from typing import Tuple

x: Tuple[int, ...]
if str():
    if len(x) >= 0:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"
    else:
        reveal_type(x)  # E: Statement is unreachable

if str():
    if len(x) <= 0:
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if 0 >= len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if len(x) <= 1:
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[tuple[int, ...]]]"

if str():
    if 1 >= len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[tuple[int, ...]]]"


[case narrow_unreachable_len2]
# flags: --warn-unreachable --mypy-compatible
from typing import Tuple

x: Tuple[int, ...]

if str():
    if 0 > len(x):
        reveal_type(x)  # E: Statement is unreachable
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"

if str():
    if 1 > len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if 2 > len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[tuple[int, ...]]]"

if str():
    if 0 < len(x):
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[()]"

if str():
    if len(x) < 0:
        reveal_type(x)  # E: Statement is unreachable
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"

[case narrowing_named_tuple_calls1]
# Like testNarrowingLenUnionOfNamedTuples, but with direct calls instead of classes
from typing import NamedTuple, Union

Point2D = NamedTuple("Point2D", [('x', int), ('y', int)])
Point3D = NamedTuple("Point3D", [('x', int), ('y', int), ('z', int)])

x: Union[Point2D, Point3D]
if len(x) == 2:
    reveal_type(x)  # N: Revealed type is "Tuple[builtins.int, builtins.int, fallback=__main__.Point2D]"
else:
    reveal_type(x)  # N: Revealed type is "Tuple[builtins.int, builtins.int, builtins.int, fallback=__main__.Point3D]"

[case narrowing_named_tuple_calls2]
# Like testNarrowingLenUnionOfNamedTuples, but with direct calls instead of classes
from typing import NamedTuple, Union
from collections import namedtuple

Point2D = namedtuple("Point2D", ['x', 'y'])
Point3D = namedtuple("Point3D", ['x', 'y', 'z'])

x: Union[Point2D, Point3D]
if len(x) == 2:
    reveal_type(x)  # N: Revealed type is "Tuple[Any, Any, fallback=__main__.Point2D]"
else:
    reveal_type(x)  # N: Revealed type is "Tuple[Any, Any, Any, fallback=__main__.Point3D]"

[case narrowing_type_of_other_side]
from typing import Any

x: Any
if int == type(x):
    reveal_type(x)  # N: Revealed type is "int"
else:
    reveal_type(x)  # N: Revealed type is "Any"

[case avoid_narrowing_of_len_with_big_unpack]
from typing import Tuple
from typing_extensions import Unpack

VarTuple = Tuple[int, Unpack[Tuple[str, ...]]]

x: VarTuple
if len(x) < 30:
    reveal_type(x) # N: Revealed type is "builtins.tuple[builtins.int, Unpack[Tuple[str, ...]]]"
else:
    reveal_type(x) # N: Revealed type is "builtins.tuple[builtins.int, Unpack[Tuple[str, ...]]]"

[case narrow_attribute_split]
class Foo:
    x: int | None

foo: Foo

foo.x + 1 # E: Unsupported operand types for + ("None" and "int") \
          # N: Left operand is of type "int | None"

if foo.x:
    foo.x + 1

[case narrow_getitem_split]
foo: list[int | None]

foo[0] + 1 # E: Unsupported operand types for + ("None" and "int") \
           # N: Left operand is of type "int | None"

if foo[0]:
    foo[0] + 1
    foo[1] + 1 # E: Unsupported operand types for + ("None" and "int") \
               # N: Left operand is of type "int | None"

[case new_type_intersection]
from typing import NewType
class A: ...
class B: ...
N = NewType('N', A)

def parse_ast(n: N) -> None:
    if isinstance(n, B):
        reveal_type(n)  # N: Revealed type is "<subclass of "N" and "B">"

[case tuple_intersection_with_getitem]
from typing import Tuple
class A:
    def foo(self) -> int: ...
class B: ...

x: Tuple[int, str]

if isinstance(x, A):
    reveal_type(x)  # N: Revealed type is "<subclass of "tuple" and "A">"
    reveal_type(x[0])  # N: Revealed type is "int"
    reveal_type(x[1])  # N: Revealed type is "str"
    x.foo()

a: A
if isinstance(a, B):
    a[0]  # E: Value of type "A" is not indexable

[case intersection_with_getitem_of_classes]
from typing import Tuple
class A:
    def __getitem__(self, other: int) -> str: ...
class B: ...

a: A
b: B
if isinstance(a, B):
    reveal_type(a[0])  # N: Revealed type is "str"

if isinstance(b, A):
    reveal_type(b[0]) # N: Revealed type is "str"

[case issubclass_and_isinstance_with_generics]
from typing import Generic, TypeVar, Type
T = TypeVar('T')

class A(Generic[T]): ...

a1: Type[A[int]]
a2: A[int]

if issubclass(a1, A):
    reveal_type(a1)  # N: Revealed type is "Type[__main__.A[int]]"

if isinstance(a2, A):
    reveal_type(a2) # N: Revealed type is "__main__.A[int]"

[case narrow_frozenset_contains]
d: frozenset[str]
key: str | None
if key in d:
    reveal_type(key)  # N: Revealed type is "str"
else:
    reveal_type(key)  # N: Revealed type is "str | None"

[case narrow_type_type_parent_unions]
from typing import ClassVar, Type, Literal
class Foo:
    baz: ClassVar[Literal[1]] = 1
class Bar:
    baz: ClassVar[Literal[2]] = 2

def foo(x: Type[Foo | Bar]) -> None:
    if x.baz == 1:
        reveal_type(x)  # N: Revealed type is "Type[__main__.Foo]"
    else:
        reveal_type(x)  # N: Revealed type is "Type[__main__.Bar]"

def bar(x: Type[Foo] | Type[Bar]) -> None:
    if x.baz == 2:
        reveal_type(x)  # N: Revealed type is "Type[__main__.Bar]"
    else:
        reveal_type(x)  # N: Revealed type is "Type[__main__.Foo]"

[case try_stmt_else_narrowing1]
class A: ...
class B(A): ...
a: A = A()
try:
    a = B()
except Exception:
    reveal_type(a)  # N: Revealed type is "__main__.A"
else:
    reveal_type(a)  # N: Revealed type is "__main__.B"
finally:
    reveal_type(a)  # N: Revealed type is "__main__.A"

[case try_stmt_else_narrowing2]
class A: ...
class B: ...
class C: ...
a: A | B | C
a = A()
try:
    a = B()
except Exception:
    reveal_type(a)  # N: Revealed type is "__main__.A | __main__.B"
else:
    reveal_type(a)  # N: Revealed type is "__main__.B"
finally:
    reveal_type(a)  # N: Revealed type is "__main__.A | __main__.B"

[case try_stmt_else_unreachable]
# flags: --warn-unreachable
try:
    raise NotImplementedError
except Exception:
    1
else:
    1  # E: Statement is unreachable
finally:
    1

[case try_multiple_excepts_narrowing]
# flags: --warn-unreachable
class A: ...
class B(A): ...

x: A = A()
y: A = A()
x = B()
y = B()

try:
    x = A()
    y = A()
except ValueError:
    pass
except TypeError:
    pass
reveal_type(x)  # N: Revealed type is "__main__.A"
reveal_type(y)  # N: Revealed type is "__main__.A"

[case try_walrus_widening]
class A: ...
class B: ...
class C: ...
a: A | B | C
b: A | B | C
c: A | B | C
d: A | B | C
a = A()
b = A()
c = A()
d = A()

try:
    if (a := B()) and bool():
        pass
    if bool() and (b := B()):
        pass
    if (c := B()):
        pass
    (d := B())
except ValueError:
    pass
else:
    a = A()
    b = A()
    c = A()
    d = A()
reveal_type(a)  # N: Revealed type is "__main__.A | __main__.B"
reveal_type(b)  # N: Revealed type is "__main__.A | __main__.B"
reveal_type(c)  # N: Revealed type is "__main__.A | __main__.B"
reveal_type(d)  # N: Revealed type is "__main__.A | __main__.B"

[case if_widening_statement1]
# flags: --warn-unreachable
class A: ...
class B(A): ...
class C(B): ...

x: A = A()
x = C()

if bool():
    x = B()

reveal_type(x)  # N: Revealed type is "__main__.B"

[case if_widening_statement2]
# flags: --warn-unreachable
class A: ...
class B: ...
class C: ...

x: A | B | C = A()
x = A()

if bool():
    if bool():
        x = B()

    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    if bool():
        x = C()
reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B | __main__.C"

[case unreachable_for_simple_stmt_but_some_simple_stmts_are_ok]
# flags: --warn-unreachable

a: str | None
a = ""
if a is None:
    raise NotImplementedError; \
        bool()  # E: Statement is unreachable

[case walrus_in_conjunction]
class A: ...
class B: ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) and y == 1:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if y == 1 and (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case walrus_in_disjunction]
class A: ...
class B: ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) or y == 1:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if y == 1 or (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B | __main__.A"

[case walrus_isinstance_conjunction_joining]
class A: ...
class B: ...
class BB(B): ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) and isinstance(x, BB):
        reveal_type(x)  # N: Revealed type is "__main__.BB"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if isinstance(x, BB) and (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case walrus_isinstance_disjunction_joining]
class A: ...
class B: ...
class BB(B): ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) or isinstance(x, BB):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if isinstance(x, BB) or (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

[case multi_while_break_widening]
class A: ...
class B: ...
class C: ...

def foo(x: A | B | C) -> None:
    x = A()
    while bool():
        if bool():
            x = B()
            break
        if bool():
            x = C()
            break
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B | __main__.C"

def bar(x: A | B | C) -> None:
    x = A()
    while True:
        if bool():
            x = B()
            break
        if bool():
            x = C()
            break
    reveal_type(x)  # N: Revealed type is "__main__.B | __main__.C"

[case while_break_widening2]
class A: ...
class B: ...
class C: ...

def foo(x: A | B | C) -> None:
    x = A()
    while bool():
        if bool():
            break
        x = B()
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
