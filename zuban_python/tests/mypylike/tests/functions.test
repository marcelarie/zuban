[case function_subtyping_of_keyword_params]
# flags: --mypy-compatible
def f(*, x: int, y: str) -> None: pass
def g(x: int, y: str) -> None: pass
def h(x: int, y: str = "") -> None: pass
def i(x: int, y: int = 3) -> None: pass
def j(y: str, x: int = 3) -> None: pass
f = g
f = h
f = i # E: Incompatible types in assignment (expression has type "Callable[[int, int], None]", variable has type "Callable[[NamedArg(int, 'x'), NamedArg(str, 'y')], None]")
f = j

[case subtyping_of_kwargs_with_defaults]
class A:
    def a(self, **kwargs: int): ...
class B(A):
    def a(self, *, x: str = "", **kwargs: int): ...  # E: Signature of "a" incompatible with supertype "A" \
                                                     # N:      Superclass: \
                                                     # N:          def a(self, **kwargs: int) -> Any \
                                                     # N:      Subclass: \
                                                     # N:          def a(self, *, x: str = ..., **kwargs: int) -> Any
class C(A):
    def a(self, *, x: int = 1, **kwargs: int): ...

[case infer_unannotated_star_args]
def foo(*args, **kwargs) -> None:
    reveal_type(args)  # N: Revealed type is "tuple[Any, ...]"
    reveal_type(kwargs)  # N: Revealed type is "dict[str, Any]"

[case staticmethod_unannotated_types]
class Foo:
    @staticmethod
    def foo(x, y) -> None:
        reveal_type(x)  # N: Revealed type is "Any"
        reveal_type(y)  # N: Revealed type is "Any"

[case global_with_late_type_defs]
# Like testGlobalWithoutInitialization, but without type comments
from typing import List

def foo1() -> None:
    global bar1  # E: Name "bar1" is not defined
    bar1: List[str] = []  # E: Name "bar1" already defined on line 5
    reveal_type(bar1)  # N: Revealed type is "Any"

def foo2():
    global bar2
    bar2: List[str] = []  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs

[case assigning_in_unannotated_funcs_should_not_generate_errors]
def foo():
    [1][1()] = 1
    [1][1()].x = 1
    str(1()).x = 1
    (1().x, b) = 1, 1
    (1().x, c) = 1, 1  # type: (int, int)  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs

[case union_iter_star_unpacking]
from typing import TypeVar
S = TypeVar("S")
T = TypeVar("T")
U = TypeVar("U")
def bar(x: T, y: U) -> tuple[T, U]: ...
def baz(x: T, y: U, z: S) -> tuple[T, U, S]: ...

def foo(x: tuple[int, str] | list[bytes]) -> None:
    reveal_type(bar(*x))  # N: Revealed type is "tuple[int | bytes, str | bytes]"
    reveal_type(baz(*x))  # E: Missing positional argument "z" in call to "baz" \
                          # N: Revealed type is "tuple[int | bytes, str | bytes, Never]"

[case avoid_wrong_inference_for_overload_when_generic]
from typing import Callable, TypeVar, overload
T = TypeVar("T")

@overload
def over(x: None) -> None: ...
@overload
def over(x: int) -> int: ...
def over(x: object) -> int | None: ...

def foo(x: Callable[[T], T], y: T): ...
def bar(x: Callable[[T], T], y: list[T]): ...

foo(over, 1)
foo(over, None)

bar(over, [1])
bar(over, [None])

[case type_var_constraint_with_any_input]
from typing import TypeVar, Any
T = TypeVar("T", int, str)

def f(x: T) -> T: ...

def foo(x: int | Any) -> None:
    reveal_type(f(x))  # N: Revealed type is "int"

[case arg_after_kwargs_normal]
def foo1(x: int, y: int) -> None: ...
def foo2(x: str, y: int) -> None: ...

def bar(**kwargs: int) -> None:
    foo1(**kwargs, x=1)
    foo2(**kwargs, x="")
    foo2(**kwargs)  # E: Argument 1 to "foo2" has incompatible type "**dict[str, int]"; expected "str"

    foo1(**kwargs, y=1)

def baz(**kwargs: str) -> None:
    foo2(**kwargs, y=1)
    foo2(**kwargs, y="")  # E: Argument "y" to "foo2" has incompatible type "str"; expected "int"

[case arg_after_kwargs_keyword_only]
def foo1(*, x: int, y: int) -> None: ...
def foo2(*, x: str, y: int) -> None: ...

def bar(**kwargs: int) -> None:
    foo1(**kwargs, x=1)
    foo2(**kwargs, x="")
    foo2(**kwargs)  # E: Argument 1 to "foo2" has incompatible type "**dict[str, int]"; expected "str"

    foo1(**kwargs, y=1)

def baz(**kwargs: str) -> None:
    foo2(**kwargs, y=1)
    foo2(**kwargs, y="")  # E: Argument "y" to "foo2" has incompatible type "str"; expected "int"

[case simple_type_var_getitem_and_execute]
from typing import TypeVar
T = TypeVar("T")
def foo(x: T, y: type[T]) -> None:
    x[1]  # E: Value of type "T" is not indexable
    x()  # E: "T" not callable

    y[1]  # E: Type application is only supported for generic classes
    y()  # E: "T" not callable

[case param_spec_kwargs_getitem]
from typing import ParamSpec, Callable
P = ParamSpec("P")
def foo(x: Callable[P, int], *args: P.args, **kwargs: P.kwargs) -> None:
    args["x"]  # E: No overload variant of "__getitem__" of "tuple" matches argument type "str" \
               # N: Possible overload variants: \
               # N:     def __getitem__(self, SupportsIndex, /) -> object \
               # N:     def __getitem__(self, slice, /) -> tuple[object, ...]
    args[1]
    kwargs["x"]
    kwargs[1]  # E: Invalid index type "int" for "dict[str, object]"; expected type "str"

[case with_unpack_arg_vs_arbitary_len_param]
def foo(*args: int): ...

def f(x: tuple[int, *tuple[int, ...]],
      y: tuple[int, *tuple[str, ...]],
      z: tuple[str, *tuple[int, ...]]):
    foo(*x)
    foo(*y)  # E: Argument 1 to "foo" has incompatible type "*tuple[Unpack[Tuple[str, ...]]]"; expected "int"
    foo(*z)  # E: Argument 1 to "foo" has incompatible type "*tuple[str, Unpack[Tuple[int, ...]]]"; expected "int"

[case param_spec_matching_with_unpack]
from typing import ParamSpec, Generic, Callable
P = ParamSpec('P')

def foo(*args: P.args, **kwargs: P.kwargs) -> Callable[P, None]: ...

def f(with_unpack: tuple[str, *tuple[str, ...]],
      arbitrary_len: tuple[int, ...],
      dct: dict[str, int],
      *args: P.args,
      **kwargs: P.kwargs):
    reveal_type(foo(*with_unpack))  # N: Revealed type is "def (str, *Unpack[Tuple[str, ...]])"
    reveal_type(foo(*with_unpack, 1))  # N: Revealed type is "def (str, *Unpack[tuple[Unpack[Tuple[str, ...]], Literal[1]?]])"
    reveal_type(foo(*with_unpack, *with_unpack))  # N: Revealed type is "Never"
    reveal_type(foo(*with_unpack, *arbitrary_len))  # N: Revealed type is "Never"
    reveal_type(foo(*with_unpack, *args, **kwargs))  # N: Revealed type is "Never"
    reveal_type(foo(1, *args, **kwargs))  # N: Revealed type is "def (Literal[1]?, *P.args, **P.kwargs)"
    reveal_type(foo(*with_unpack, **dct))  # N: Revealed type is "def (str, *Unpack[Tuple[str, ...]], **int)"

[case type_var_tuple_context_from_func]
from typing import TypeVarTuple, Generic
Ts = TypeVarTuple('Ts')

class A(Generic[*Ts]):
    def f(self, *a: *Ts) -> None: pass

a: A[int, str]

a.f(1) # E: Argument 1 to "f" of "A" has incompatible type "tuple[int]"; expected "tuple[int, str]"
a.f(2, '')

x: A[list[int]]
-- TODO x.f([""]) # E: Argument 1 to "f" of "A" has incompatible type "tuple[list[str]]"; expected "tuple[list[int]]"
-- TODO x.f([])

[case param_spec_context_from_func]
from typing import ParamSpec, Generic, Callable, Any
P = ParamSpec('P')

class A(Generic[P]):
    def f(self, x: Callable[P, Any]) -> None: pass
    def g(self, *args: P.args, **kwargs: P.kwargs) -> None: pass

a: A[int, str]

def f(x: int) -> None: ...
def g(x: int, y: str) -> None: ...
a.f(f) # E: Argument 1 to "f" of "A" has incompatible type "tuple[int]"; expected "tuple[int, str]"
a.f(g)

a.g(1)  # E: Too few arguments for "g" of "A"
a.g(1, "")

x: A[list[int]]
x.f(lambda y: reveal_type(y))  # N: Revealed type is "list[int]"

x.g([])
x.g([1])
x.g([2])
