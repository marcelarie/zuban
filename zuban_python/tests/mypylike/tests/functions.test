[case function_subtyping_of_keyword_params]
# flags: --mypy-compatible
def f(*, x: int, y: str) -> None: pass
def g(x: int, y: str) -> None: pass
def h(x: int, y: str = "") -> None: pass
def i(x: int, y: int = 3) -> None: pass
def j(y: str, x: int = 3) -> None: pass
f = g
f = h
f = i # E: Incompatible types in assignment (expression has type "Callable[[int, int], None]", variable has type "Callable[[NamedArg(int, 'x'), NamedArg(str, 'y')], None]")
f = j

[case infer_unannotated_star_args]
def foo(*args, **kwargs) -> None:
    reveal_type(args)  # N: Revealed type is "tuple[Any, ...]"
    reveal_type(kwargs)  # N: Revealed type is "dict[str, Any]"

[case staticmethod_unannotated_types]
class Foo:
    @staticmethod
    def foo(x, y) -> None:
        reveal_type(x)  # N: Revealed type is "Any"
        reveal_type(y)  # N: Revealed type is "Any"

[case global_with_late_type_defs]
# Like testGlobalWithoutInitialization, but without type comments
from typing import List

def foo1() -> None:
    global bar1  # E: Name "bar1" is not defined
    bar1: List[str] = []  # E: Name "bar1" already defined on line 5
    reveal_type(bar1)  # N: Revealed type is "Any"

def foo2():
    global bar2
    bar2: List[str] = []  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs

[case assigning_in_unannotated_funcs_should_not_generate_errors]
def foo():
    [1][1()] = 1
    [1][1()].x = 1
    str(1()).x = 1
    (1().x, b) = 1, 1
    (1().x, c) = 1, 1  # type: (int, int)  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
