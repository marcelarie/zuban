[case duplicate_base_class_of_tuple]

class A(tuple, tuple): ...  # E: Duplicate base class "tuple"
class B(tuple[int, str], tuple): ...  # E: Duplicate base class "tuple"
class C(tuple, tuple[int, ...]): ...  # E: Duplicate base class "tuple"
class D(tuple[str], tuple[int, ...]): ...  # E: Duplicate base class "tuple"

class X(tuple[str, int]): ...
class Y(tuple[str, ...]): ...
class Z(tuple): ...

[case duplicate_base_class_of_type]

class A(type, type): ...  # E: Duplicate base class "type"
class B(type[int], type): ...  # E: Invalid base class "type[int]"
class C(type, type[int]): ...  # E: Invalid base class "type[int]"
class D(type[str], type[int]): ...  # E: Invalid base class "type[str]" # E: Invalid base class "type[int]"

class X(type): ...

[case base_class_of_type]
from typing import Type

class A(Type[int]): ...  # E: Invalid base class "Type[int]"
class B(type[int]): ...  # E: Invalid base class "type[int]"
class C(Type): ...
class D(type): ...

[case duplicate_base_class_of_callable]
from typing import Callable

class A(Callable, Callable): ...  # E: Duplicate base class "Callable"
class B(Callable[[], int], Callable): ...  # E: Duplicate base class "Callable"
class C(Callable, Callable[..., str]): ...  # E: Duplicate base class "Callable"
class D(Callable[..., str], Callable[..., str]): ...  # E: Duplicate base class "Callable"

class X(Callable[[str], int]): ...
class Y(Callable[..., int], tuple): ...
class Z(Callable): ...

[case function_as_invalid_base_class]
def untyped(): ...
def typed() -> None: ...
class A(abs): ...  # E: Invalid base class "abs"
class B(untyped): ...  # E: Invalid base class "untyped"
class C(typed): ...  # E: Invalid base class "typed"

[case generic_metaclasses_are_invalid_according_to_mypy]
from typing import Generic, TypeVar

T = TypeVar("T")

class Meta(type, Generic[T]):
    def f(cls) -> T: ...

class A(metaclass=Meta[int]): ...  # E: Invalid metaclass "Meta[int]"

[case metaclass_inheritance]
class MyMeta1(type): ...
class MyMeta2(type): ...
class MyMeta3(MyMeta1, MyMeta2): ...
class A(metaclass=MyMeta1): ...
class B(metaclass=MyMeta2): ...
class C(metaclass=MyMeta3): ...

class Try1(A, B): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try2(B, A): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try3(C, A): ...
class Try4(A, C): ...

[case kwargs_base_class]
from typing import Type
foo: dict[str, Type[Any]]

class Bar(**foo): ...  # E: Invalid base class "**foo"

[case staticmethod_and_classmethod]
# This is tested in testClassMethodAndStaticMethod, but only one side, so test
# both here.
class C:
  @classmethod  # E: Cannot have both classmethod and staticmethod
  @staticmethod
  def foo(cls) -> None: pass

  @staticmethod  # E: Cannot have both classmethod and staticmethod
  @classmethod
  def bar(cls) -> None: pass

[case overloaded_property_not_possible]
# There's also testOverloadedProperty, but it's not complete
from typing import overload
class A:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass

class B:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property
    def f(self) -> int: pass

reveal_type(A().f)  # N: Revealed type is "Any"
reveal_type(B().f)  # N: Revealed type is "Any"

[case invalid_args_for_property]
# Similar to testInvalidArgCountForProperty, but a few more cases
from typing import Callable

def any(f: Callable[[Any], int]) -> Callable[..., int]: ...

class A:
    @property
    @any
    def f(self) -> int: pass

[case property_generic_access]
# Make sure this is tested
from typing import Callable, TypeVar, Generic

T = TypeVar("T")

class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x

    @property
    def f(self) -> T: self.x

x: A[int]

reveal_type(x.f)  # N: Revealed type is "int"

reveal_type(A("").f)  # N: Revealed type is "str"

[case super_with_explicit_self]
# There's testSuperWithGenericSelf, but nothing with explict Self arguments
# AFAIK
from typing import Self

class B:
    def f(self) -> float: pass

class C(B):
    def f(self) -> int: pass

    def g(self: Self) -> Self:
        reveal_type(super(C, self).f) # N: Revealed type is "def () -> builtins.float"
        return self

[case class_var_in_method_annotation]
class Foo:
    def method1(self, x: ClassVar) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method2(self, x: ClassVar[int]) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method3(self) -> ClassVar: ...  # E: ClassVar can only be used for assignments in class body
    def method4(self) -> ClassVar[int]: ...  # E: ClassVar can only be used for assignments in class body

[case self_callable]
class Foo:
    def __init__(self) -> None:
        o: Callable[[], Callable[[Foo, int], None]]
        self.foo: Callable[[Foo, int], str]
        self.bar = self.foo
        self.bla = o()

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (__main__.Foo, int)"
Foo.foo  # E: "Type[Foo]" has no attribute "foo"

[case callable_on_class_with_classvar]
class Foo:
    o: ClassVar[Callable[[], Callable[[Foo, int], None]]]
    foo: ClassVar[Callable[[Foo, int], str]]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_on_class_without_classvar]
class Foo:
    o: Callable[[], Callable[[Foo, int], None]]
    foo: Callable[[Foo, int], str]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case generic_descriptor]
from typing import Generic, TypeVar
T = TypeVar("T")

class Descriptor(Generic[T]):
    def __get__(self, instance, cls) -> T:
        raise NotImplementedError

class Foo(Generic[T]):
    def __init__(self, x: T):
        raise NotImplementedError

    d1: Descriptor[T]
    d2 = Descriptor[T]()

reveal_type(Foo(1).d1)  # N: Revealed type is "int"
reveal_type(Foo(1).d2)  # N: Revealed type is "int"
reveal_type(Foo[int].d1)  # E: Access to generic instance variables via class is ambiguous \
                          # N: Revealed type is "int"
reveal_type(Foo[int].d2)  # N: Revealed type is "int"
