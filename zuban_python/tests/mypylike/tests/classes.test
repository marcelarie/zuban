[case duplicate_base_class_of_tuple]

class A(tuple, tuple): ...  # E: Duplicate base class "tuple"
class B(tuple[int, str], tuple): ...  # E: Duplicate base class "tuple"
class C(tuple, tuple[int, ...]): ...  # E: Duplicate base class "tuple"
class D(tuple[str], tuple[int, ...]): ...  # E: Duplicate base class "tuple"

class X(tuple[str, int]): ...
class Y(tuple[str, ...]): ...
class Z(tuple): ...

[case duplicate_base_class_of_type]

class A(type, type): ...  # E: Duplicate base class "type"
class B(type[int], type): ...  # E: Invalid base class "type[int]"
class C(type, type[int]): ...  # E: Invalid base class "type[int]"
class D(type[str], type[int]): ...  # E: Invalid base class "type[str]" # E: Invalid base class "type[int]"

class X(type): ...

[case base_class_of_type]
from typing import Type

class A(Type[int]): ...  # E: Invalid base class "Type[int]"
class B(type[int]): ...  # E: Invalid base class "type[int]"
class C(Type): ...
class D(type): ...

[case duplicate_base_class_of_callable]
from typing import Callable

class A(Callable, Callable): ...  # E: Duplicate base class "Callable"
class B(Callable[[], int], Callable): ...  # E: Duplicate base class "Callable"
class C(Callable, Callable[..., str]): ...  # E: Duplicate base class "Callable"
class D(Callable[..., str], Callable[..., str]): ...  # E: Duplicate base class "Callable"

class X(Callable[[str], int]): ...
class Y(Callable[..., int], tuple): ...
class Z(Callable): ...

[case function_as_invalid_base_class]
def untyped(): ...
def typed() -> None: ...
class A(abs): ...  # E: Invalid base class "abs"
class B(untyped): ...  # E: Invalid base class "untyped"
class C(typed): ...  # E: Invalid base class "typed"

[case generic_metaclasses_are_invalid_according_to_mypy]
from typing import Generic, TypeVar

T = TypeVar("T")

class Meta(type, Generic[T]):
    def f(cls) -> T: ...

class A(metaclass=Meta[int]): ...  # E: Dynamic metaclass not supported for "A"
