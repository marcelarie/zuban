[case duplicate_base_class_of_tuple]

class A(tuple, tuple): ...  # E: Duplicate base class "tuple"
class B(tuple[int, str], tuple): ...  # E: Duplicate base class "tuple"
class C(tuple, tuple[int, ...]): ...  # E: Duplicate base class "tuple"
class D(tuple[str], tuple[int, ...]): ...  # E: Duplicate base class "tuple"

class X(tuple[str, int]): ...
class Y(tuple[str, ...]): ...
class Z(tuple): ...

[case duplicate_base_class_of_type]

class A(type, type): ...  # E: Duplicate base class "type"
class B(type[int], type): ...  # E: Invalid base class "type[int]"
class C(type, type[int]): ...  # E: Invalid base class "type[int]"
class D(type[str], type[int]): ...  # E: Invalid base class "type[str]" # E: Invalid base class "type[int]"

class X(type): ...

[case base_class_of_type]
from typing import Type

class A(Type[int]): ...  # E: Invalid base class "Type[int]"
class B(type[int]): ...  # E: Invalid base class "type[int]"
class C(Type): ...
class D(type): ...

[case function_as_invalid_base_class]
def untyped(): ...
def typed() -> None: ...
class A(abs): ...  # E: Invalid base class "abs"
class B(untyped): ...  # E: Invalid base class "untyped"
class C(typed): ...  # E: Invalid base class "typed"

[case generic_metaclasses_are_invalid_according_to_mypy]
from typing import Generic, TypeVar

T = TypeVar("T")

class Meta(type, Generic[T]):
    def f(cls) -> T: ...

class A(metaclass=Meta[int]): ...  # E: Invalid metaclass "Meta[int]"

[case metaclass_inheritance]
class MyMeta1(type): ...
class MyMeta2(type): ...
class MyMeta3(MyMeta1, MyMeta2): ...
class A(metaclass=MyMeta1): ...
class B(metaclass=MyMeta2): ...
class C(metaclass=MyMeta3): ...

class Try1(A, B): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try2(B, A): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try3(C, A): ...
class Try4(A, C): ...

[case self_type_in_metaclass]
# Similar to testTypingSelfMetaClassDisabled, but with additional tests
from typing import Self, Any

class Meta(type):
    def __new__(cls, *args: Any) -> Self:  # E: Self type cannot be used in a metaclass
        return 1
    def meth(cls) -> Self: ...  # E: Self type cannot be used in a metaclass
    def other(cls, next: Self) -> None: ...  # E: Self type cannot be used in a metaclass
    x: Self  # E: Self type cannot be used in a metaclass

class Bar(metaclass=Meta): ...

reveal_type(Bar.x)  # N: Revealed type is "Any"
reveal_type(Bar.meth)  # N: Revealed type is "def () -> Any"
reveal_type(Bar.other)  # N: Revealed type is "def (next: Any)"

[case metaclass_descriptor]
from typing import TypeVar, Tuple
T = TypeVar("T")
S = TypeVar("S")
class Descriptor():
    def __get__(self, instance: S, cls: T) -> Tuple[S, T]:
        return instance, cls

class Meta(type):
    a = Descriptor()


class A(metaclass=Meta): ...

# This differs in Mypy and CPython:
# >>> A.a
# (<class '__main__.A'>, <class '__main__.Meta'>)
# However in mypy it's tuple[None, Type[x2.A@1369]]
reveal_type(A.a)  # N: Revealed type is "tuple[Type[__main__.A], Type[__main__.Meta]]"
reveal_type(Meta(A()).a)  # N: Revealed type is "tuple[__main__.Meta, Type[__main__.Meta]]"

[case metaclass_iter_on_type_bound]
# Similar to testInferringLvarTypesUnpackedFromIterableClassObject, but with
# bounds
from typing import Iterator, Type, TypeVar, Union, overload
class Meta(type):
    def __iter__(cls) -> Iterator[int]: raise NotImplementedError

class Meta2(type):
    def __iter__(cls) -> Iterator[str]: raise NotImplementedError

class Meta3(type): ...

class Foo(metaclass=Meta): ...
class Bar(metaclass=Meta2): ...
class Baz(metaclass=Meta3): ...
class Spam: ...

T = TypeVar("T", bound=Foo)
def check_bound1(x: Type[T]) -> None:
    for var in x:
        reveal_type(var)  # N: Revealed type is "builtins.int"

U = TypeVar("U", bound=Foo | Bar)
def check_bound2(x: Type[U]) -> None:
    for var in x:
        reveal_type(var)  # N: Revealed type is "builtins.int | builtins.str"

V = TypeVar("V", bound=Bar | Baz | Spam)
def check_bound3(x: Type[V]) -> None:
    for var in x:  # E: "Type[Baz]" object is not iterable \
                   # E: "Type[Spam]" object is not iterable
        reveal_type(var)  # N: Revealed type is "builtins.str | Any"

[case kwargs_base_class]
from typing import Type, Any
foo: dict[str, Type[Any]]

class Bar(**foo): ...  # E: Invalid base class "**foo"

[case staticmethod_and_classmethod]
# This is tested in testClassMethodAndStaticMethod, but only one side, so test
# both here.
class C:
  @classmethod  # E: Cannot have both classmethod and staticmethod
  @staticmethod
  def foo(cls) -> None: pass

  @staticmethod  # E: Cannot have both classmethod and staticmethod
  @classmethod
  def bar(cls) -> None: pass

[case overloaded_property_not_possible]
# flags: --mypy-compatible
# There's also testOverloadedProperty, but it's not complete
from typing import overload
class A:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property # E: Name "f" already defined on line 5
    @overload
    def f(self) -> int: pass

class B:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property  # E: Name "f" already defined on line 13
    @overload
    def f(self) -> int: pass
    @property  # E: Name "f" already defined on line 13
    def f(self) -> int: pass

reveal_type(A().f)  # N: Revealed type is "Any"
reveal_type(B().f)  # N: Revealed type is "Any"

[case invalid_args_for_property]
# Similar to testInvalidArgCountForProperty, but a few more cases
from typing import Callable, Any

def any(f: Callable[[Any], int]) -> Callable[..., int]: ...

class A:
    @property
    @any
    def f(self) -> int: pass

[case property_generic_access]
# Make sure this is tested
from typing import Callable, TypeVar, Generic

T = TypeVar("T")

class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x

    @property
    def f(self) -> T: return self.x

x: A[int]

reveal_type(x.f)  # N: Revealed type is "int"

reveal_type(A("").f)  # N: Revealed type is "str"

[case super_with_explicit_self]
# There's testSuperWithGenericSelf, but nothing with explict Self arguments
# AFAIK
from typing import Self

class B:
    def f(self) -> float: pass

class C(B):
    def f(self) -> int: pass

    def g(self: Self) -> Self:
        reveal_type(super(C, self).f) # N: Revealed type is "def () -> builtins.float"
        return self

[case super_self_lookup]
class Bar:
    def f1(self) -> None:
        self.bar = 1
class Foo(Bar):
    def f2(self) -> None:
        self.foo = 1
        reveal_type(super().foo)  # E: "foo" undefined in superclass # N: Revealed type is "Any"
        reveal_type(super().bar)  # E: "bar" undefined in superclass # N: Revealed type is "Any"

[case class_var_in_method_annotation]
from typing import ClassVar

class Foo:
    def method1(self, x: ClassVar) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method2(self, x: ClassVar[int]) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method3(self) -> ClassVar: ...  # E: ClassVar can only be used for assignments in class body
    def method4(self) -> ClassVar[int]: ...  # E: ClassVar can only be used for assignments in class body

[case self_callable]
from typing import Callable
class Foo:
    def __init__(self) -> None:
        o: Callable[[], Callable[[Foo, int], None]]
        self.foo: Callable[[Foo, int], str]
        self.bar = self.foo
        self.bla = o()

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (__main__.Foo, int)"
Foo.foo  # E: "Type[Foo]" has no attribute "foo"

[case callable_on_class_with_classvar]
from typing import Callable, ClassVar
class Foo:
    o: ClassVar[Callable[[], Callable[[Foo, int], None]]]
    foo: ClassVar[Callable[[Foo, int], str]]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_on_class_without_classvar]
from typing import Callable
class Foo:
    o: Callable[[], Callable[[Foo, int], None]]
    foo: Callable[[Foo, int], str]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_mapped_via_class1]
from typing import Callable, ClassVar
class Foo:
    foo: ClassVar[Callable[[Foo, Bar, int], None]]
class Bar:
    bar = Foo().foo

reveal_type(Bar.bar)  # N: Revealed type is "def (__main__.Bar, int)"
reveal_type(Bar().bar)  # N: Revealed type is "def (int)"

[case callable_mapped_via_class2]
class Foo:
    def foo(self, bar: Bar, other: int) -> None: ...
class Bar:
    bar = Foo().foo

reveal_type(Bar.bar)  # N: Revealed type is "def (bar: __main__.Bar, other: int)"
# This might not work in Mypy. As of 47480a5dc, this leads to the same type,
# but also an error:
# Invalid self argument "Bar" to attribute function "bar" with type "Callable[[Bar, int], None]"
reveal_type(Bar().bar)  # N: Revealed type is "def (other: int)"

[case generic_descriptor]
from typing import Generic, TypeVar
T = TypeVar("T")

class Descriptor(Generic[T]):
    def __get__(self, instance, cls) -> T:
        raise NotImplementedError

class Foo(Generic[T]):
    def __init__(self, x: T):
        raise NotImplementedError

    d1: Descriptor[T]
    d2 = Descriptor[T]()

reveal_type(Foo(1).d1)  # N: Revealed type is "int"
reveal_type(Foo(1).d2)  # N: Revealed type is "int"
reveal_type(Foo[int].d1)  # E: Access to generic instance variables via class is ambiguous \
                          # N: Revealed type is "int"
reveal_type(Foo[int].d2)  # N: Revealed type is "int"

[case descriptor_with_wrong_annotations]
class Descriptor():
    def __get__(self, instance: None, cls: None) -> int:
        raise NotImplementedError

class Foo:
    d1: Descriptor
    d2 = Descriptor()

x: int
x = Foo().d1  # E: Argument 1 to "__get__" of "Descriptor" has incompatible type "Foo"; expected "None" \
              # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"
x = Foo().d2  # E: Argument 1 to "__get__" of "Descriptor" has incompatible type "Foo"; expected "None" \
              # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"
x = Foo.d1  # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"
x = Foo.d2  # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "Type[Foo]"; expected "None"

[case instance_self___call__]
def call(x: int) -> int:
    return 1
class Foo:
    def __init__(self) -> None:
        self.__call__ = call

Foo()()  # E: "Foo" not callable

[case class_context_super_class]
from typing import TypeVar, Generic

T = TypeVar('T')

class I(Generic[T]): ...
class A(I[list[T]]): ...

x = A() # type: I[list[int]]

a_object = A() # type: A[object]
y = a_object # type: I[int] # E: Incompatible types in assignment (expression has type "A[object]", variable has t>

z = A() # type: I[int]

[case cannot_determine_mro]
# Similar to testCannotDetermineMro, but a few more tests
class A: pass
class B(A): pass
class D(A, B): pass # E: Cannot determine consistent method resolution order (MRO) for "D"

class A2(A): pass
class B2(B): pass
class D2(A2, B2): pass  # This is fine

[case classes_with__and__]
# int() supports __and__, but int should not.
int & int  # E: Unsupported left operand type for & ("Type[int]")
int() & int()

[case typed_dict_with_normal_bases]
# Adapted from testCannotCreateTypedDictWithClassOtherBases to test an additional case
from typing import TypedDict

class A: pass

class X(TypedDict, A): # E: All bases of a new TypedDict must be TypedDict types
    x: int
class Y(A, TypedDict): # E: All bases of a new TypedDict must be TypedDict types
    x: int

[case liskov_inheritance_with_changed_type_vars]
from typing import TypeVar, Generic, List
T = TypeVar('T')

class A(Generic[T]):
    def x(self, t: T) -> None: ...
class B(A[List[T]]):
    def x(self, t: T) -> None: ...  # E: Argument 1 of "x" is incompatible with supertype "A"; supertype defines the argument type as "list[T]" \
                                    # N: This violates the Liskov substitution principle \
                                    # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

class C(A[List[T]]):
    def x(self, t: List[T]) -> None: ...

[case operator_shortcut_type_error]

class A:
    def __add__(self, x: int) -> str:
        return ""

A() + A()  # E: Unsupported operand types for + ("A" and "A")

[case generic_class_as_callable]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, x: T):
        self.x = x

def foo(c: Callable[[int], Foo[int]]) -> None: ...
def bar(c: Callable[[int], Foo[str]]) -> None: ...

foo(Foo)
bar(Foo)  # E: Argument 1 to "bar" has incompatible type "Type[Foo]"; expected "Callable[[int], Foo[str]]"

[case generic_class_as_callable_with_func_type_vars]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
S = TypeVar('S')

class Foo(Generic[T]):
    def __init__(self, x: T, y: S, z: S):
        self.x = x

def foo(c: Callable[[int, float, float], Foo[int]]) -> None: ...
def bar(c: Callable[[int, float, str], Foo[int]]) -> None: ...
def baz(c: Callable[[str, str, float], Foo[int]]) -> None: ...

foo(Foo)
bar(Foo)
baz(Foo)  # E: Argument 1 to "baz" has incompatible type "Type[Foo]"; expected "Callable[[str, str, float], Foo[int]]"

[case generic_class_as_callable_with_func_type_vars_and_bounds]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
S = TypeVar('S', bound=int)

class Foo(Generic[T]):
    def __init__(self, x: T, y: S, z: S):
        self.x = x

def foo(c: Callable[[str, int, int], Foo[str]]) -> None: ...
def bar1(c: Callable[[str, int, bytes], Foo[str]]) -> None: ...
def bar2(c: Callable[[str, bytes, int], Foo[str]]) -> None: ...
def bar3(c: Callable[[str, str, float], Foo[int]]) -> None: ...

foo(Foo)
bar1(Foo)  # E: Argument 1 to "bar1" has incompatible type "Type[Foo]"; expected "Callable[[str, int, bytes], Foo[str]]"
bar2(Foo)  # E: Value of type variable "S" of "bar2" cannot be "bytes"
bar3(Foo)  # E: Value of type variable "S" of "bar3" cannot be "str"

[case class_init_with_mismatching_self_type_vars]
from typing import Generic, TypeVar

T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T, U]):
    def __init__(self: Foo[int, U], y: U): ...

class Bar(Foo[str, U]): ...

x: Bar[float]  # Fine
y = Bar(1.0)  # E: Invalid self type in __init__
reveal_type(y)  # N: Revealed type is "__main__.Bar[float]"

[case class_init_with_mismatching_self_type_vars_overload]
from typing import Generic, TypeVar, overload

T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T, U]):
    @overload
    def __init__(self: Foo[int, U], y: U): ...
    @overload
    def __init__(self: Foo[float, U], y: U): ...
    def __init__(self, y): ...

class Bar(Foo[str, U]): ...

x: Bar[float]  # Fine
y = Bar(1.0)  # E: No overload variant of "Bar" matches argument type "float" \
              # N: Possible overload variants: \
              # N:     def __init__(self: Foo[int, U], y: U) -> Bar[Any] \
              # N:     def __init__(self: Foo[float, U], y: U) -> Bar[Any]

reveal_type(y)  # N: Revealed type is "Any"

[case class_union_attribute_assignment]
from typing import Union

class Foo:
    x: Union[str, int] = ''

f = Foo()
f.x = ''
f.x = 1

[case self_attr_context]
class Foo:
    def __init__(self, x: list[int]):
        self.x = x

f: Foo
f.x = []

[case avoid_losing_context_when_self_attr_doesnt_exist]
class Foo: ...
x = [1]
Foo().undefined = x = []  # E: "Foo" has no attribute "undefined"

[case avoid_context_of_getattr]
class Foo:
    def __getattr__(self, name: str) -> list[int]: ...

class Bar(Foo):
    x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")

[case initialize_type]
type("A", (), {})
type("B", 1, 1)

[out]
main:2: error: No overload variant of "type" matches argument types "str", "int", "int"
main:2: note: Possible overload variants:
main:2: note:     def __init__(self, object, /) -> type
main:2: note:     def __init__(self, str, tuple[Type[Any], ...], dict[str, Any], /, **kwds: Any) -> type

[case assign_in_subclass_to_callable]
# Inspired a bit by testTypedDictUnpackSingleWithSubtypingNoCrash
from typing import Callable

def f(pseudo_self, x: int) -> None:
    pass
def g(pseudo_self, y: str) -> None:
    pass
def h(x: int) -> None:
    pass

class C:
    foo: Callable[[int], None]
    bar: Callable[[int], None]
    baz: Callable[[int], None]

# Currently we fail
class D(C):
    foo = f
    bar = g  # E: Argument 1 of "bar" is incompatible with supertype "C"; supertype defines the argument type as "int" \
             # N: This violates the Liskov substitution principle \
             # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
    baz = h  # E: Invalid self argument "D" to attribute function "h" with type "Callable[[int], None]" \
             # E: Signature of "baz" incompatible with supertype "C" \
             # N:      Superclass: \
             # N:          def (int, /) -> None \
             # N:      Subclass: \
             # N:          Callable[[], None]

[case total_ordering_missing_method]
from functools import total_ordering

@total_ordering
class Ord:  # E: No ordering operation defined when using "functools.total_ordering": < > <= >=
    def __eq__(self, other: object) -> bool:
        return False

reveal_type(Ord() < Ord())  # E: Unsupported left operand type for < ("Ord")  # N: Revealed type is "Any"
reveal_type(Ord() <= Ord())  # E: Unsupported left operand type for <= ("Ord")  # N: Revealed type is "Any"
reveal_type(Ord() == Ord())  # N: Revealed type is "bool"

[case self_annotation_eq_mismatch]
from typing import Generic, TypeVar

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __eq__(self: A[int], other: object) -> bool: ...

aint = A(1)
astr = A("")
aint == None
astr == None
