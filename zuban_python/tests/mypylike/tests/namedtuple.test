[case namedtuple__new__]

from typing import NamedTuple
class A(NamedTuple):
    x: int

reveal_type(A.__new__)  # N: Revealed type is "?"
reveal_type(A(1).__new__)  # N: Revealed type is "?"

reveal_type(A.__new__(A, 1))  # N: Revealed type is "A"
reveal_type(A(1).__new__(A, 1))  # N: Revealed type is "A"

[case namedtuple_type_used_as_callable]
from typing import NamedTuple, Generic, Callable, ParamSpec, TypeVar

P = ParamSpec("P")
T = TypeVar("T")

class Foo(NamedTuple):
    a: int = 1
class Bar(NamedTuple, Generic[T]):
    a: T

Baz = NamedTuple("Baz", [('x', int)])

def identity(x: Callable[P, T]) -> Callable[P, T]:
    return x

reveal_type(identity(Foo)) # N: Revealed type is "def (a: builtins.int =) -> tuple[builtins.int, fallback=__main__.Foo]"
reveal_type(identity(Bar)) # N: Revealed type is "def [T] (a: T) -> tuple[T, fallback=__main__.Bar[T]]"
reveal_type(identity(Baz)) # N: Revealed type is "def (x: builtins.int) -> tuple[builtins.int, fallback=__main__.Baz]"

[case namedtuple_replace_on_inherited_class]
from typing import NamedTuple

class Foo(NamedTuple):
    a: int

class Bar(Foo): ...

b: Bar
Bar._replace(b, c=3) # E: Unexpected keyword argument "c" for "_replace" of "Foo"
reveal_type(Bar._replace(b, a=3)) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"

b._replace(c=3) # E: Unexpected keyword argument "c" for "_replace" of "Foo"
reveal_type(b._replace(a=3)) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"

[case namedtuple_make_on_inherited_class]
from typing import NamedTuple

class Foo(NamedTuple):
    a: int

class Bar(Foo): ...

b: Bar
reveal_type(Bar._make([])) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"
reveal_type(b._make([])) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"

[case namedtuple_generic_call_form_in_class]
from typing import NamedTuple, TypeVar, Generic

T = TypeVar("T")
S = TypeVar("S")

class Foo(Generic[S]):
    def foo(self, s: S) -> None:
        NT = NamedTuple("NT", [("key", S), ("value", T)])
        reveal_type(NT)  # N: Revealed type is "def [T] (key: S, value: T) -> Tuple[S, T, fallback=__main__.NT]"

        wrong_count: NT[int, str] # E: "NT" expects 1 type argument, but 2 given

        nt_any: NT
        reveal_type(nt_any)  # N: Revealed type is "Tuple[S, Any, fallback=__main__.NT]"
        nts: NT[str]
        reveal_type(nts)  # N: Revealed type is "Tuple[S, builtins.str, fallback=__main__.NT]"

        NT[int](key=1, value=1)  # E: Argument "key" to "NT" has incompatible type "int"; expected "S"
        NT[int](key=s, value=1)

[case functional_namedtuple_attributes_are_readonly]
# Like testTypingNamedTupleAttributesAreReadOnly but with functional namedtuples
from typing import NamedTuple, Protocol

class HasX(Protocol):
    x: str

A = NamedTuple("A", [('x', str)])

a: HasX = A("foo")  # E: Incompatible types in assignment (expression has type "A", variable has type "HasX") \
                    # N: Protocol member HasX.x expected settable variable, got read-only attribute
a.x = "bar"

[case namedtuple_iter_of_generic]
from typing import NamedTuple, Generic, TypeVar

T = TypeVar("T")
class A(NamedTuple, Generic[T]):
    val: T

a: A[int]
for x in a:
    reveal_type(x)  # N: Revealed type is "int"

[case namedtuple_generic_matching]
from typing import NamedTuple, Generic, TypeVar

T = TypeVar("T")
N = NamedTuple("N", [('t', T)])

def f1(n1: N[int], n2: N[int]) -> None:
    n1 = n2

def f2(n1: N, n2: N) -> None:
    n1 = n2

def f3(n1: N[int], n2: N[str]) -> None:
    n1 = n2  # E: Incompatible types in assignment (expression has type "N", variable has type "N")

[case namedtuple_invalid_init]
from typing import NamedTuple
from collections import namedtuple

x = NamedTuple()  # E: Too few arguments for "NamedTuple()"
y = namedtuple()  # E: Missing positional arguments "typename", "field_names" in call to "namedtuple"

A = NamedTuple("A", *[{}])  # E: List or tuple literal expected as the second argument to "NamedTuple()"
B = namedtuple("B", *[{}])  # E: List or tuple literal expected as the second argument to "namedtuple()"

C = NamedTuple("C", lambda: 1)  # E: List or tuple literal expected as the second argument to "NamedTuple()"
D = namedtuple("D", lambda: 1)  # E: List or tuple literal expected as the second argument to "namedtuple()" \
                                # E: Argument 2 to "namedtuple" has incompatible type "Callable[[], int]"; expected "str | Iterable[str]"
