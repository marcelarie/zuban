[case class_var_without_type_qualifier]
from typing import ClassVar

class Foo:
    x: ClassVar = 1

reveal_type(Foo.x)  # N: Revealed type is "int"
reveal_type(Foo().x)  # N: Revealed type is "int"
Foo().x = 3  # E: Cannot assign to class variable "x" via instance
Foo.x = 4

[case invalid_classvar_attribute]
from typing import ClassVar
class Foo:
    x: ClassVar[str].upper  # E: Invalid type comment or annotation

[case double_classvar_getitem]
from typing import ClassVar
class Foo:
    x: ClassVar[str][str]  # E: Invalid type comment or annotation

[case any_getitem]
from typing import Any
x: Any[int]  # E: Invalid type comment or annotation

[case avoid_type_cycle]
class Foo:
    foo: foo
    bar: list[bar]
    baz += baz  # E: Name "baz" is not defined   # E: Name "baz" is not defined
    bla: baz  # E: Invalid type comment or annotation

    x = x  # E: Name "x" is not defined
    y: x  # E: Variable "__main__.x" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    a = list[a]  # E: Name "a" is not defined
    b: a

[case avoid_type_cycle_in_assignment_expr]
class Foo:
    l = (x := x)  # E: Name "x" is not defined
    y: x  # E: Variable "__main__.x" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    l = (a := list[a])  # E: Name "a" is not defined
    b: a  # E: Variable "__main__.a" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case avoid_type_cycle_in_lambda]
class Foo:
    x = lambda x=x: x  # E: Name "x" is not defined

[case avoid_type_cycle_in_param]
from typing import cast
def foo(
    foo: foo  # E: Function "__main__.foo" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
    ) -> foo: ...  # E: Function "__main__.foo" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
def bar(
    bar: list[bar]  # E: Function "__main__.bar" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
    ) -> list[bar]: ...  # E: Function "__main__.bar" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
def baz(x: undefined) -> undefined2: ...  # E: Name "undefined" is not defined # E: Name "undefined2" is not defined

x = 1
def oneline1() -> None: cast(oneline1, x)  # E: Function "__main__.oneline1" is not valid as a type \
                                           # N: Perhaps you need "Callable[...]" or a callback protocol?
def oneline2() -> None: cast(undefined, x)  # E: Name "undefined" is not defined
def default_param_cast1(z: int = cast(undefined, 1)) -> None: ...  # E: Name "undefined" is not defined
def default_param_cast2(z: int = cast(default_param_cast2, 1)) -> None: ...  # E: Name "default_param_cast2" is used before definition \
                                                                             # E: Function "__main__.default_param_cast2" is not valid as a type \
                                                                             # N: Perhaps you need "Callable[...]" or a callback protocol?
[case avoid_type_cycle_in_class_def]
from typing import List
class Foo(Foo): ...  # E: Name "Foo" is used before definition  # E: Cannot resolve name "Foo" (possible cyclic definition)
class Bar(List[Bar]): ...  # E: Name "Bar" is used before definition

[case invalid_usage_of_param_spec_attr]
from typing import ParamSpec
P = ParamSpec("P")
def foo(*args: P.args, **kwargs: P.kwargs) -> None:
    x: P.args
    y: P.kwargs
    z: P.undefined  # E: Name "P.undefined" is not defined
    x = args
    y = kwargs
    if bool():
        x = y  # E: Incompatible types in assignment (expression has type "P.kwargs", variable has type "P.args")
    y = x  # E: Incompatible types in assignment (expression has type "P.args", variable has type "P.kwargs")

[case namespace_attr]
import foo
x: foo.bar.baz.X
[file foo/__init__.py]
from foo.bar import baz
[file foo/bar/baz.py]
class X: ...

[case namedtuple_additional_invalid_definitions]
from typing import NamedTuple

Bar1 = NamedTuple("Bar1", [('x', *int)])  # E: Star args are not supported
Bar2 = NamedTuple("Bar2", [(*'x', int)])  # E: Invalid "NamedTuple()" field name
Bar3 = NamedTuple("Bar3", [*int])  # E: Tuple expected as "NamedTuple()" field
Bar4 = NamedTuple("Bar4", [()])  # E: NamedTuple field should be a tuple of a string literal and a type
Bar5 = NamedTuple("Bar5", [(*int,)])  # E: NamedTuple field should be a tuple of a string literal and a type
Bar5 = NamedTuple("Bar5", [('x',)])  # E: NamedTuple field should be a tuple of a string literal and a type

[case namedtuple_invalid_bound]
from typing import NamedTuple, Generic, TypeVar
T = TypeVar("T", bound=int)
class Foo(NamedTuple, Generic[T]):
    t: T

Bar = NamedTuple("Bar", [('x', T)])

x: Foo[str]  # E: Type argument "str" of "Foo" must be a subtype of "int"
y: Bar[str]  # E: Type argument "str" of "Bar" must be a subtype of "int"

[case typed_dict_invalid_bound]
from typing import TypedDict, Generic, TypeVar
T = TypeVar("T", bound=int)
class Foo(TypedDict, Generic[T]):
    t: T

Bar = TypedDict("Bar", {'x': T})

x: Foo[str]  # E: Type argument "str" of "Foo" must be a subtype of "int"
y: Bar[str]  # E: Type argument "str" of "Bar" must be a subtype of "int"

[case typed_dict_non_generic_getitem]
from typing import TypedDict
Bar = TypedDict("Bar", {'x': int})
x: Bar[int]  # E: "Bar" expects no type arguments, but 1 given

[case invalid_class_type_application]
from typing import Generic, TypeVar
T = TypeVar("T")
class Foo(Generic[T]): ...
Foo[int][int]  # E: Invalid type comment or annotation

[case invalid_callable]
from typing import Callable

c1: Callable[int:str, int]  # E: Invalid callable params

reveal_type(c1)  # N: Revealed type is "def (*Any, **Any) -> int"

[case never_in_unions]
from typing import Union, Never

u1: Union[Never, Never]
u2: Union[Never]
u3: Union[Never, int]
u4: Union[Never, int, str, Never]

reveal_type(u1)  # N: Revealed type is "Never"
reveal_type(u2)  # N: Revealed type is "Never"
reveal_type(u3)  # N: Revealed type is "int"
reveal_type(u4)  # N: Revealed type is "int | str"

[case invalid_type_type]
from typing import Type
x: Type[int, str]  # E: Invalid type comment or annotation

[case fstring_forward_reference]
x: f'int'  # E: Invalid type comment or annotation

[case invalid_type_application]
from typing import Protocol, Generic
Generic[int]  # E: Invalid type application
Protocol[int]  # E: Invalid type application

[case parens_in_annotation]
class X:
    foo: (int)
    bar: ()  # E: Syntax error in type annotation \
             # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
    baz: (int) = 1

def foo(
        x: (tuple[int, str]),
        y: (),  # E: Syntax error in type annotation \
                # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
        z: (a := int),  # E: Invalid type comment or annotation
        ): ...

[case func_in_class_should_not_be_looked_at_as_a_type_definition]
bar = int
class Foo:
    x: foo  # E: Name "foo" is not defined
    y: bar

    def foo(self) -> None: ...
    def bar(self) -> None: ...

reveal_type(Foo().x)  # N: Revealed type is "Any"
reveal_type(Foo().y)  # N: Revealed type is "int"

[case invalid_module_getattr]
from ok import undefined1
from not_ok import undefined2  # E: "int" not callable
reveal_type(undefined1)  # N: Revealed type is "str"
reveal_type(undefined2)  # N: Revealed type is "Any"

x: undefined1  # E: Invalid type comment or annotation
y: undefined2

[file ok.py]
def __getattr__(name: str) -> str: ...
[file not_ok.py]
__getattr__ = 1  # E: Invalid signature "int" for "__getattr__"

[case type_var_tuple_unpack_in_callable]
from typing import TypeVarTuple, Callable, Unpack
Ts = TypeVarTuple("Ts")
x: Callable[[Ts], int]  # E: TypeVarTuple "Ts" is only valid with an unpack
y: Callable[[Unpack[Ts]], int]
z: Callable[[*Ts], int]
reveal_type(x)  # N: Revealed type is "def [Ts] (Any) -> int"
reveal_type(y)  # N: Revealed type is "def [Ts] (*Unpack[Ts]) -> int"
reveal_type(z)  # N: Revealed type is "def [Ts] (*Unpack[Ts]) -> int"

[case mypy_extensions_invalid_callable_param]
from typing import Callable
from mypy_extensions import Arg, DefaultArg

x1: Callable[[Arg(int, f"{1}")], int]  # E: Name argument should be a string literal
x2: Callable[[Arg(int, 1)], int] # E: Name argument should be a string literal \
                                 # E: No overload variant of "Arg" matches argument types "Type[int]", "int" \
                                 # N: Possible overload variants: \
                                 # N:     def [_T] Arg(type: _T, name: str | None = ...) -> _T \
                                 # N:     def Arg(*, name: str | None = ...) -> Any
