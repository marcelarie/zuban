[case class_var_without_type_qualifier]
from typing import ClassVar

class Foo:
    x: ClassVar = 1

reveal_type(Foo.x)  # N: Revealed type is "int"
reveal_type(Foo().x)  # N: Revealed type is "int"
Foo().x = 3  # E: Cannot assign to class variable "x" via instance
Foo.x = 4

[case invalid_classvar_attribute]
from typing import ClassVar
class Foo:
    x: ClassVar[str].upper  # E: Invalid type comment or annotation

[case double_classvar_getitem]
from typing import ClassVar
class Foo:
    x: ClassVar[str][str]  # E: Invalid type comment or annotation

[case any_getitem]
from typing import Any
x: Any[int]  # E: Invalid type comment or annotation

[case avoid_type_cycle]
class Foo:
    foo: foo
    bar: list[bar]
    baz += baz  # E: Name "baz" is not defined   # E: Name "baz" is not defined
    bla: baz  # E: Invalid type comment or annotation

    x = x  # E: Name "x" is not defined
    y: x  # E: Variable "__main__.x" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    a = list[a]  # E: Name "a" is not defined
    b: a

[case avoid_type_cycle_in_assignment_expr]
class Foo:
    l = (x := x)  # E: Name "x" is not defined
    y: x  # E: Variable "__main__.x" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    l = (a := list[a])  # E: Name "a" is not defined
    b: a  # E: Variable "__main__.a" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case avoid_type_cycle_in_lambda]
class Foo:
    x = lambda x=x: x  # E: Name "x" is not defined

[case avoid_type_cycle_in_param]
from typing import cast
def foo(
    foo: foo  # E: Function "__main__.foo" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
    ) -> foo: ...  # E: Function "__main__.foo" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
def bar(
    bar: list[bar]  # E: Function "__main__.bar" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
    ) -> list[bar]: ...  # E: Function "__main__.bar" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
def baz(x: undefined) -> undefined2: ...  # E: Name "undefined" is not defined # E: Name "undefined2" is not defined

x = 1
def oneline1() -> None: cast(oneline1, x)  # E: Function "__main__.oneline1" is not valid as a type \
                                           # N: Perhaps you need "Callable[...]" or a callback protocol?
def oneline2() -> None: cast(undefined, x)  # E: Name "undefined" is not defined
def default_param_cast1(z: int = cast(undefined, 1)) -> None: ...  # E: Name "undefined" is not defined
def default_param_cast2(z: int = cast(default_param_cast2, 1)) -> None: ...  # E: Name "default_param_cast2" is used before definition \
                                                                             # E: Function "__main__.default_param_cast2" is not valid as a type \
                                                                             # N: Perhaps you need "Callable[...]" or a callback protocol?
[case avoid_type_cycle_in_class_def]
from typing import List
class Foo(Foo): ...  # E: Name "Foo" is used before definition  # E: Cannot resolve name "Foo" (possible cyclic definition)
class Bar(List[Bar]): ...  # E: Name "Bar" is used before definition

[case invalid_usage_of_param_spec_attr]
from typing import ParamSpec
P = ParamSpec("P")
def foo(*args: P.args, **kwargs: P.kwargs) -> None:
    x: P.args
    y: P.kwargs
    z: P.undefined  # E: Name "P.undefined" is not defined
    x = args
    y = kwargs
    if bool():
        x = y  # E: Incompatible types in assignment (expression has type "P.kwargs", variable has type "P.args")
    y = x  # E: Incompatible types in assignment (expression has type "P.args", variable has type "P.kwargs")

[case namespace_attr]
import foo
x: foo.bar.baz.X
[file foo/__init__.py]
from foo.bar import baz
[file foo/bar/baz.py]
class X: ...

[case namedtuple_invalid_bound]
from typing import NamedTuple, Generic, TypeVar
T = TypeVar("T", bound=int)
class Foo(NamedTuple, Generic[T]):
    t: T

Bar = NamedTuple("Bar", [('x', T)])

x: Foo[str]  # E: Type argument "str" of "Foo" must be a subtype of "int"
y: Bar[str]  # E: Type argument "str" of "Bar" must be a subtype of "int"
