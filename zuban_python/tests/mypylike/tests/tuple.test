[case tuple_none]
x: tuple[None]
reveal_type(x.__getitem__(0)) # N: Revealed type is "None"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_empty]
x: tuple[()]
reveal_type(x.__getitem__(0)) # N: Revealed type is "Never"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_one]
x: tuple[str]
reveal_type(x.__getitem__(0)) # N: Revealed type is "str"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_multiple]
x: tuple[int, str]
reveal_type(x.__getitem__(0)) # N: Revealed type is "object"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_none_arbitrary]
x: tuple[None, ...]
reveal_type(x.__getitem__(0)) # N: Revealed type is "None"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_empty_arbitrary]
x: tuple[(), ...]  # E: Syntax error in type annotation \
                   # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
reveal_type(x.__getitem__(0)) # N: Revealed type is "Any"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_one_arbitrary]
x: tuple[str, ...]
reveal_type(x.__getitem__(0)) # N: Revealed type is "str"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_multiple_illegal_arbitrary]
-- TODO reenable this
-- x: tuple[int, str, ...]
-- reveal_type(x.__getitem__(0)) # N: Revealed type is "object"
-- reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_multiple_arbitrary]
y: tuple[int | str, ...]
reveal_type(y.__getitem__(0)) # N: Revealed type is "int | str"
reveal_type(y.index(0)) # N: Revealed type is "int"

[case tuple_methods_no_generic]
y: tuple
reveal_type(y.__getitem__(0)) # N: Revealed type is "Any"
reveal_type(y.index(0)) # N: Revealed type is "int"

[case tuple_inference]
from typing import TypeVar, Generic

T = TypeVar("T")

class A(Generic[T]): ...

x: tuple[A[int], ...] = (A(), A())
y: tuple[A[int], ...] = (A(), 1)  # E: Incompatible types in assignment (expression has type "tuple[A[int], int]", variable has type "tuple[A[int], ...]")

[case tuple_negative_index_out_of_range]
reveal_type((1, "")[-3])  # E: Tuple index out of range \
                          # N: Revealed type is "Any"

[case inheritance_tuple_mul]
from typing import Tuple

class T2(Tuple[int, str]): pass

x: T2
reveal_type(x * 2)  # N: Revealed type is "tuple[int, str, int, str]"
reveal_type(2 * x)  # N: Revealed type is "tuple[int, str, int, str]"

[case inheritance_tuple_add]
from typing import Tuple

class T2(Tuple[int, str]): pass

x: T2
reveal_type(x + (1.0,))  # N: Revealed type is "tuple[int, str, float]"
reveal_type((1.0,) + x)  # N: Revealed type is "tuple[float, int, str]"

[case tuple_slice_reverse_arbitrary_len]
x: tuple[int, ...]
reveal_type(x[42:])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[:42])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[::-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[::-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[0:0])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[-2:-5:-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[-2:-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[-5:-3])  # N: Revealed type is "tuple[int, ...]"
