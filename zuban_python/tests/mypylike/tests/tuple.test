[case tuple_none]
x: tuple[None]
reveal_type(x.__getitem__(0)) # N: Revealed type is "None"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_empty]
x: tuple[()]
reveal_type(x.__getitem__(0)) # N: Revealed type is "Never"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_one]
x: tuple[str]
reveal_type(x.__getitem__(0)) # N: Revealed type is "str"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_multiple]
x: tuple[int, str]
reveal_type(x.__getitem__(0)) # N: Revealed type is "int | str"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_none_arbitrary]
x: tuple[None, ...]
reveal_type(x.__getitem__(0)) # N: Revealed type is "None"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_empty_arbitrary]
x: tuple[(), ...]  # E: Syntax error in type annotation \
                   # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
reveal_type(x.__getitem__(0)) # N: Revealed type is "Any"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_one_arbitrary]
x: tuple[str, ...]
reveal_type(x.__getitem__(0)) # N: Revealed type is "str"
reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_multiple_illegal_arbitrary]
-- TODO reenable this
-- x: tuple[int, str, ...]
-- reveal_type(x.__getitem__(0)) # N: Revealed type is "object"
-- reveal_type(x.index(0)) # N: Revealed type is "int"

[case tuple_methods_multiple_arbitrary]
y: tuple[int | str, ...]
reveal_type(y.__getitem__(0)) # N: Revealed type is "int | str"
reveal_type(y.index(0)) # N: Revealed type is "int"

[case tuple_methods_no_generic]
y: tuple
reveal_type(y.__getitem__(0)) # N: Revealed type is "Any"
reveal_type(y.index(0)) # N: Revealed type is "int"

[case tuple_inference]
from typing import TypeVar, Generic

T = TypeVar("T")

class A(Generic[T]): ...

x: tuple[A[int], ...] = (A(), A())
y: tuple[A[int], ...] = (A(), 1)  # E: Incompatible types in assignment (expression has type "tuple[A[int], int]", variable has type "tuple[A[int], ...]")

[case tuple_negative_index_out_of_range]
reveal_type((1, "")[-3])  # E: Tuple index out of range \
                          # N: Revealed type is "Any"

[case inheritance_tuple_mul]
from typing import Tuple

class T2(Tuple[int, str]): pass

x: T2
reveal_type(x * 2)  # N: Revealed type is "tuple[int, str, int, str]"
reveal_type(2 * x)  # N: Revealed type is "tuple[int, str, int, str]"

[case inheritance_tuple_add]
from typing import Tuple

class T2(Tuple[int, str]): pass

x: T2
reveal_type(x + (1.0,))  # N: Revealed type is "tuple[int, str, float]"
reveal_type((1.0,) + x)  # N: Revealed type is "tuple[float, int, str]"

[case tuple_slice_reverse_arbitrary_len]
x: tuple[int, ...]
reveal_type(x[42:])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[:42])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[::-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[::-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[0:0])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[-2:-5:-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[-2:-3])  # N: Revealed type is "tuple[int, ...]"
reveal_type(x[-5:-3])  # N: Revealed type is "tuple[int, ...]"

[case tuple_slice_step_zero]
from typing import Unpack
x: tuple[int, ...]
y: tuple[int, str]
z: tuple[int, Unpack[tuple[bytes, ...]], str]
reveal_type(x[::0])  # E: slice step cannot be zero  # N: Revealed type is "tuple[Any, ...]"
reveal_type(y[::-0])  # E: slice step cannot be zero  # N: Revealed type is "tuple[Any, ...]"
reveal_type(z[1:-1:0])  # E: slice step cannot be zero  # N: Revealed type is "tuple[Any, ...]"

x[-1::0] # E: slice step cannot be zero
y[-1:3:0] # E: slice step cannot be zero
z[:-5:0] # E: slice step cannot be zero

[case tuple_reverse_slice]
x: tuple[int, str, bytes]
reveal_type(x[::-1])  # N: Revealed type is "tuple[bytes, str, int]"
reveal_type(x[:1:-1])  # N: Revealed type is "tuple[bytes]"

reveal_type(x[2:1:-1])  # N: Revealed type is "tuple[bytes]"
reveal_type(x[3:1:-1])  # N: Revealed type is "tuple[bytes]"
reveal_type(x[1:1:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[1:0:-1])  # N: Revealed type is "tuple[str]"

reveal_type(x[1::-1])  # N: Revealed type is "tuple[str, int]"
reveal_type(x[0::-1])  # N: Revealed type is "tuple[int]"

[case tuple_reverse_slice_negative_indices]
x: tuple[int, str, bytes]

reveal_type(x[-3::-1])  # N: Revealed type is "tuple[int]"
reveal_type(x[:-2:-1])  # N: Revealed type is "tuple[bytes]"
reveal_type(x[:-4:-1])  # N: Revealed type is "tuple[bytes, str, int]"
reveal_type(x[-1:-1:-1])  # N: Revealed type is "tuple[()]"

reveal_type(x[-1:1:-1])  # N: Revealed type is "tuple[bytes]"
reveal_type(x[-1:0:-1])  # N: Revealed type is "tuple[bytes, str]"

reveal_type(x[2:-1:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[1:-2:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[2:-3:-1])  # N: Revealed type is "tuple[bytes, str]"

[case tuple_reverse_slice_bigger_step]
x: tuple[int, str, bytes, float]
reveal_type(x[::-2])  # N: Revealed type is "tuple[float, str]"
reveal_type(x[1::-2])  # N: Revealed type is "tuple[str]"
reveal_type(x[2::-2])  # N: Revealed type is "tuple[bytes, int]"

reveal_type(x[:1:-2])  # N: Revealed type is "tuple[float]"
reveal_type(x[:2:-2])  # N: Revealed type is "tuple[float]"
reveal_type(x[:3:-2])  # N: Revealed type is "tuple[()]"

reveal_type(x[3:1:-2])  # N: Revealed type is "tuple[float]"
reveal_type(x[-2:-4:-2])  # N: Revealed type is "tuple[bytes]"
reveal_type(x[-4:-2:-2])  # N: Revealed type is "tuple[()]"
reveal_type(x[-1:-4:-2])  # N: Revealed type is "tuple[float, str]"

reveal_type(x[2:-4:-2])  # N: Revealed type is "tuple[bytes]"

[case tuple_reverse_slice_out_of_bounds]
x: tuple[int, str, bytes]
reveal_type(x[20:2:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[20:19:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[12:19:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[12:19:-4])  # N: Revealed type is "tuple[()]"
reveal_type(x[:19:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[:19:-4])  # N: Revealed type is "tuple[()]"
reveal_type(x[:-12:-4])  # N: Revealed type is "tuple[bytes]"
reveal_type(x[-12::-4])  # N: Revealed type is "tuple[()]"
reveal_type(x[-13:-12:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[-12:-13:-1])  # N: Revealed type is "tuple[()]"
reveal_type(x[-12::-1])  # N: Revealed type is "tuple[()]"

[case tuple_star_args_at_least_size_one_narrowed]
def foo(tup: tuple[int, ...]) -> None:
    def f(*args: int) -> None: ...
    def g(x: int, *args: int) -> None: ...
    def h(x: int, y: int, *args: int) -> None: ...

    def i(*args: str) -> None: ...
    def j(x: str, *args: int) -> None: ...
    def k(x: int, *args: str) -> None: ...
    def l(x: str, *args: str) -> None: ...
    def m(x: str, y: str, *args: str) -> None: ...

    def n(x: int) -> None: ...
    def o(*, x: int) -> None: ...

    if tup:
        f(*tup)
        g(*tup)
        h(*tup)

        i(*tup)  # E: Argument 1 to "i" has incompatible type "*tuple[int, Unpack[Tuple[int, ...]]]"; expected "str" \
                 # E: Argument 1 to "i" has incompatible type "*tuple[Unpack[Tuple[int, ...]]]"; expected "str"
        j(*tup)  # E: Argument 1 to "j" has incompatible type "*tuple[int, Unpack[Tuple[int, ...]]]"; expected "str"
        k(*tup)  # E: Argument 1 to "k" has incompatible type "*tuple[Unpack[Tuple[int, ...]]]"; expected "str"
        l(*tup)  # E: Argument 1 to "l" has incompatible type "*tuple[int, Unpack[Tuple[int, ...]]]"; expected "str" \
                 # E: Argument 1 to "l" has incompatible type "*tuple[Unpack[Tuple[int, ...]]]"; expected "str"
        m(*tup)  # E: Argument 1 to "m" has incompatible type "*tuple[int, Unpack[Tuple[int, ...]]]"; expected "str" \
                 # E: Argument 1 to "m" has incompatible type "*tuple[Unpack[Tuple[int, ...]]]"; expected "str" \
                 # E: Argument 1 to "m" has incompatible type "*tuple[Unpack[Tuple[int, ...]]]"; expected "str"

        n(*tup)
        o(*tup)  # E: Too many positional arguments for "o"

[case tuple_star_args_at_least_size_one_narrowed_variance]
def foo(tup1: tuple[int, ...], tup2: tuple[object, ...]) -> None:
    def f(*args: int) -> None: ...
    def g(x: int, *args: int) -> None: ...
    def h(x: int, y: int, *args: int) -> None: ...

    def x(*args: object) -> None: ...
    def y(x: object, *args: object) -> None: ...
    def z(x: object, y: object, *args: object) -> None: ...

    if tup1:
        if tup2:
            f(*tup1)
            g(*tup1)
            h(*tup1)

            f(*tup2)  # E: Argument 1 to "f" has incompatible type "*tuple[object, Unpack[Tuple[object, ...]]]"; expected "int" \
                      # E: Argument 1 to "f" has incompatible type "*tuple[Unpack[Tuple[object, ...]]]"; expected "int"
            g(*tup2)  # E: Argument 1 to "g" has incompatible type "*tuple[object, Unpack[Tuple[object, ...]]]"; expected "int" \
                      # E: Argument 1 to "g" has incompatible type "*tuple[Unpack[Tuple[object, ...]]]"; expected "int"
            h(*tup2)  # E: Argument 1 to "h" has incompatible type "*tuple[object, Unpack[Tuple[object, ...]]]"; expected "int" \
                      # E: Argument 1 to "h" has incompatible type "*tuple[Unpack[Tuple[object, ...]]]"; expected "int" \
                      # E: Argument 1 to "h" has incompatible type "*tuple[Unpack[Tuple[object, ...]]]"; expected "int"

            x(*tup1)
            y(*tup1)
            z(*tup1)

            x(*tup2)
            y(*tup2)
            z(*tup2)


[case tuple_star_args_at_least_size_one_narrowed_type_var]
from typing import TypeVar
T = TypeVar("T")

def foo(tup: tuple[int, ...]) -> None:
    def f(*args: T) -> T: ...
    def g(x: T, *args: T) -> T: ...
    def h(x: T, y: T, *args: T) -> T: ...
    def i(x: T, *args: int) -> T: ...
    def j(x: int, *args: T) -> T: ...

    if tup:
        reveal_type(f(*tup))  # N: Revealed type is "int"
        reveal_type(g(*tup))  # N: Revealed type is "int"
        reveal_type(h(*tup))  # N: Revealed type is "int"
        reveal_type(i(*tup))  # N: Revealed type is "int"
        reveal_type(j(*tup))  # N: Revealed type is "int"

[case with_unpack_function_args]
def foo(
        tup1: tuple[int, int, *tuple[int, ...], int],
        tup2: tuple[int, int, *tuple[int, ...], str],
        tup3: tuple[str, int, *tuple[int, ...], int],
        tup4: tuple[int, int, *tuple[str, ...], int],
        ) -> None:
    def f(x: int, y: int, *args: int) -> None: ...
    def g(x: str, y: int, *args: int) -> None: ...
    def h(x: str, y: int, z: int) -> None: ...

    f(*tup1)
    f(*tup2)  # E: Argument 1 to "f" has incompatible type "*tuple[Unpack[Tuple[int, ...]], str]"; expected "int"
    f(*tup3)  # E: Argument 1 to "f" has incompatible type "*tuple[str, int, Unpack[Tuple[int, ...]], int]"; expected "int"

    g(*tup1)  # E: Argument 1 to "g" has incompatible type "*tuple[int, int, Unpack[Tuple[int, ...]], int]"; expected "str"
    g(*tup2)  # E: Argument 1 to "g" has incompatible type "*tuple[int, int, Unpack[Tuple[int, ...]], str]"; expected "str" \
              # E: Argument 1 to "g" has incompatible type "*tuple[Unpack[Tuple[int, ...]], str]"; expected "int"
    g(*tup3)

    h(*tup1)  # E: Argument 1 to "h" has incompatible type "*tuple[int, int, Unpack[Tuple[int, ...]], int]"; expected "str"
    h(*tup2)  # E: Argument 1 to "h" has incompatible type "*tuple[int, int, Unpack[Tuple[int, ...]], str]"; expected "str" \
              # E: Argument 1 to "h" has incompatible type "*tuple[Unpack[Tuple[int, ...]], str]"; expected "int"
    h(*tup3)
    h(*tup4)  # E: Argument 1 to "h" has incompatible type "*tuple[int, int, Unpack[Tuple[str, ...]], int]"; expected "str" \
              # E: Argument 1 to "h" has incompatible type "*tuple[Unpack[Tuple[str, ...]], int]"; expected "int"

[case valid_slice_args]
def foo(x: tuple[int, str], z: int | None) -> None:
    reveal_type(x[z:])  # N: Revealed type is "tuple[int | str, ...]"

[case tuple_execution]
from typing import Iterable
def foo(x: Iterable[int], y: tuple[int, str]) -> None:
    reveal_type(tuple(x))  # N: Revealed type is "tuple[int, ...]"
    reveal_type(tuple(y))  # N: Revealed type is "tuple[int | str, ...]"
    reveal_type(tuple())  # N: Revealed type is "tuple[Never, ...]"

[case tuple_execution_with_context]
def foo(wanted: tuple[list[int], ...]) -> None:
    wanted = tuple([[]])
    wanted = tuple([[1]])
