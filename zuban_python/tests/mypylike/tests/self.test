[case self_as_base_class]
from typing import Self
class Foo(Self): ...  # E: Self type is only allowed in annotations within class definition
class Foo2(list[Self]): ...  # E: Self type is only allowed in annotations within class definition

[case self_as_nested_base_class]
from typing import Self
class Foo:
    class Bar(list[Self]): ...  # E: Self type is only allowed in annotations within class definition

[case self_invalid_annotation]
from typing import Self
x: Self  # E: Self type is only allowed in annotations within class definition
def foo(self) -> None:
    x: Self  # E: Self type is only allowed in annotations within class definition

[case self_valid_annotation]
from typing import Self
class Foo:
    x: Self
    def foo(self) -> None:
        x: Self

[case self_invalid_function]
from typing import Self
def foo(self: Self) -> None:  ...  # E: Self type is only allowed in annotations within class definition
def foo2() -> Self: ...  # E: Self type is only allowed in annotations within class definition

[case self_valid_method]
from typing import Self
class Foo:
    x: int
    def return_self(self: Self) -> Self:
        reveal_type(self.x)  # N: Revealed type is "int"
        reveal_type(self)  # N: Revealed type is "Self"
        return self

reveal_type(Foo().return_self())  # N: Revealed type is "__main__.Foo"
reveal_type(Foo.return_self(Foo()))  # N: Revealed type is "__main__.Foo"

[case self_valid_method_untyped_input]
from typing import Self
class Foo:
    x: int
    def return_self(self) -> Self:
        reveal_type(self.x)  # N: Revealed type is "int"
        reveal_type(self)  # N: Revealed type is "Self"
        return self

reveal_type(Foo().return_self())  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().return_self().x)  # N: Revealed type is "int"

[case self_instance_variable1]
from typing import Self
class Foo:
    x: Self
    y: int
    def foo(self) -> Self:
        self.x = self
        return self.x

reveal_type(Foo().x)  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().x.y)  # N: Revealed type is "int"

[case self_instance_variable2]
from typing import Self
class Foo:
    x: Self
    y: int
    def foo(self) -> None: ...

reveal_type(Foo().x)  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().x.y)  # N: Revealed type is "int"
reveal_type(Foo.x)  # E: Access to generic instance variables via class is ambiguous \
                    # N: Revealed type is "__main__.Foo"
reveal_type(Foo.x.y)  # E: Access to generic instance variables via class is ambiguous \
                      # N: Revealed type is "int"

[case self_instance_variable3]
from typing import Self
class Foo:
    x: Self
    def foo(self) -> Self:
        return self.x

[case self_instance_with_classvar]
from typing import Self, ClassVar
class Foo:
    x: ClassVar[Self]
    y: int
    def foo(self) -> None: ...

reveal_type(Foo().x)  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().x.y)  # N: Revealed type is "int"
reveal_type(Foo.x)  # N: Revealed type is "__main__.Foo"
reveal_type(Foo.x.y)  # N: Revealed type is "int"

[case self_with_generics]
from typing import Self, TypeVar, Generic

T = TypeVar("T")

class Foo(Generic[T]):
    def foo(self) -> Self:
        x: Foo[T] = self
        y: Foo[int] = self  # E: Incompatible types in assignment (expression has type "Self", variable has type "Foo[int]")
        z: Foo[str] = self  # E: Incompatible types in assignment (expression has type "Self", variable has type "Foo[str]")
        return self

reveal_type(Foo[int]().foo())  # N: Revealed type is "__main__.Foo[int]"

[case self_with_generics_bound]
from typing import Self, TypeVar, Generic

T = TypeVar("T", bound=int)

class Foo(Generic[T]):
    value: T
    def foo(self: Self):
        reveal_type(self.value) # N: Revealed type is "T"
        reveal_type(self.value + 1) # N: Revealed type is "int"

[case no_self]
from typing import Any, overload
class C:
    def foo() -> None: ... # E: Method must have at least one argument. Did you forget the "self" argument?
    def foo2(*, bar: C) -> None: ... # E: Method must have at least one argument. Did you forget the "self" argument?
    def foo3(*bar: C) -> None: ...
    def foo4(**bar: C) -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?

    @overload
    def bar() -> None: ... # E: Method must have at least one argument. Did you forget the "self" argument? 
    @overload
    def bar(*, a: int) -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    @overload
    def bar(self) -> None: ...
    def bar(*args: Any, **kwargs: Any) -> None: ...

reveal_type(C().foo()) # E: Attribute function "foo" with type "Callable[[], None]" does not accept self argument \
                       # N: Revealed type is "None"
reveal_type(C().bar()) # N: Revealed type is "None"

reveal_type(C().foo3()) # N: Revealed type is "None"

[case self_return_allowed]
from typing import Self
class Foo():
    def meth2(self: Self) -> Self:
        return self
    def meth3(self) -> Self:
        return self
    def meth(self) -> Self:
        if bool():
            return self.meth2()
        else:
            return self.meth3()

reveal_type(Foo().meth()) # N: Revealed type is "__main__.Foo"
reveal_type(Foo().meth2()) # N: Revealed type is "__main__.Foo"

[case self_param_in_method]
from typing import Self

class X:
    def foo(self, other: Self) -> None: ...
    def bar(self, other: Self) -> Self:
        return other

X().foo(X())
reveal_type(X().bar(X()))  # N: Revealed type is "__main__.X"

[case self_param_in_method_inherited]
from typing import Self

class Base:
    def foo(self, other: Self) -> None: ...
    def bar(self, other: Self) -> Self:
        return other
    def baz(self: Self, other: Self) -> Self:
        return other

class X(Base): ...

X().foo(X())
reveal_type(X().bar(X()))  # N: Revealed type is "__main__.X"
reveal_type(X().baz(X()))  # N: Revealed type is "__main__.X"

X().bar(Base())  # E: Argument 1 to "bar" of "Base" has incompatible type "Base"; expected "Self"
X().baz(Base())  # E: Argument 1 to "baz" of "Base" has incompatible type "Base"; expected "X"

[case invalid_self_argument_return]
from typing import TypeVar, Generic
T = TypeVar("T")
class Foo(Generic[T]):
    def foo(self: Foo[int]) -> int:
        return 1

x = Foo[str]().foo() # E: Invalid self argument "Foo[str]" to attribute function "foo" with type "Callable[[Foo[int]], int]"
reveal_type(x)  # N: Revealed type is "int"

[case self_argument_to_class__init__]
from typing import Self
class Foo:
    def __init__(self) -> None:
        Bar(self, Bar(self, None))

class Bar:
    def __init__(self, x: Foo, y: Self | None) -> None: ...

[case self_of_new_type]
from typing import NewType, Self, TypeVar
T = TypeVar("T")
class C:
    def foo(self) -> Self: ...
    def bar(self: T) -> T: ...

N = NewType("N", C)
def x(x: N) -> N:
    if bool():
        return x.foo()
    return x.bar()

[case self_like_override]
from typing import Self
class A():
    def copy_modified1(self) -> Self: ...
    def copy_modified2(self) -> Self: ...

class B(A):
    # This is ok, because the constrained that Self is still A is ensured
    def copy_modified1(self) -> B: ...
    def copy_modified2(self) -> A: ...  # E: Return type "A" of "copy_modified2" incompatible with return type "B" in supertype "A"

[case class_binding_of_self_with_weird_args_and_class_lookup]
from typing import Self
class C:
    def foo(*args: Self) -> None: ...
    def bar(self: Self) -> None: ...

class D(C): ...

reveal_type(C.foo)  # N: Revealed type is "def [Self <: __main__.C] (*args: Self)"
C.foo(D(), C())
C.foo(D(), D())
D.foo(D(), C())
D.foo(C(), C())
reveal_type(C.bar)  # N: Revealed type is "def (self: __main__.C)"

[case class_lookup_with_self_generics]
from typing import Self, Callable, TypeVar, Generic, ClassVar

def simple_dec(x: T) -> T: ...
T = TypeVar("T")
class G(Generic[T]):
    def foo(self, x: T) -> Self: ...

    @simple_dec
    def bar(self, x: T) -> Self: ...

class H(G[list[T]]): ...

class C:
    def x(self, one: type[G[int]], other: type[G[Self]], h: type[H[str]]) -> None:
        reveal_type(one.foo)  # N: Revealed type is "def [Self <: __main__.G[int]] (self: Self, x: int) -> Self"
        reveal_type(one.bar)  # N: Revealed type is "def [Self <: __main__.G[int]] (self: Self, x: int) -> Self"

        foo = other.foo
        bar = other.bar
        # The formatting is a bit confusing, but it seems to do the correct thing.
        reveal_type(foo)  # N: Revealed type is "def [Self <: __main__.G[Self]] (self: Self, x: Self) -> Self"
        reveal_type(bar)  # N: Revealed type is "def [Self <: __main__.G[Self]] (self: Self, x: Self) -> Self"

        foo(C(), self)  # E: Value of type variable "Self" of "foo" of "G" cannot be "C"
        foo(D(), self)  # E: Value of type variable "Self" of "foo" of "G" cannot be "D"
        foo(self, self)  # E: Value of type variable "Self" of "foo" of "G" cannot be "Self"
        foo(G(), self)

        bar(C(), self)  # E: Value of type variable "Self" of "bar" of "G" cannot be "C"
        bar(D(), self)  # E: Value of type variable "Self" of "bar" of "G" cannot be "D"
        bar(self, self)  # E: Value of type variable "Self" of "bar" of "G" cannot be "Self"
        bar(G(), self)

        reveal_type(G.foo)  # N: Revealed type is "def [Self <: __main__.G[Any]] (self: Self, x: Any) -> Self"
        reveal_type(G.bar)  # N: Revealed type is "def [Self <: __main__.G[Any]] (self: Self, x: Any) -> Self"

class D(C): ...

[case class_lookup_with_self_generics_inheritance]
from typing import Self, Callable, TypeVar, Generic, ClassVar

def simple_dec(x: T) -> T: ...
T = TypeVar("T")
class G(Generic[T]):
    def foo(self, x: T) -> Self: ...

    @simple_dec
    def bar(self, x: T) -> Self: ...

class H(G[list[T]]): ...

class C:
    def x(self, one: type[G[int]], other: type[G[Self]], h: type[H[str]]) -> None:
        reveal_type(h.foo)  # N: Revealed type is "def [Self <: __main__.G[list[str]]] (self: Self, x: list[str]) -> Self"
        reveal_type(h.bar)  # N: Revealed type is "def [Self <: __main__.G[list[str]]] (self: Self, x: list[str]) -> Self"
        reveal_type(H.foo)  # N: Revealed type is "def [Self <: __main__.G[list[Any]]] (self: Self, x: list[Any]) -> Self"
        reveal_type(H.bar)  # N: Revealed type is "def [Self <: __main__.G[list[Any]]] (self: Self, x: list[Any]) -> Self"

        h.bar(G(), [""])
        h.bar(H(), [""])
        h.bar(H(), [1])  # E: List item 0 has incompatible type "int"; expected "str"
        h.bar(C(), [""]) # E: Value of type variable "Self" of "bar" of "G" cannot be "C"

        H.bar(G(), [""])
        H.bar(H(), [""])
        H.bar(H(), [1])
        H.bar(C(), [""])  # E: Value of type variable "Self" of "bar" of "G" cannot be "C"

        h.foo(G(), [""])
        h.foo(H(), [""])
        h.foo(H(), [1])   # E: List item 0 has incompatible type "int"; expected "str"
        h.foo(C(), [""])  # E: Value of type variable "Self" of "foo" of "G" cannot be "C"

        H.foo(G(), [""])
        H.foo(H(), [""])
        H.foo(H(), [1])
        H.foo(C(), [""])  # E: Value of type variable "Self" of "foo" of "G" cannot be "C"

class D(C): ...

[case class_initiation_self_matching]
from typing import Self

class Foo:
    def __init__(self, other: Self): ...
    def foo(self, other: Self) -> None: ...

class Bar:
    def f(self, foo: Foo, bar: Bar) -> None:
        Foo(self)  # E: Argument 1 to "Foo" has incompatible type "Self"; expected "Self"
        foo.foo(self)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Self"; expected "Self"
        Foo(foo)
        foo.foo(foo)

        Foo(bar)  # E: Argument 1 to "Foo" has incompatible type "Bar"; expected "Self"
        foo.foo(bar)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Bar"; expected "Self"

[case class_initiation_self_matching_final]
from typing import Self, final

@final
class Foo:
    def __init__(self, other: Self): ...
    def foo(self, other: Self) -> None: ...

@final
class Bar:
    def f(self, foo: Foo, bar: Bar) -> None:
        Foo(self)  # E: Argument 1 to "Foo" has incompatible type "Self"; expected "Self"
        foo.foo(self)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Self"; expected "Self"
        Foo(foo)
        foo.foo(foo)

        Foo(bar)  # E: Argument 1 to "Foo" has incompatible type "Bar"; expected "Self"
        foo.foo(bar)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Bar"; expected "Self"

[case class_initiation_self_matching_generic]
from typing import Self, Generic, TypeVar
T = TypeVar("T")

class Foo(Generic[T]):
    def __init__(self, other: Self): ...
    def foo(self, other: Self) -> None: ...

class Bar:
    def f(self, foo_int: Foo[int], foo_str: Foo[str]) -> None:
        foo_int.foo(self)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Self"; expected "Self"
        foo_str.foo(self)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Self"; expected "Self"

        Foo[int](foo_int)
        Foo[str](foo_int)  # E: Argument 1 to "Foo" has incompatible type "Foo[int]"; expected "Self"

        foo_int.foo(foo_int)
        foo_int.foo(foo_str)  # E: Argument 1 to "foo" of "Foo" has incompatible type "Foo[str]"; expected "Self"

[case overload_self_type_matching]
from typing import Any, overload, Self
class A: ...
class B(A):
    @overload
    def foo(self, other: Self) -> Self: ...
    @overload
    def foo(self, other: int) -> None: ...
    def foo(self, other: Self) -> Self | None: ...  # E: Overloaded function implementation does not accept all possible arguments of signature 2

    @overload
    def bar(self, other: Self) -> Self: ...
    @overload
    def bar(self, other: None) -> int: ...
    def bar(self, other: Self) -> Self | int: ...  # E: Overloaded function implementation does not accept all possible arguments of signature 2

    @overload
    def baz(self, other: C) -> int: ...
    @overload
    def baz(self, other: A) -> int: ...
    def baz(self, other: Self) -> int: ...  # E: Overloaded function implementation does not accept all possible arguments of signature 2

    @overload
    def blub(self, other: int) -> A: ...
    @overload
    def blub(self, other: str) -> C: ...
    def blub(self, other: int | str) -> Self: ...  # E: Overloaded function implementation cannot produce return type of signature 1

    @overload
    def bla(self, other: C, x: int) -> A: ...
    @overload
    def bla(self, other: A, x: str) -> C: ...
    @overload
    def bla(self, other: C, x: bytes) -> C: ...
    @overload
    def bla(self, other: A, x: float) -> A: ...
    def bla(self, other: Self, x: Any) -> Self: ...  # E: Overloaded function implementation does not accept all possible arguments of signature 2 \
                                                     # E: Overloaded function implementation does not accept all possible arguments of signature 4 \
                                                     # E: Overloaded function implementation cannot produce return type of signature 1 \
                                                     # E: Overloaded function implementation cannot produce return type of signature 4

class C(B): ...
