[case self_as_base_class]
from typing import Self
class Foo(Self): ...  # E: Invalid base class "Self" \
                      # E: Invalid type
class Foo(list[Self]): ...  # E: Invalid type

[case self_as_nested_base_class]
from typing import Self
class Foo:
    class Bar(list[Self]): ...  # E: Invalid type

[case self_invalid_annotation]
from typing import Self
x: Self  # E: Invalid type
def foo(self):
    x: Self  # E: Invalid type

[case self_valid_annotation]
from typing import Self
class Foo:
    x: Self
    def foo(self):
        x: Self

[case self_invalid_function]
from typing import Self
def foo(self: Self) -> None:  ...  # E: Invalid type
def foo() -> Self: ...  # E: Invalid type

[case self_valid_method]
from typing import Self
class Foo:
    x: int
    def return_self(self: Self) -> Self:
        reveal_type(self.x)  # N: Revealed type is "int"
        reveal_type(self)  # N: Revealed type is "Self"
        return self

[case self_valid_method_untyped_input]
from typing import Self
class Foo:
    x: int
    def return_self(self) -> Self:
        reveal_type(self.x)  # N: Revealed type is "int"
        reveal_type(self)  # N: Revealed type is "Self"
        return self

reveal_type(Foo().return_self())  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().return_self().x)  # N: Revealed type is "int"

[case self_instance_variable1]
from typing import Self
class Foo:
    x: Self
    y: int
    def foo(self) -> Self:
        self.x = self
        return self.x

reveal_type(Foo().x)  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().x.y)  # N: Revealed type is "int"

[case self_instance_variable2]
from typing import Self
class Foo:
    x: Self
    y: int
    def foo(self) -> None: ...

reveal_type(Foo().x)  # N: Revealed type is "__main__.Foo"
reveal_type(Foo().x.y)  # N: Revealed type is "int"

[case self_instance_variable3]
from typing import Self
class Foo:
    x: Self
    def foo(self) -> Self:
        return self.x
