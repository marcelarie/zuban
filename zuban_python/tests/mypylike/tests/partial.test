[case infer_partial_list_with_changes_to_non_self]
# Like testInferAttributeInitializedToEmptyNonSelf, but with an explicit annotation
from typing import Self

class C:
    def __init__(self) -> None:
        self.a = []  # E: Need type annotation for "a" (hint: "a: List[<type>] = ...")
        if bool():
            a: Self = self
            a.a = [1]
            a.a.append(1)
reveal_type(C().a)  # N: Revealed type is "builtins.list[Any]"

[case partial_list_any_aug_assignment]

x = []
x += [undefined]  # E: Name "undefined" is not defined
reveal_type(x)  # N: Revealed type is "list[Any]"

y = []
y += undefined  # E: Name "undefined" is not defined
reveal_type(y)  # N: Revealed type is "list[Any]"

[case partial_list_any_aug_assignment_in_self]

class Foo:
    def __init__(self) -> None:
        self.x = []
        self.x += [undefined]  # E: Name "undefined" is not defined
        reveal_type(self.x)  # N: Revealed type is "list[Any]"

        self.y = []
        self.y += undefined  # E: Name "undefined" is not defined
        reveal_type(self.y)  # N: Revealed type is "list[Any]"

[case partial_list_aug_assignment_in_self]

class Foo:
    def __init__(self) -> None:
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

[case partial_list_never_aug_assignment]

x = []
x += []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = []  # E: Need type annotation for "y" (hint: "y: List[<type>] = ...")
y += []
reveal_type(y)  # N: Revealed type is "list[Any]"

[case module_mutual_flow_analysis_partial_list]
# flags: --warn-unreachable
import a
reveal_type(a.foo)  # N: Revealed type is "list[int]"
[file a.py]
bar = []
bar.append(1)
foo = bar
reveal_type(foo)  # N: Revealed type is "list[int]"

[case walrus_with_partial_list]
# flags: --warn-unreachable
# Like testWalrusPartialTypes, but with a bit of additional code as well
from typing import List

def check_partial_list() -> None:
    if (z := []):
        print(1)  # Theoretically this would be unreachable and could be analyzed as such as well.
    else:
        z.append(4)
    reveal_type(z)  # N: Revealed type is "list[int]"

[case partial_dict]
class A:
    def f(self) -> None:
        self.x = dict()
        self.x[1] = ""
        reveal_type(self.x)  # N: Revealed type is "dict[int, str]"

[case partial_defaultdict_with_set]
from collections import defaultdict
x = defaultdict(set)
x[1].add("")
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

y = defaultdict(set)
y[1].update([""])
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

[case partial_nullable_defaultdict_with_list_mypy_compatible]
# flags: --mypy-compatible
from collections import defaultdict
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = defaultdict(list)
        self.x[0].extend([""])
        reveal_type(self.x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

reveal_type(A().x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

[case partial_nullable_defaultdict_with_list_no_mypy_compatible]
# flags: --no-mypy-compatible
from collections import defaultdict
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = defaultdict(list)
        self.x[0].extend([""])
        reveal_type(self.x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

reveal_type(A().x)  # N: Revealed type is "collections.defaultdict[int, list[str]] | None"

[case narrowed_partial1_mypy_compatible]
# flags: --mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[str]"

[file foo.py]
from collections import defaultdict
x = None
x = []
x.append("")
reveal_type(x)  # N: Revealed type is "list[str]"

[case narrowed_partial1_no_mypy_compatible]
# flags: --no-mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[str] | None"

[file foo.py]
from collections import defaultdict
x = None
x = []
x.append("")
reveal_type(x)  # N: Revealed type is "list[str]"

[case narrowed_partial2_mypy_compatible]
import foo
reveal_type(foo.x)  # N: Revealed type is "dict[int, str]"

[file foo.py]
from collections import defaultdict
x = None
x = {}
x[0] = ""
reveal_type(x)  # N: Revealed type is "dict[int, str]"

[case narrowed_partial2_no_mypy_compatible]
import foo
reveal_type(foo.x)  # N: Revealed type is "dict[int, str] | None"

[file foo.py]
from collections import defaultdict
x = None
x = {}
x[0] = ""
reveal_type(x)  # N: Revealed type is "dict[int, str]"
