[case invalid_namespace_types_import_name]
import foo
import foo as bar
import foo.bar as baz

a: foo.bar.X
b: bar.bar.X
c: baz.X

x: foo  # E: Module "foo" is not valid as a type \
        # N: Perhaps you meant to use a protocol matching the module structure?
y: foo.bar  # E: Module "foo.bar" is not valid as a type \
            # N: Perhaps you meant to use a protocol matching the module structure?
z: bar  # E: Module "foo" is not valid as a type \
        # N: Perhaps you meant to use a protocol matching the module structure?
u: baz  # E: Module "foo.bar" is not valid as a type \
        # N: Perhaps you meant to use a protocol matching the module structure?
v: foo.undefined  # E: Name "foo.undefined" is not defined
[file foo/bar.py]
class X: ...

[case invalid_namespace_types_import_name_nested]
import foo

a: foo.bar.bla.X

x: foo.bar # E: Module "foo.bar" is not valid as a type \
           # N: Perhaps you meant to use a protocol matching the module structure?

[file foo/bar/bla.py]
class X: ...

[case invalid_namespace_types_import_from]
from foo import bar
from foo import bla  # E: Module "foo" has no attribute "bla"
from foo import bar as bbb

a: bar.bla.X
b: bbb.bla.X
c: bla  # No error here, because there's already an import error

x: bar  # E: Module "foo.bar" is not valid as a type \
        # N: Perhaps you meant to use a protocol matching the module structure?
y: bbb  # E: Module "foo.bar" is not valid as a type \
        # N: Perhaps you meant to use a protocol matching the module structure?
z: bar.bla # E: Module "foo.bar.bla" is not valid as a type \
           # N: Perhaps you meant to use a protocol matching the module structure?
u: bbb.bla # E: Module "foo.bar.bla" is not valid as a type \
           # N: Perhaps you meant to use a protocol matching the module structure?
v: bbb.X  # E: Name "bbb.X" is not defined
[file foo/bar/bla.py]
class X: ...

[case namespace_usage]
from foo import bar
from foo import bar as b
import foo as f
import foo

reveal_type(bar.bla.x)  # N: Revealed type is "int"
reveal_type(b.bla.x)  # N: Revealed type is "int"
reveal_type(f.bar.bla.x)  # N: Revealed type is "int"
reveal_type(foo.bar.bla.x)  # N: Revealed type is "int"
[file foo/bar/bla.py]
x: int

[case namespace_matching]
from foo import bar
import foo

def bla() -> None:
    import foo as foo2
    from foo import bar as bar2
    if bool():
        foo2 = foo  # E: Incompatible types in assignment (expression has type "ModuleType", variable has type "ModuleType")
    if bool():
        bar2 = bar  # E: Incompatible types in assignment (expression has type "ModuleType", variable has type "ModuleType")
    if bool():
        foo2 = bar  # E: Incompatible types in assignment (expression has type "ModuleType", variable has type "ModuleType")
    if bool():
        bar2 = foo  # E: Incompatible types in assignment (expression has type "ModuleType", variable has type "ModuleType")

[file foo/bar/bla.py]

[case namespace_submodule_lookup]
import foo
from foo import bar

foo.bar.bla.lala
foo.bar.undefined  # E: "ModuleType" has no attribute "undefined"
bar.bla.lala
bar.bla.undefined  # E: Module has no attribute "undefined"

[file foo/__init__.py]
[file foo/bar/bla.py]
lala = 1
