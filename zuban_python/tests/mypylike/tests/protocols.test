[case protocol_class_access_with_self_type_check_without_ignoring_params_names]
-- From testProtocolTypeTypeSelfTypeInstanceMethod
from typing import Protocol, Type, TypeVar, Union

T = TypeVar("T")
class P(Protocol):
    def foo(ob, self: T) -> T: ...

class B:
    def foo(self: T) -> T: ...
class C:
    def foo(self: T) -> Union[T, int]: ...

def test(arg: P) -> None: ...
b: Type[B]
c: Type[C]
test(b)  # OK
test(c)  # E: Argument 1 to "test" has incompatible type "Type[C]"; expected "P" \
         # N: Following member(s) of "C" have conflicts: \
         # N:     Expected: \
         # N:         def [T] foo(self: T) -> T \
         # N:     Got: \
         # N:         def [T] foo(self: T) -> Union[T, int]

[case protocol_with_ellipsis_default]
from typing import Protocol
class Foo(Protocol):
    def foo(self, x: int = ...) -> None: ...

[case protocol_class_object_callable_possible]
-- testProtocolClassObjectCallableError a bit modified
from typing import Protocol, Any, Callable

class P(Protocol):
    def __call__(self, app: int) -> Callable[[str], None]:
        ...

class Q(Protocol):
    def __call__(self, app: str) -> Callable[[str], None]:
        ...

class R(Protocol):
    def __call__(self, app: str) -> Callable[[int], None]:
        ...

class C:
    def __init__(self, app: str) -> None:
        pass

    def __call__(self, el: str) -> None:
        return None

p: P = C  # E: Incompatible types in assignment (expression has type "Type[C]", variable has type "P") \
          # N: Following member(s) of "C" have conflicts: \
          # N:     Expected: \
          # N:         def __call__(app: int) -> Callable[[str], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C
q: Q = C
r: R = C  # E: Incompatible types in assignment (expression has type "Type[C]", variable has type "R") \
          # N: Following member(s) of "C" have conflicts: \
          # N:     Expected: \
          # N:         def __call__(app: str) -> Callable[[int], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C

[case supports_keys_and_getitem_propagation]
from typing import TypeVar, Tuple
from _typeshed import SupportsKeysAndGetItem

S = TypeVar('S')
T = TypeVar('T')
def foo(x: SupportsKeysAndGetItem[S, T]) -> Tuple[S, T]: ...

x: Tuple[int, str] = foo(reveal_type({}))  # N: Revealed type is "dict[int, str]"
