[case dataclass_any_inherited_nested]
# Checks issues of testDataclassesAnyInherit but with additional inheritance
from dataclasses import dataclass
from typing import Any
A: Any
@dataclass
class B(A):
    a: int

@dataclass
class C(B):
    b: str

reveal_type(C) # N: Revealed type is "def (a: int, b: str, *Any, **Any) -> __main__.C"
C(a=1, b="", c=2)
C(1, 1)  # E: Argument 2 to "C" has incompatible type "int"; expected "str"
C(a="foo", b="")  # E: Argument "a" to "C" has incompatible type "str"; expected "int"

[case dataclass_method_binding1]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

class B(A):
    y: int

x = B(1).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1))
type(z)(x=3)

[case dataclass_method_binding2]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

@dataclass
class B(A):
    y: int

x = B(1, 2).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3, y=4)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1, 2))
type(z)(x=3, y=2)

a = A.foo(A(1))
reveal_type(a)  # N: Revealed type is "__main__.A"
type(a)(x=3)

[case dataclass_inheritance_method_generics_with_normal_class]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

class C(A[List[T]]): ...

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "List[int]"

[case dataclass_inheritance_method_generics_with_dataclass]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1, "")
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass
class C(A[List[T]]):
    y: str

C(1, "")  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1], "")
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass_no_init]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass(init=False)
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1, "")
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass(init=False)
class C(A[List[T]]):
    y: str

C(1, "")  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1], "")
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_self_in_inheritance]
from typing import Self
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def foo(self) -> Self: return self

@dataclass()
class B(A):
    y: str

x = B(1, "").foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(2, "")
type(x)(2, 2)  # E: Argument 2 to "B" has incompatible type "int"; expected "str"

class C(A):
    y: str

y = C(1)
reveal_type(y)  # N: Revealed type is "__main__.C"
type(y)("")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
type(y)(1)
