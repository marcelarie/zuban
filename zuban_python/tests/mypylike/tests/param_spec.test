[case param_spec_with_generics]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

_P = ParamSpec("_P")
_T = TypeVar("_T")

class Job(Generic[_P, _T]):
    def __init__(self, target: Callable[_P, _T]) -> None: ...
    def into_callable(self) -> Callable[_P, _T]: ...

def generic_f(x: _T) -> _T: ...

j = Job(generic_f)
reveal_type(j)  # N: Revealed type is "__main__.Job[[x: _T], _T]"

jf = j.into_callable()
reveal_type(jf)  # N: Revealed type is "def [_T] (x: _T) -> _T"
reveal_type(jf(1))  # N: Revealed type is "int"
reveal_type(jf(""))  # N: Revealed type is "str"

[case param_spec_with_generics_combined]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec, Concatenate

_P = ParamSpec("_P")
_T = TypeVar("_T")
_U = TypeVar("_U")

class Job(Generic[_P, _T]):
    def __init__(self, target: Callable[_P, _T]) -> None: ...
    def into_callable(self) -> Callable[Concatenate[_U, _P], tuple[_U, list[_T]]]: ...

def generic_f(x: _T) -> _T: ...

j = Job(generic_f)
reveal_type(j)  # N: Revealed type is "__main__.Job[[x: _T], _T]"

jf = j.into_callable()
reveal_type(jf)  # N: Revealed type is "def [_U, _T] (_U, x: _T) -> tuple[_U, list[_T]]"
reveal_type(jf(1.0, 1))  # N: Revealed type is "tuple[float, list[int]]"
reveal_type(jf(1, ""))  # N: Revealed type is "tuple[int, list[str]]"

[case param_spec_with_generic_class]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec, Concatenate

_P = ParamSpec("_P")
_T = TypeVar("_T")
_U = TypeVar("_U")

class Job(Generic[_P, _T]):
    def __init__(self, target: Callable[_P, _T]) -> None: ...
    def into_callable(self) -> Callable[Concatenate[_U, _P], tuple[_U, list[_T]]]: ...

class X(Generic[_T]):
    def __init__(self, y: set[_T]): ...

j = Job(X)
reveal_type(j)  # N: Revealed type is "__main__.Job[[y: set[_T]], __main__.X[_T]]"

jf = j.into_callable()
reveal_type(jf)  # N: Revealed type is "def [_U, _T] (_U, y: set[_T]) -> tuple[_U, list[__main__.X[_T]]]"
reveal_type(jf(1.0, {1}))  # N: Revealed type is "tuple[float, list[__main__.X[int]]]"
reveal_type(jf(1, {""}))  # N: Revealed type is "tuple[int, list[__main__.X[str]]]"

[case param_spec_with_identity_mypy_issue_12278]
from typing import Callable, ParamSpec, TypeVar

T = TypeVar("T")

P = ParamSpec("P")
R = TypeVar("R")

def call(f: Callable[P, R], *args: P.args, **kwargs: P.kwargs) -> R:
    return f(*args, **kwargs)

def identity(x: T) -> T:
    return x

call(identity, 2)  # error: Argument 2 to "call" has incompatible type "int"; expected "T"

y: int = call(identity, 2)

[case param_spec_aesthetic]
from typing import Generic, ParamSpec

P = ParamSpec("P")

class Z(Generic[P]): ...

t1: Z[int]
t2: Z[bytes, str]
reveal_type(t1)  # N: Revealed type is "__main__.Z[[builtins.int]]"
reveal_type(t2)  # N: Revealed type is "__main__.Z[[builtins.bytes, builtins.str]]"

[case alias_applying_param_spec]
# Similar to testConcatDeferralNoCrash
from typing import Callable, TypeVar
from typing_extensions import Concatenate, ParamSpec

P = ParamSpec("P")

Alias = Callable[P, bool]

def test(f: Alias[Concatenate[int, P]]) -> Callable[P, float]: ...

x: Callable[[int, int], bool]
y: Callable[[int, int, str], bool]
z: Callable[[int], bool]
reveal_type(test(x))  # N: Revealed type is "def (int) -> float"
reveal_type(test(y))  # N: Revealed type is "def (int, str) -> float"
reveal_type(test(z))  # N: Revealed type is "def () -> float"

f: Callable[[str], bool]
g: Callable[[int], str]
test(f)  # E: Argument 1 to "test" has incompatible type "Callable[[str], bool]"; expected "Callable[[int, Never], bool]"
test(g)  # E: Argument 1 to "test" has incompatible type "Callable[[int], str]"; expected "Callable[[int], bool]"
