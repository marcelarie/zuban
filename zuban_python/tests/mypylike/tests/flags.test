[case reveal_type_defined_in_untyped_func]
def reveal_type(a: str) -> None: ...
def foo():
    reveal_type(1)

[case union_alias_disallowed_any_expr_simple]
# flags: --disallow-any-explicit
from typing import Any, TypeAlias, Tuple

x1: TypeAlias = Any | int  # E: Explicit "Any" is not allowed
y1: TypeAlias = int | Any  # E: Explicit "Any" is not allowed

x2 = Any | int  # E: Explicit "Any" is not allowed
y2 = int | Any  # E: Explicit "Any" is not allowed

x: Tuple[x1, y1, x2, y2]

[case union_alias_disallowed_any_expr_nested]
# flags: --disallow-any-explicit
from typing import Any, TypeAlias, Tuple

x1: TypeAlias = list[Any] | int  # E: Explicit "Any" is not allowed
y1: TypeAlias = int | list[Any]  # E: Explicit "Any" is not allowed

x2 = list[Any] | int  # E: Explicit "Any" is not allowed
y2 = int | list[Any]  # E: Explicit "Any" is not allowed

x: Tuple[x1, y1, x2, y2]

[case redundant_casts_with_any_nested]
# flags: --warn-redundant-casts
from typing import cast

x: list[int]
cast(list[int], x) # E: Redundant cast to "list[int]"
cast(list[Any], x)

[case unannotated_return_in_method_with_disallow_untyped_defs]
# flags: --disallow-untyped-defs
# Like testUnannotatedReturnWithOnlySelfArgument, but fixed with context
class Foo:
    def f(self): pass
[out]
main:4: error: Function is missing a return type annotation
main:4: note: Use "-> None" if function does not return a value
