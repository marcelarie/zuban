[case single_line_typed_dict]
from typing import TypedDict

class A(TypedDict): x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
class B(TypedDict): x: str

reveal_type(A)  # N: Revealed type is "def (*, x: Any) -> TypedDict('__main__.A', {'x': Any})"
reveal_type(B)  # N: Revealed type is "def (*, x: str) -> TypedDict('__main__.B', {'x': str})"

[case unpack_optional_args]
from typing import TypedDict, Unpack
from typing_extensions import NotRequired

class A(TypedDict, total=False):
    x: int
    y: int

class B(TypedDict):
    x: int
    y: NotRequired[int]

def foo(**kwargs: Unpack[A]) -> None: ...
def bar(**kwargs: Unpack[B]) -> None: ...

foo()
bar()  # E: Missing named argument "x" for "bar"
foo(y=1)
bar(y=1)  # E: Missing named argument "x" for "bar"
foo(x=1)
bar(x=1)

[case invalid_typed_dict_inference]
# This used to lead to stack overflows
from typing import TypeVar
T = TypeVar("T")
U = TypeVar("U")
def foo(x: T) -> T:
    def bar(x: U, y: T) -> U: ...

    bar(1, {})  # E: Argument 2 to "bar" has incompatible type "dict[Never, Never]"; expected "T"
    return x

[case accessing_special_implementations]
from typing import TypedDict

class TD(TypedDict):
    x: int

def foo(x: TD) -> None:
    x.get.__sizeof__
