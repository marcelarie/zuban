[case unreachable_var_definition]
import mod
mod.foo  # E: Module has no attribute "foo"
mod.bar  # E: Module has no attribute "bar"
[file mod.py]
import sys
if sys.platform == 'lol':
    foo = 3
    def bar() -> None: ...

foo  # E: Name "foo" is not defined
bar  # E: Name "bar" is not defined

[case unreachable_var_definition_with_assert]
# flags: --mypy-compatible
import mod
mod.foo  # E: Module has no attribute "foo"
mod.bar  # E: Module has no attribute "bar"
mod.undefined  # E: Module has no attribute "undefined"
[file mod.py]
import sys
assert sys.platform == 'lol'
foo = 3
def bar() -> None: ...

foo
bar
undefined

[case unreachable_var_definition_with_return]
def func() -> None:
    if bool():
        return
        foo = 3
        def bar() -> None: ...

    foo  # E: Name "foo" is not defined
    bar  # E: Name "bar" is not defined
    undefined  # E: Name "undefined" is not defined

[case unreachable_var_definition_with_raise]
def func() -> None:
    if bool():
        raise; foo = 3
        def bar() -> None: ...

    foo  # E: Name "foo" is not defined
    bar  # E: Name "bar" is not defined
    undefined  # E: Name "undefined" is not defined

[case unreachable_var_after_assert_false]
# flags: --warn-unreachable
from typing import Literal, TYPE_CHECKING
x: Literal[False]
def func1() -> None:
    assert False; undefined1  # E: Statement is unreachable
    undefined2
def func2() -> None:
    assert x; undefined1  # E: Statement is unreachable
    undefined2
def func3() -> None:
    assert not TYPE_CHECKING; undefined1  # E: Statement is unreachable
    undefined2

[case conjunction_partial_inference_combination_issue]
# This was an issue, because flow analysis for conjunction can lead to
# multiple times trying to infer partials (which are not even used here).
import os
def foo() -> None:
    x = 1 and os.path.islink("").conjugate(1)  # E: Too many arguments for "conjugate" of "int"

[case avoid_type_computation_recursion]

[file foo.py]
from typing import Generic
from bar import X
class Foo(Generic[X]): ...
[file bar.py]
from typing import TypeVar
import foo

if bool():  # Causes flow analysis to happen
    X = TypeVar("X")

def here() -> None:
    reveal_type(foo.Foo())

[case flow_analysis_should_be_avoided_for_simple_imports]
import foo
for x in [1]:
    foo.bar  # This used to cause "Cannot use Final inside a loop" in foo.py

[file foo.py]
from typing import Final
bar: Final = 1

[case flow_analysis_circular_dependency]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import X
if bool(): # Causes flow analysis
    def foo() -> X: ...

class Y: ...
[file bar.py]
from foo import Y
if bool(): # Causes flow analysis
    def bar() -> Y: ...

class X: ...

[case flow_analysis_global_context_should_not_be_loop_context]
# flags: --mypy-compatible
import foo

def f(x: foo.X) -> None:
    x.abc

[file foo.py]
from typing import Final

bar: Final = 1

class X:
    def __init__(self) -> None:
        for x in (1,):
            self.abc = bar

[case flow_analysis_circular_import_but_simple_assign_is_fine]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import x1, x2, x3  # E: Cannot determine type of "x1"
if bool(): # Causes flow analysis
    ...

y1 = str()
y2 = 1
y3: int = 1
[file bar.py]
from foo import y1, y2, y3
if bool(): # Causes flow analysis
    ...

class X: ...

x1 = str()
x2 = 1
x3: int = 1
